INCLUDE "vars.zkasm"

start:
; First of all, load The call Data.  The first A value is forced with the hash of the TX. 
        ${getGlobalHash()} => A                                   ; In A register we have the TXHash
        A                               :MSTORE(globalHash) 

        ${getOldStateRoot()}=>SR        :HASHW(0)

        ${getNTxs()} => A               :MSTORE(pendingTxs)                           ; In Number of Txs to process

        $${var curTx = 0}                        

txLoop:
        $ => A          : MLOAD(pendingTxs)
        A-1 =>  A       : MSTORE(pendingTxs) 
        A               : JMPC(processTxsEnd)

        $ => A          : MLOAD(lastCtxUsed)                           ; Set the CTX and store in system 
        A+1 => CTX      : MSTORE(lastCtxUsed)

                        : JMP(processTx)

processTxEnd:
        $${curTx = curTx +1}
                        : JMP(txLoop)

processTxsEnd: 

        SR              : HASHW(0)
                        : HASHE(0)

        $ => A          : MLOAD(globalHash)
        $ => B          : HASHR(0), ASSERTAB

        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM                 ; Set all registers to 0
finalLoop:
        STEP-0x100000-1  : JMPC(finalLoop)

                         : JMP(start)

INCLUDE "process_tx.zkasm"

