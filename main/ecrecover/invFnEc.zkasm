;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; invFnEc B = inv(A)
;;
;; PRE: A no alias-free
;; POST: B no alias-free (on MAP)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; RESOURCES:
;   non-normalized: 2 ariths + 2 binaries + 12 steps
;   normalized: 2 ariths + 1 binaries + 11 steps
;   TOTAL (worst case): 2 ariths + 2 binaries + 12 steps

VAR GLOBAL invFnEc_tmp

invFnEc:

        %SECP256K1_N => B
        $       :LT,JMPC(invFnEc_normalized)
        $ => A  :SUB

invFnEc_normalized:
        0 => C

        ; B = inv(A)
        ${var _invFnEc_A = inverseFnEc(A)} => B :MSTORE(invFnEc_tmp)
        ; A * B + 0 = [D] * 2 ** 256 + [E]

        $${var _invFnEc_AB = A * B}

        ${_invFnEc_AB >> 256} => D
        ${_invFnEc_AB} => E :ARITH

        ;
        ; with committed E,D
        ; FnEc * [k] + 1 = D * 2 ** 256 + E
        ;

        1 => C
        ${_invFnEc_AB / const.SECP256K1_N} => B
        %SECP256K1_N => A

        E :ARITH
        $ => B   :MLOAD(invFnEc_tmp), RETURN