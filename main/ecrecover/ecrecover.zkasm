;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; ecrecover:
;;             in: A = hash, B = r, C = s, D = v
;;             out: A = result, B = result_code
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

VAR GLOBAL ecrecover_hash
VAR GLOBAL ecrecover_r
VAR GLOBAL ecrecover_s
VAR GLOBAL ecrecover_v
VAR GLOBAL ecrecover_r_inv
VAR GLOBAL ecrecover_y
VAR GLOBAL ecrecover_y2
VAR GLOBAL ecrecover_k1
VAR GLOBAL ecrecover_k2
VAR GLOBAL ecrecover_RR
VAR GLOBAL ecrecover_v_parity
VAR GLOBAL ecrecover_s_upperlimit

INCLUDE "constSecp256k1.zkasm"

; ERROR CODES (B)
; 0 - no error
; 1 - r is zero
; 2 - r is too big
; 3 - s is zero
; 4 - s is too big
; 5 - v not valid value (1b, 1c)
; 6 - sqrt of y does not exist
; 100 - sqrt failed, but it has a solution (!!!)

; MAP: MAlicious Prover

; RESOURCES:
;   PATH without root:                   [steps: 1816, bin: 8,  arith: 505]
;   PATH with root:                      [steps: 6343, bin: 13, arith: 520, keccak: 1]
;   PATH with result of dbl is infinity: [steps: 6332, bin: 12, arith: 520]
; --------------------------------------------------------------------------------------
;  worst case:                           [steps: 6343, bin: 13, arith: 520, keccak: 1]

ecrecover_precompiled:
        %SECP256K1_N_MINUS_ONE :MSTORE(ecrecover_s_upperlimit), JMP(ecrecover_store_args)

ecrecover_tx:
        %SECP256K1_N_DIV_TWO   :MSTORE(ecrecover_s_upperlimit)

ecrecover_store_args:

        ; save arguments
        A           :MSTORE(ecrecover_hash)
        B           :MSTORE(ecrecover_r)
        C           :MSTORE(ecrecover_s)
        D           :MSTORE(ecrecover_v)

        %MAX_CNT_BINARY - CNT_BINARY - 15       :JMPN(outOfCountersBinary)
        %MAX_CNT_ARITH - CNT_ARITH - 520        :JMPN(outOfCountersArith)
        %MAX_CNT_STEPS - STEP - 6350            :JMPN(outOfCountersStep)

        %MAX_CNT_KECCAK_F - CNT_KECCAK_F - 1    :JMPN(outOfCountersKeccak)

        ; save RR to call return at end of routine
        RR          :MSTORE(ecrecover_RR)

        ; r in [1, SECP256K1_N-1]
        0 => A
        $ => B      :MLOAD(ecrecover_r)
        $           :EQ, JMPC(ecrecover_r_is_zero)
        %SECP256K1_N_MINUS_ONE => A
        $           :LT, JMPC(ecrecover_r_is_too_big)

        ; s in [1, ecrecover_s_upperlimit]
        0 => A
        $ => B      :MLOAD(ecrecover_s)
        $           :EQ, JMPC(ecrecover_s_is_zero)
        $ => A      :MLOAD(ecrecover_s_upperlimit)
        $           :LT, JMPC(ecrecover_s_is_too_big)
        ; [steps: 23, bin: 4]

        0x1Bn => B ; 27
        $ => A      :MLOAD(ecrecover_v)
        $ => E      :EQ, JMPNC(ecrecover_v_not_eq_1b)

        ;  ecrecover_v_eq_1b:
        0n          :MSTORE(ecrecover_v_parity), JMP(ecrecover_v_ok)
        ; 1] [steps: 27, bin: 5]

ecrecover_v_not_eq_1b:
        0x1Cn => B ; 28
        ; ecrecover_v_eq_1c:
        $ => E      :EQ, MSTORE(ecrecover_v_parity), JMPNC(ecrecover_v_not_eq_1b1c)
        ; 2] [steps: 29, bin: 6]

ecrecover_v_ok:
        ; before (w.c.) -> [steps: 29, bin: 6]
        ;
        ; y² = x³ + 7
        ;
        ; A·B·A + 7 = calculate y from x
        ;

        %SECP256K1_P => D

        ; Square r
        $ => A,B      :MLOAD(ecrecover_r)
        0 => C
        ${(A*B) % D} => A   :ARITH_MOD
        ; A = r², B = r, C = 0

        ; Mul r² by r
        ${(A*B) % D} => C   :ARITH_MOD
        ; A = r², B = r, C = r³

        ; Add 7 to r³
        7 => A
        1 => B
        ${(A + C) % D} => C   :ARITH_MOD, MSTORE(ecrecover_y2)
        ; A = 7, B = 1, C = r³ + 7

        ; load on A parity expected
        ; [steps: 42, bin: 6, arith: 3]
        $ => A      :MLOAD(ecrecover_v_parity), CALL(sqrtFpSecp256k1) ;   with sqrt: [steps: 9, bin: 1, arith: 1]
                                                                      ;without sqrt: [steps: 4, bin: 1, arith: 0]

        ; If it has root C = 0, else B = 1
        ; If C = 0 => B is alias-free (see sqrtFpSecp256k1)

        C           :JMPZ(ecrecover_has_sqrt)
        ; [steps: 49, bin: 7, arith: 3]

        ; hasn't sqrt, now verify

        $ => C      :MLOAD(ecrecover_y2), CALL(assertNQRFpSecp256k1) ; [steps: 1761, bin: 1, arith: 502]

                    :JMP(ecrecover_not_exists_sqrt_of_y)
        ; till the end -> [steps: 1816, bin: 8, arith: 505]

ecrecover_has_sqrt:
        ; before -> [steps: 53, bin: 7, arith: 4]
        ; (v == 1b) ecrecover_y_parity = 0x00
        ; (v == 1c) ecrecover_y_parity = 0x01

        ; B: y = sqrt(y^2)  [it's alias free, verified in previous lines]
        B           :MSTORE(ecrecover_y)

        1 => A
        ; ASSERT ((y & 1) == ecrecover_v_parity), if it fails => MAP
        ${B & 1}    :AND, MLOAD(ecrecover_v_parity)

        ; how solution y = 0 not exists because -7 not has a cubic root,

        ; compute r inverse
        $ => A      :MLOAD(ecrecover_r)
        ${var _invFnSecp256k1_A = inverseFnEc(A)} => B :MSTORE(ecrecover_r_inv)
        0 => C
        %SECP256K1_N => D
        1n                      :ARITH_MOD

        ; calculate A as (hash * inv_r) % SECP256K1_N
        $ => A      :MLOAD(ecrecover_hash)
        ${(A*B) % D} => B   :ARITH_MOD

        ; calculate k1 as (SECP256K1_N - hash * inv_r) % SECP256K1_N
        ; B = (hash * inv_r) % SECP256K1_N is alias free
        0 => A
        ; B is zero, special case
        $   :EQ, JMPNC(k1_c_is_not_zero)
        ; [steps: 72, bin: 9, arith: 6]

k1_c_is_zero:
        ; k1 = 0 is alias-free
        0   :MSTORE(dblScalarMulSecp256k1_k1), JMP(k1_calculated)


k1_c_is_not_zero:
        ; before (w.c.) -> [steps: 72, bin: 9, arith: 6]

        ; B = (hash * inv_r) % SECP256K1_N

        ; SECP256K1_N - B = SECP256K1_N - (hash * inv_r) % SECP256K1_N
        %SECP256K1_N => A
        ; B != 0 ==> dblScalarMulSecp256k1_k1 = SECP256K1_N - B
        ; k1 is alias-free
        $   :SUB, MSTORE(dblScalarMulSecp256k1_k1)

k1_calculated:
        ; Compute s * inv_r
        $ => A             :MLOAD(ecrecover_s)
        $ => B             :MLOAD(ecrecover_r_inv)
        ; C = 0
        ; D = SECP256K1_N
        ${(A*B) % D}       :ARITH_MOD, MSTORE(dblScalarMulSecp256k1_k2)

        ;   C = (s * inv_r) % SECP256K1_N => k2
        ; [steps: 81, bin: 10, arith: 7]

        %SECP256K1_GX       :MSTORE(dblScalarMulSecp256k1_p1_x)
        %SECP256K1_GY       :MSTORE(dblScalarMulSecp256k1_p1_y)

        ; r isn't an alias because the range has been checked at beginning
        $ => A      :MLOAD(ecrecover_r)
        A           :MSTORE(dblScalarMulSecp256k1_p2_x)

        ; y isn't an alias because was checked before
        ; (r,y) is a point of curve because it satisfies the curve equation
        $ => A      :MLOAD(ecrecover_y)
        A           :MSTORE(dblScalarMulSecp256k1_p2_y), CALL(dblScalarMulSecp256k1) ; 513 arith + 2 binaries + 6239 steps

        ; check if result of dblScalarMulSecp256k1 is point at infinity
        $           :MLOAD(dblScalarMulSecp256k1_p3_zero), JMPNZ(ecrecover_p3_point_at_infinity)
        ; [steps: 6328, bin: 12, arith: 520]

        ; generate keccak of public key to obtain ethereum address
        $ => E         :MLOAD(nextHashKId)
        E + 1          :MSTORE(nextHashKId)
        0 => HASHPOS
        32 => D

        ; p3_x, p3_y are alias free because arithmetic guarantees it
        $ => A         :MLOAD(dblScalarMulSecp256k1_p3_x)
        A              :HASHK(E)
        $ => A         :MLOAD(dblScalarMulSecp256k1_p3_y)
        A              :HASHK(E)

        64             :HASHKLEN(E)
        $ => A         :HASHKDIGEST(E)

        ; for address take only last 20 bytes
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn => B
        $ => A         :AND
        ; till the end -> [steps: 6343, bin: 13, arith: 520]
        0 => B         :JMP(ecrecover_end)

; ERRORS
ecrecover_r_is_zero:
        1 => B      :JMP(ecrecover_error)

ecrecover_r_is_too_big:
        2 => B      :JMP(ecrecover_error)

ecrecover_s_is_zero:
        3 => B      :JMP(ecrecover_error)

ecrecover_s_is_too_big:
        4 => B      :JMP(ecrecover_error)

ecrecover_v_not_eq_1b1c:
        5 => B      :JMP(ecrecover_error)

ecrecover_not_exists_sqrt_of_y:
        6 => B      :JMP(ecrecover_error)

ecrecover_p3_point_at_infinity:
        7 => B      :JMP(ecrecover_error)

ecrecover_error:
        0 => A

ecrecover_end:
        $ => RR     :MLOAD(ecrecover_RR)
        :RETURN

INCLUDE "./FPSECP256K1/sqrtFpSecp256k1.zkasm"
INCLUDE "./FPSECP256K1/assertNQRFpSecp256k1.zkasm"

INCLUDE "dblScalarMulSecp256k1.zkasm"