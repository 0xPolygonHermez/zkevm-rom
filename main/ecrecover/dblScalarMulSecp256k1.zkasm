;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: p1 = (p1_x, p1_y), p2 = (p2_x, p2_y) are in E(Fp)\{𝒪} and p1_x,p1_y,p2_x,p2_y,k1,k2 are alias-free
;; POST: The resulting coordinates p3_x,p3_y are alias-free and HASHPOS ∈ {0,1}
;;
;; dblScalarMulSecp256k1:
;;             in: Points p1 = (p1_x, p1_y), p2 = (p2_x, p2_y) and scalars k1, k2
;;             out:
;;              · p3 = (p3_x, p3_y) ∈ E(Fp)
;;              · HASHPOS = 0 or 1, depending on whether p3 is the point at infinity or not
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; TODO: Optimizations 1
; -----------------------------
; RR*2 + 1 => RR
; HASHPOS*2 + 1 => HASHPOS

; $ => C            :MLOAD(dblScalarMulSecp256k1_acum_k1)
; ROTL_C + RR       :MSTORE(dblScalarMulSecp256k1_acum_k1)
; ; :O
; $ => C            :MLOAD(dblScalarMulSecp256k1_acum_k2)
; ROTL_C + HASHPOS:MSTORE(dblScalarMulSecp256k1_acum_k2)

; 0 => RR,HASHPOS

; TODO: Optimizations 2
;         RR - 1 => RR      :JMP(table + RR);

; table:
;                                 :JMP(dblScalarMulSecp256k1_save_k1k2)   ; RR = 0
;         HASHPOS                 :JMPZ(dblScalarMulSecp256k1_loop,l1)    ; RR = 1
;         HASHPOS                 :JMPZ(dblScalarMulSecp256k1_loop,l1)    ; RR = 2
;         HASHPOS                 :JMPZ(dblScalarMulSecp256k1_loop,l1)    ; RR = 3
;         HASHPOS                 :JMPZ(dblScalarMulSecp256k1_loop,l1)    ; RR = 4
;         HASHPOS                 :JMPZ(dblScalarMulSecp256k1_loop,l1)    ; RR = 5
;         HASHPOS                 :JMPZ(dblScalarMulSecp256k1_loop,l1)    ; RR = 6
;         :JMP(dblScalarMulSecp256k1_l1)    ; RR = 0
;                 :
;         :JMP(dblScalarMulSecp256k1_save)    ; RR = 0
;         HASHPOS                 :JMPZ(dblScalarMulSecp256k1_loop,l1)    ; RR = 256
; -----------------------------

; Since the curve is E: y² = x³ + 7, there is no issue in representing the point at infinity as (0, 0).

VAR GLOBAL dblScalarMulSecp256k1_p1_x
VAR GLOBAL dblScalarMulSecp256k1_p1_y
VAR GLOBAL dblScalarMulSecp256k1_p2_x
VAR GLOBAL dblScalarMulSecp256k1_p2_y
VAR GLOBAL dblScalarMulSecp256k1_k1
VAR GLOBAL dblScalarMulSecp256k1_k2

; p3 output point
VAR GLOBAL dblScalarMulSecp256k1_p3_x
VAR GLOBAL dblScalarMulSecp256k1_p3_y

; point p12 = p1 + p2
VAR GLOBAL dblScalarMulSecp256k1_p12_x
VAR GLOBAL dblScalarMulSecp256k1_p12_y

; dblScalarMulSecp256k1_p12_zero = 1 ==> p12 is the point at infinity
; dblScalarMulSecp256k1_p12_zero = 0 ==> p12 isn't the point at infinity
VAR GLOBAL dblScalarMulSecp256k1_p12_zero

; acummulators
VAR GLOBAL dblScalarMulSecp256k1_acum_k1
VAR GLOBAL dblScalarMulSecp256k1_acum_k2

; backups
VAR GLOBAL dblScalarMulSecp256k1_RR
VAR GLOBAL dblScalarMulSecp256k1_RCX

; RESOURCES (k1,k2):
;                1 arith + 23 steps                                     // setup, calculation p12
;              + number_of_bits_1(k1|k2) * arith                        // additions
;              + max_bin_len(k1,k2) * arith                             // doubles
;              + 29 * max_bin_len(k1,k2)                                // additions + doubles (steps, worst case)
;              + (8 - 5) steps                                          // last part - last part double no done
;              - 1 arith                                                // first assignation
;
;
; RESOURCES (worst case): 512 arith + 2 binaries + 7451 steps           // 23 + 256 * 29 + 3 = 7451

dblScalarMulSecp256k1:
        RR      :MSTORE(dblScalarMulSecp256k1_RR)

        RCX     :MSTORE(dblScalarMulSecp256k1_RCX)

        $${uintToBin2(mem.dblScalarMulSecp256k1_k1,mem.dblScalarMulSecp256k1_k2)}       ; convert k1 and k2 to binary

        ; TODO: I can directly say what C or D assign to RCX, I do not need this path
        $0{receiveLen(mem.dblScalarMulSecp256k1_k1)} => C     ; receive the length of the binary representation of k1
        $0{receiveLen(mem.dblScalarMulSecp256k1_k2)} => D     ; receive the length of the binary representation of k2

        ; assign to the loop counter RCX the length of the largest of k1 and k2
        C - D           :JMPN(__dblScalarMulSecp256k1_assign_len_k2)
        C => RCX        :JMP(__dblScalarMulSecp256k1_len_k1_assigned)
        __dblScalarMulSecp256k1_assign_len_k2:
        D => RCX
        __dblScalarMulSecp256k1_len_k1_assigned:

        ; start the acummulator of k1 and k2
        0       :MSTORE(dblScalarMulSecp256k1_acum_k1)
        0       :MSTORE(dblScalarMulSecp256k1_acum_k2)

        ; Initialize p3 = 𝒪
        0n => HASHPOS   :MSTORE(dblScalarMulSecp256k1_p3_x)
        0n              :MSTORE(dblScalarMulSecp256k1_p3_y)

        $ => A  :MLOAD(dblScalarMulSecp256k1_p1_x)
        $ => B  :MLOAD(dblScalarMulSecp256k1_p1_y)
        $ => C  :MLOAD(dblScalarMulSecp256k1_p2_x)
        $ => D  :MLOAD(dblScalarMulSecp256k1_p2_y)

        ; check p1_x == p2_x
        ; [steps: 14]
        ${A == C}     :JMPZ(dblScalarMulSecp256k1DiffInitialPoints)

        ; verify path p1_x == p2_x
        C             :ASSERT

        ; check p1_y == p2_y
        ; [steps: 16]
        ${B == D}     :JMPNZ(dblScalarMulSecp256k1SameInitialPoints)

        ; verify path p1_y != p2_y <==> p1_y = -p2_y or p1_y + p2_y = 0
        ; use arith because in this path save a lot of arith,
        ; because when add p12 do nothing.

        ; x must be distinct from 0, because the square root of 7 doesn't exist (y² = x³ + 7)
        ; y must be distinct from 0, because the cubic root of -7 doesn't exist (y² = x³ + 7)

        B => A        ; A = p1_y
        1 => B
        D => C        ; C = p2_y
        0 => D        ; check p1_y * 1 + p2_y = 0 * 2^256 * 0 + SECP256K1_P
        %SECP256K1_P         :ARITH
        ; We have p2 == -p1

        ; p12 = p1 - p1 = 𝒪, therefore is the point at infinity
        ; [steps: 23]
        1n            :MSTORE(dblScalarMulSecp256k1_p12_zero), JMP(dblScalarMulSecp256k1_loop)

dblScalarMulSecp256k1SameInitialPoints:
        ; [steps.before: 16]
        ; verify path p1_y (B) == p2_y (D)
        ; as an ASSERT(B == mulPointEc_p2_y)
        B             :MLOAD(dblScalarMulSecp256k1_p2_y)

        ; p12 = p1 + p1, therefore isn't the point at infinity
        0n                        :MSTORE(dblScalarMulSecp256k1_p12_zero)

        ; Compute and check the doubling p1 + p1
        ; A == p1_x
        ; B == p1_y
        ; (A,B) * 2 = (E, op)
        ${xDblPointEc(A,B)} => E  :MSTORE(dblScalarMulSecp256k1_p12_x)
        ${yDblPointEc(A,B)}       :ARITH_ECADD_SAME, MSTORE(dblScalarMulSecp256k1_p12_y), JMP(dblScalarMulSecp256k1_loop)

dblScalarMulSecp256k1DiffInitialPoints:
        ; [steps.before: 14]
        ; verify path p1_x != p2_x
        ; p2_x != p1_x ==> p2 != p1
        ; [MAP] if p1 == p2 => arith fails because p1 = p2

        ; p12 = p1 + p2, therefore isn't the point at infinity
        0n                            :MSTORE(dblScalarMulSecp256k1_p12_zero)

        ; Compute and check the addition p1 + p2
        ; (A, B) + (C, D) = (E, op)
        ${xAddPointEc(A,B,C,D)} => E  :MSTORE(dblScalarMulSecp256k1_p12_x)
        ${yAddPointEc(A,B,C,D)}       :ARITH_ECADD_DIFFERENT, MSTORE(dblScalarMulSecp256k1_p12_y)


; [steps.before (worst case): 23]

; Goes forward in different branches of code depending on the values of the
; most significant bits of k1 and k2.

; [steps.byloop (worst case): 12 + 17 = 29]

; [steps.byloop (p3initialempty.nolast): 12]
; [steps.byloop (bit.k1 || bit.k2 == 1): 8]
; [steps.byloop (bit.k1 && bit.k2 == 1): 12]

dblScalarMulSecp256k1_loop:
        ; Receive the next MSB b of k1.
        $0{receiveNextBit(mem.dblScalarMulSecp256k1_k1)}        :JMPNZ(dblScalarMulSecp256k1_k11)

; high_bit(k1) == 0 high_bit(k2) == ??
dblScalarMulSecp256k1_k10:
        ; Receive the next MSB b of k2.
        $0{receiveNextBit(mem.dblScalarMulSecp256k1_k2)}        :JMPNZ(dblScalarMulSecp256k1_k10_k21)

; high_bit(k1) == 0 high_bit(k2) == 0
dblScalarMulSecp256k1_k10_k20:
        $ => A  :MLOAD(dblScalarMulSecp256k1_p3_x)
        $ => B  :MLOAD(dblScalarMulSecp256k1_p3_y), JMP(dblScalarMulSecp256k1_double)

; high_bit(k1) == 1 high_bit(k2) == ??
dblScalarMulSecp256k1_k11:
        ; Receive the next MSB b of k2.
        $0{receiveNextBit(mem.dblScalarMulSecp256k1_k2)}        :JMPNZ(dblScalarMulSecp256k1_k11_k21)

; high_bit(k1) == 1 high_bit(k2) == 0
dblScalarMulSecp256k1_k11_k20:
        ; Keep reconstructing the scalar k1
        RCX - 1 => E
        $ => A          :MLOAD(dblScalarMulSecp256k1_acum_k1)
                        :CALL(@bitwiseReconstruction + E)
        A               :MSTORE(dblScalarMulSecp256k1_acum_k1)

        $ => C  :MLOAD(dblScalarMulSecp256k1_p1_x)
        $ => D  :MLOAD(dblScalarMulSecp256k1_p1_y), JMP(dblScalarMulSecp256k1_add)

; high_bit(k1) == 1 high_bit(k2) == 1
dblScalarMulSecp256k1_k11_k21:
        ; Keep reconstructing the scalars k1,k2
        RCX - 1 => E
        0 => A          :CALL(@bitwiseReconstruction + E)
        $ => B          :MLOAD(dblScalarMulSecp256k1_acum_k1)
        A + B           :MSTORE(dblScalarMulSecp256k1_acum_k1)
        $ => B          :MLOAD(dblScalarMulSecp256k1_acum_k2)
        A + B           :MSTORE(dblScalarMulSecp256k1_acum_k2)

        ; if (dblScalarMulSecp256k1_p12_zero) k11_k21 is the same as k10_k20
        ; because adding the point at infinity to a point is the point itself
        $       :MLOAD(dblScalarMulSecp256k1_p12_zero), JMPNZ(dblScalarMulSecp256k1_k10_k20)

        $ => C  :MLOAD(dblScalarMulSecp256k1_p12_x)
        $ => D  :MLOAD(dblScalarMulSecp256k1_p12_y), JMP(dblScalarMulSecp256k1_add)

; high_bit(k1) == 0 high_bit(k2) == 1
dblScalarMulSecp256k1_k10_k21:
        ; Keep reconstructing the scalar k2
        RCX - 1 => E
        $ => A          :MLOAD(dblScalarMulSecp256k1_acum_k2)
                        :CALL(@bitwiseReconstruction + E)
        A               :MSTORE(dblScalarMulSecp256k1_acum_k2)

        $ => C  :MLOAD(dblScalarMulSecp256k1_p2_x)
        $ => D  :MLOAD(dblScalarMulSecp256k1_p2_y), JMP(dblScalarMulSecp256k1_add)

; [steps.loadp2 (worst case): 7 (regular case 6)

; in this point C,D have point to be add
dblScalarMulSecp256k1_add:
        ; [steps.p3empty.nolast: 10]
        ; [steps.p3empty.last: 5]
        ; [steps.xeq.yeq: 9 + steps.double = 15]
        ; [steps.xeq.yneq: 11 + steps.double = 17]
        ; [steps.xneq.nolast: 7 + steps.double = 13]
        ; [steps.xneq.last: 7 + steps.double = 13]
        ; [steps.block: 17]

        ; if p3 is the point at infinity do not add, just assign, since 𝒪 + P = P
        HASHPOS   :JMPZ(dblScalarMulSecp256k1_p3_assignment)

        ; check whether p.x == p3.x
        ${ C == mem.dblScalarMulSecp256k1_p3_x } :JMPNZ(dblScalarMulSecp256k1_x_equals_before_add)

        ; [MAP] if C == mem.dblScalarMulSecp256k1_p3_x ==> fails arithmetic because check
        ; points are different

        ; p3 = (A,B)
        $ => A  :MLOAD(dblScalarMulSecp256k1_p3_x)
        $ => B  :MLOAD(dblScalarMulSecp256k1_p3_y)

        ; p3 = p3 + (C,D)
        ; (C, D) is point to add (p1 or p2 or p12)
        ; (A, B) + (C, D) = (E, op)
        ${xAddPointEc(A,B,C,D)} => E :MSTORE(dblScalarMulSecp256k1_p3_x)
        ${yAddPointEc(A,B,C,D)} => B :ARITH_ECADD_DIFFERENT, MSTORE(dblScalarMulSecp256k1_p3_y)

dblScalarMulSecp256k1_after_add:
        E => A  :JMP(dblScalarMulSecp256k1_double)

dblScalarMulSecp256k1_p3_assignment:
        ; p3 = (C,D)
        1 => HASHPOS    ; flag, dblScalarMulSecp256k1_p3 has a value, no-empty
        C => A   :MSTORE(dblScalarMulSecp256k1_p3_x)
        D => B   :MSTORE(dblScalarMulSecp256k1_p3_y)

dblScalarMulSecp256k1_double:
        ; [steps.last: 1]
        ; [steps.nolast.p3empty: 2]
        ; [steps.nolast.p3: 6]
        ; [steps.block: 6]

        ; E,A = p3_x  B = p3_y
        RCX - 1 => RCX    :JMPZ(dblScalarMulSecp256k1_end_loop)

        ; if p3 is the point at infinity do not double, since 𝒪 + 𝒪 = 𝒪
        HASHPOS           :JMPZ(dblScalarMulSecp256k1_loop)

        $ => A  :MLOAD(dblScalarMulSecp256k1_p3_x)
        $ => B  :MLOAD(dblScalarMulSecp256k1_p3_y)

        ; (A, B) * 2 = (E, op)
        ${xDblPointEc(A,B)} => E  :MSTORE(dblScalarMulSecp256k1_p3_x)
        ${yDblPointEc(A,B)}       :ARITH_ECADD_SAME, MSTORE(dblScalarMulSecp256k1_p3_y), JMP(dblScalarMulSecp256k1_loop)

dblScalarMulSecp256k1_x_equals_before_add:
        ; [steps.same.point: 7]
        ; [steps.opposite.point: 9]
        ; [steps.block: 9]

        ; [MAP] if C != mem.dblScalarMulSecp256k1_p3_x ==> fails, MLOAD fails because read something different
        ; for memory. It verifies C and dblScalarMulSecp256k1_p3_x are same value, as an ASSERT.
        C   :MLOAD(dblScalarMulSecp256k1_p3_x)

        ; points to add: point1 (p3) + point2 (C,D)

        ; C: point2.x
        ; D: point2.y

        ; p3_x == C, check if points are same or a point was opposite point

        ${ D ==  mem.dblScalarMulSecp256k1_p3_y } :JMPNZ(dblScalarMulSecp256k1_same_point_to_add)

        ; In this path must be verified that D != dblScalarMulSecp256k1_p3_y to
        ; how p2_y and p3_y are different for same x, it implies that
        ; p2_y == -p3_y. In this case next operation with p3 doesn't
        ; spend arithmetics, for this reason is used an arithmetic
        ; instead of binary to use similar resources on different paths.

        ; if p2_y == -p3_y, and them are alias free ==> p2_y + p3_y === SECP256K1_P

        1 => B
        D => A
        0 => D
        $ => C :MLOAD(dblScalarMulSecp256k1_p3_y)

        ; p2_y * 1 + p3_y = 2^256 * 0 + SECP256K1_P
        %SECP256K1_P :ARITH

        ; NOTE: all points are free of alias because arithmetic guarantees it

        ; HASHPOS flag = 0, dblScalarMulSecp256k1_p3 was empty, need addition must be an assignation
        0n => HASHPOS   :MSTORE(dblScalarMulSecp256k1_p3_x)
        0n              :MSTORE(dblScalarMulSecp256k1_p3_y), JMP(dblScalarMulSecp256k1_double)

dblScalarMulSecp256k1_same_point_to_add:
        ; [steps.block: 5]
        ; must check really are equals, use MLOAD as ASSERT
        ; ASSERT(D == dblScalarMulSecp256k1_p3_y)

        D       :MLOAD(dblScalarMulSecp256k1_p3_y)
        C => A
        D => B

        ; (A,B) * 2 = (E, op)
        ${xDblPointEc(A,B)} => E  :MSTORE(dblScalarMulSecp256k1_p3_x)
        ${yDblPointEc(A,B)} => B  :ARITH_ECADD_SAME, MSTORE(dblScalarMulSecp256k1_p3_y), JMP(dblScalarMulSecp256k1_after_add)

dblScalarMulSecp256k1_end_loop:
        ; [steps.block: 8]

        ; Check that the accumulated scalars coincide with the original ones
        $ => A      :MLOAD(dblScalarMulSecp256k1_k1)
        $ => B      :MLOAD(dblScalarMulSecp256k1_acum_k1)
        1           :EQ
        $ => A      :MLOAD(dblScalarMulSecp256k1_k2)
        $ => B      :MLOAD(dblScalarMulSecp256k1_acum_k2)
        1           :EQ

        $ => RR         :MLOAD(dblScalarMulSecp256k1_RR)
        $ => RCX        :MLOAD(dblScalarMulSecp256k1_RCX), RETURN
