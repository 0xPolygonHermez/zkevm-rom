;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; invFpEc B = inv(A)
;;
;; PRE: A no alias-free
;; POST: B no alias-free (on MAP)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; RESOURCES:
;   non-normalized: 2 ariths + 2 binaries + 12 steps
;   normalized: 2 ariths + 1 binaries + 11 steps
;   TOTAL (worst case): 2 ariths + 2 binaries + 12 steps

VAR GLOBAL invFpEc_tmp

invFpEc:

        %SECP256K1_P => B
        $       :LT,JMPC(invFpEc_normalized)
        $ => A  :SUB

invFpEc_normalized:
        0n => C
        ; B = inv(A)

        ${var _invFpEc_A = inverseFpEc(A)} => B :MSTORE(invFpEc_tmp);

        ; A * B + 0 = [D] * 2 ** 256 + [E]

        $${var _invFpEc_AB = A * _invFpEc_A}

        ${_invFpEc_AB >> 256} => D
        ${_invFpEc_AB} => E :ARITH

        ;
        ; with committed E,D
        ; FpEc * [k] + 1 = D * 2 ** 256 + E
        ;

        1n => C
        ${_invFpEc_AB / const.SECP256K1_P} => B
        %SECP256K1_P => A

        E :ARITH
        $ => B   :MLOAD(invFpEc_tmp),RETURN