
opJUMP:

    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 1 => SP                    :JMPN(stackUnderflow)
    $ => PC                         :MLOAD(SP)
    GAS - 8 => GAS                  :JMPN(outOfGas)
    ; Check PC is a JUMPDEST
    :JMP(checkJumpDest)

opJUMPI:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 2 => SP                    :JMPN(stackUnderflow)
    $ => B                          :MLOAD(SP)
    GAS - 10 => GAS                 :JMPN(outOfGas)
    0 => A
    $                               :EQ, JMPC(readCode)
    SP + 1 => SP
    $ => PC                         :MLOAD(SP--) ;
    PC => B
    ; Check PC is a JUMPDEST
                                    :JMP(checkJumpDest)

; TODO check do not overflow
checkJumpDest:
    ; If it is a deploy we have to check the data from the calldata (not the bytecode)
    $ => A                          :MLOAD(isCreateContract)
    -A                              :JMPN(checkJumpDestDeployment)
    PC => HASHPOS
    HASHPOS => D
    1 => D
    $ => E                          :MLOAD(contractHashId) ; hash index
    $ => A                          :HASHP(E)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)
checkJumpDestDeployment:
    1 => A
    $ => B                          :MLOAD(isCreate)
    $                               :EQ,JMPC(checkJumpDestDeploymentCreate)
    $ => HASHPOS                    :MLOAD(dataStarts)
    HASHPOS + PC => HASHPOS
    $ => E                          :MLOAD(batchHashDataId)
    1 => D
    $ => A                          :HASHK(E)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)

checkJumpDestDeploymentCreate:

    %MAX_CNT_ARITH - CNT_ARITH - 224 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 225 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCountersMemalign)

    $ => CTX                        :MLOAD(originCTX)
    $ => E                          :MLOAD(argsOffsetCall)
    E + PC => E
    1 => C
                                    :CALL(MLOADX)
    $ => CTX                        :MLOAD(currentCTX)
    31 => D
                                    :CALL(SHRarith)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)

opPC:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    GAS - 2 => GAS      :JMPN(outOfGas)
    PC - 1              :MSTORE(SP++) ; TODO: check PC
    1024 - SP           :JMPN(stackOverflow)
                        :JMP(readCode)

opJUMPDEST:
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    GAS - 1 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)
