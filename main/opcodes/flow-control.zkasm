
/**
 * @link [https://www.evm.codes/#56?fork=berlin]
 * @zk-counters
 *  - 32 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [counter]
 *  - stack output: none
 */
opJUMP:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - MIN_STEPS_FINISH_TX - STEP - 100 :JMPN(outOfCountersStep)

    ; check stack underflow
    SP - 1 => SP                    :JMPN(stackUnderflow)

    ; check out-of-gas
    GAS - 8 => GAS                  :JMPN(outOfGas)

    $ => B                         :MLOAD(SP); [counter => PC]
    ; Check PC is a JUMPDEST
    :JMP(checkJumpDest)
/**
 * @link [https://www.evm.codes/#57?fork=berlin]
 * @zk-counters
 *  - 32 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [counter, value]
 *  - stack output: none
 */
opJUMPI:

    %MAX_CNT_STEPS - MIN_STEPS_FINISH_TX - STEP - 100 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)

    SP - 2 => SP                    :JMPN(stackUnderflow)
    $ => B                          :MLOAD(SP); [value => B]
    GAS - 10 => GAS                 :JMPN(outOfGas)
    0 => A
    $                               :EQ, JMPC(readCode)
    SP + 1 => SP
    $ => B                         :MLOAD(SP--); [counter => PC]
    ; Check PC is a JUMPDEST
                                    :JMP(checkJumpDest)

; TODO check do not overflow
checkJumpDest:
    ; if it is a deploy we have to check the data from the calldata (not the bytecode)
    $ => A                          :MLOAD(isCreateContract)
    -A                              :JMPN(checkJumpDestDeployment)
    $ => A                          :MLOAD(bytecodeLength)
    $                               :LT,JMPC(invalidJump)
    B => PC
    B => HASHPOS
    ; set number of bytes to hashP at D
    1 => D
    ; get hashP address pointer where contract bytecode is stored
    $ => E                          :MLOAD(contractHashId)
    $ => A                          :HASHP(E)
    ; check if is a jumpDest (0x5B)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)
checkJumpDestDeployment:
    ; check jumpDest from calldata
    $ => A                          :MLOAD(isCreate)
    -A                              :JMPN(checkJumpDestDeploymentCreate)
    ; get position where data starts in the tx
    $ => HASHPOS                    :MLOAD(dataStarts)
    ; add PC to data starts to  point the bytes to read for the push
    B => PC
    HASHPOS + PC => HASHPOS
    ; get memory pointer for hashing
    $ => E                          :MLOAD(batchHashDataId)
    ; set number of bytes to hashK at D
    1 => D
    $ => A                          :HASHK(E)
    ; check if is a jumpDest (0x5B)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)

checkJumpDestDeploymentCreate:
    ; checks zk-counters
    %MAX_CNT_ARITH - CNT_ARITH - 224 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 225 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCountersMemalign)
    ; get bytes from previous context memory
    $ => CTX                        :MLOAD(originCTX)
    ; get offset call position
    $ => E                          :MLOAD(argsOffsetCall)
    ; increase current program counter (PC) to offset for getting pushed bytes to read
    B => PC
    E + PC => E
    ; set bytes to read from memory at C
    1 => C
                                    :CALL(MLOADX); in: [E: offset, C: length] out: [A: value, E: new offset]
    $ => CTX                        :MLOAD(currentCTX)
    31 => D
                                    :CALL(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    ; check if is a jumpDest (0x5B)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)

/**
 * @link [https://www.evm.codes/#58?fork=berlin]
 * @zk-counters
 *  - dynamic steps: 120 * pushed bytes
 * @process-opcode
 *  - stack input: none
 *  - stack output: [PC]
 */
opPC:
    ; checks zk-counters
    %MAX_CNT_STEPS - MIN_STEPS_FINISH_TX - STEP - 100 :JMPN(outOfCountersStep)

    ; check out-of-gas
    GAS - 2 => GAS      :JMPN(outOfGas)
    ; store current PC
    PC - 1              :MSTORE(SP++); [PC => SP]
    ; check stack overflow
    1024 - SP           :JMPN(stackOverflow)
                        :JMP(readCode)


/**
 * @link [https://www.evm.codes/#5B?fork=berlin]
 * @zk-counters
 *  - dynamic steps: 120 * pushed bytes
 * @process-opcode
 *  - stack input: none
 *  - stack output: none
 */
opJUMPDEST:

    ; checks zk-counters
    %MAX_CNT_STEPS - MIN_STEPS_FINISH_TX - STEP - 100 :JMPN(outOfCountersStep)
    
    ; check out-of-gas
    GAS - 1 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)
