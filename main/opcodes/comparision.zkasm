/**
 * @link [https://www.evm.codes/#10?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a < b]
 */
opLT:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    ; if (a < b) [1 => SP] else [0 => SP] 
    $               :LT,MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#11?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a > b]
 */
opGT:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    ; if (a > b) [1 => SP] else [0 => SP]
    $               :LT,MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#12?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a < b]
 */
opSLT:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    ; if (a < b) [1 => SP] else [0 => SP]
    $               :SLT,MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#13?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a > b]
 */
opSGT:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    ; if (a > b) [1 => SP] else [0 => SP]
    $               :SLT,MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#14?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a == b]
 */
opEQ:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    ; if (a == b) [1 => SP] else [0 => SP]
    $               :EQ,MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#15?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a]
 *  - stack output: [a == 0]
 */
opISZERO:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    0 => B
    ; if (a == 0) [1 => SP] else [0 => SP]
    $               :EQ,MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#16?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a & b]
 */
opAND:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :AND,MSTORE(SP++) ; [ a & b => SP]
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#17?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a | b]
 */
opOR:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :OR,MSTORE(SP++) ; [ a | b => SP]
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#18?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a ^ b]
 */
opXOR:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :XOR,MSTORE(SP++) ; [ a ^ b => SP]
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#19?fork=berlin]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a]
 *  - stack output: [ NOT a ]
 */
opNOT:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn => B
    $ => A          :XOR,MSTORE(SP++) ; [ NOT a => SP]
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#1a?fork=berlin]
 * @zk-counters
 *  - 2 arith
 *  - 4 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [byte offset, 32-byte value]
 *  - stack output: [byte]
 */
opBYTE:
    ; checks zk-counters
    %MAX_CNT_ARITH - CNT_ARITH - 2 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
    ; if the byte offset is out of range --> JMP(opBYTE0)
    31 - B => D     :JMPN(opBYTE0)
    ; A >> D => A
                    :CALL(SHRarith)
    255 => B
    ; result A & 255 --> [ A & 255 => SP]
    $               :AND,MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opBYTE0:
    ; result 0 --> [ 0 => SP]
    0               :MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#1c?fork=berlin]
 * @zk-counters
 *  - 1 arith
 *  - 3 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [shift, value]
 *  - stack output: [value >> shift]
 */
opSHR:
    ; checks zk-counters
    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; CALL shr util (with arith)
                    :CALL(SHRarithBit)  ; [ A >> D => A]
    A               :MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#1b?fork=berlin]
 * @zk-counters
 *  - 1 arith
 *  - 3 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [shift, value]
 *  - stack output: [value << shift]
 */
opSHL:
    ; checks zk-counters
    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; CALL shl util (with arith)
                    :CALL(SHLarithBit)  ; [ A << D => A]
    A               :MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

/**
 * @link [https://www.evm.codes/#1d?fork=berlin]
 * @zk-counters
 *  - 2 arith
 *  - 10 binary
 *  - 200 steps
 * @process-opcode
 *  - stack input: [shift, value]
 *  - stack output: [value >> shift (signed)]
 */
; TODO: Adapt to multiplication
; https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/evm/src/opcodes/functions.ts#L336
opSAR:
    ; checks zk-counters
    %MAX_CNT_ARITH - CNT_ARITH - 2 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 10 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)
    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)    ; [shift (bits) => D]
    ${D/8} => B                     ; [shift (bytes) => B]
    32 => A
    $ => A          :LT             ; if (shift (bytes) > 32) 1 => A, else 0 => A
    1 => B
    $ => B          :XOR            ; if (A == 1) 0 => B, else 1 => B
    ${A * 256 + B * D} => D         ; if (shift (bytes) > 32) 256 => D, else D => D
    $ => A          :MLOAD(SP)      ; [value => A]
    ; CALL abs: Get absolute value (A) and sign (B)
                    :CALL(abs)
    ; CALL shr util (with arith)
                    ; if more than 32 set to 32
                    :CALL(SHRarithBit)
    A => C                          ; [absolute value => C]
    B => A                          ; [sign => A]
    1 => B
    $ => B          :XOR            ; if (sign negative (A == 1)) 0 => B, else 1 => B
    B - 1           :JMPN(opSARNeg)  ; 0 negative, 1 positive
    C               :MSTORE(SP++)   ; [absolute value => SP]
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSARNeg:
    C => A                          ; [absolute value => A]
    1 => B
    $ => B          :LT             ; if (absolute value < 1) 1 => B, else 0 => B
    ${A + B} => B                   ; TODO: This is UNSAFE
    0 => A
    $ => A          :SUB            ; 0 - (absolute value + B) => A
    A               :MSTORE(SP++)
    ; check stack overflow
    1024 - SP       :JMPN(stackOverflow)
    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)
