; gas_cost = 375 + 375 * num_topics + 8 * data_size + mem_expansion_cost
opLOG0:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 2              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    0                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG1:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 3              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    1                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG2:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 4              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    2                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG3:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 5              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    3                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG4:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 6              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    4                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOGLoop:

    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)

    C - 1           :JMPN(opSaveTopicsInit)
    C - 32          :JMPN(opLOGFinal)
                    :CALL(MLOAD32)
    ${storeLog(B, 0, A)} ; storeLog(indexLog, isTopic, bytesToStore)
    C - 32 => C
                    :JMP(opLOGLoop)

opLOGFinal:
                    :CALL(MLOADX)
    ${storeLog(B, 0, A)}

opSaveTopicsInit:
    $ => A          :MLOAD(numTopics)

opSaveTopicsLoop:

    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)

    A - 1               :JMPN(readCode)
    SP - 1 => SP        :JMPN(stackUnderflow)
    GAS - 375 => GAS    :JMPN(outOfGas)
    $ => C              :MLOAD(SP)   ; topicX
    ${storeLog(B, 1, C)}     ; storeLog(indexLog, isTopic, bytesToStore)
    A - 1 =>  A
                        :JMP(opSaveTopicsLoop)
