
opMLOAD:

    %MAX_CNT_ARITH - CNT_ARITH - 32 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => E          :MLOAD(SP)                  ;offset
    E               :MSTORE(lastMemOffset)
                    :CALL(MLOAD32)
    32              :MSTORE(lastMemLength)
                    :CALL(saveMem)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)

;MSTORE 32 bytes
opMSTORE:

    %MAX_CNT_ARITH - CNT_ARITH - 32 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)                ;offset
    $ => B          :MLOAD(SP)                  ;value
    B               :MSTORE(bytesToStore)
    E               :MSTORE(lastMemOffset)
    E => A
                    :CALL(MSTORE32)
    32              :MSTORE(lastMemLength)
                    :CALL(saveMem)
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)


opMSTORE8:

    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)                ;offset
    B               :MSTORE(lastMemOffset)
    1               :MSTORE(lastMemLength)
    0x200000 => A
    $               :LT,JMPC(errorMLOADMSTORE)
    B => A
                    :CALL(offsetUtil)
    $ => B          :MLOAD(SP)                  ;value
    $ => A          :MLOAD(MEM:E) ; read M0
    ${memAlignWR8_W0(A,B,C)} => D  ; no trust calculate W0
    B               :MEM_ALIGN_WR8 ; only use LSB of B, rest of bytes could be non zero.
    D               :MSTORE(MEM:E)     ; write W0
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :CALL(saveMem)
                    :JMP(readCode)


opMSIZE:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    GAS - 2 => GAS      :JMPN(outOfGas)
    $ => E              :MLOAD(memLength)
    ; MSIZE should be multiple of a word (32 bytes)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes1)
    $ => B          :MLOAD(arithRes2)
    0 => A
    $               :EQ, JMPC(MSIZEend)
    ; Round size to 32bytes multiple
    C + 1 => C
    C * 32 => E

MSIZEend:
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opSLOAD:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => C          :MLOAD(SP) ;key
    $ => A          :MLOAD(storageAddr)
    %SMT_KEY_SC_STORAGE => B
    $ => E          :SLOAD ;current value
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :CALL(isWarmedSlot)
    GAS - %SLOAD_GAS - A*2000 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSSTORE:
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 765 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_BINARY - CNT_BINARY - 10 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    ; If GAS <= 2300 --> OOG
    GAS - 2300 - 1  :JMPN(outOfGas)
    $ => A          :MLOAD(isStaticCall)
    0 - A           :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => C          :MLOAD(SP--) ;key
    C               :MSTORE(tmpVarC)
    $ => D          :MLOAD(SP) ; new value
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(deploymentSSTORE)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opSSTOREinit)

deploymentSSTORE:
    $ => A          :MLOAD(createContractAddress)

opSSTOREinit:
    %SMT_KEY_SC_STORAGE => B
    $ => E          :SLOAD ;current value
    SR              :MSTORE(auxSR)
    $ => SR         :MLOAD(originSR)
    $ => B          :SLOAD ;origin value
    $ => SR         :MLOAD(auxSR)
                    :CALL(isWarmedSlot)
    B => C           ;origin value
    GAS - A*2100 => GAS    :JMPN(outOfGas)
    E => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdif)
    ;if new_val == current_val
    GAS - 100 => GAS:JMPN(outOfGas)
                    :JMP(opSSTOREend)

opSSTOREdif:
    ;if new_val != current_val
    C => A
    E => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA)
    ;if current_val == orig_val
    0 => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifB)
    ;if origin_val == 0
    GAS - %SSTORE_SET_GAS => GAS    :JMPN(outOfGas)
                    :JMP(opSSTOREend)

opSSTOREdifA:
    ;if current_val != orig_val
    GAS - 100 => GAS:JMPN(outOfGas)
    0 => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA1)
    ;if origin_value == 0

opSSTOREdifAB:
    ;if origin_value == 0
    D => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREend)
    ;if new_val == orig_val
    0 => A
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA2)
    ;if orig_val == 0
    $ => A          :MLOAD(gasRefund)
    A + 19900 => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREdifA1:
    ;if orig_val != 0
    0 => A
    E => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA12)
    ;if current_val == 0
    $ => A          :MLOAD(gasRefund)
    A - %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREdifAB)
opSSTOREdifA12:
    ;if current_val != 0
    0 => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifAB)
    ;if new_val == 0
    $ => A          :MLOAD(gasRefund)
    A + %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREdifAB)

opSSTOREdifA2:
    ;if orig_val != 0
    $ => A          :MLOAD(gasRefund)
    A + 2800 => A   :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREdifB:
    ;if orig_val != 0
    GAS - %SSTORE_RESET_GAS => GAS    :JMPN(outOfGas)
    0 => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREend)
    ;if new_val == 0
    $ => A          :MLOAD(gasRefund)
    A + %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREend:
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(mloadContract)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opSSTOREsr)

mloadContract:
    $ => A          :MLOAD(createContractAddress)

opSSTOREsr:
    %SMT_KEY_SC_STORAGE => B
    $ => C          :MLOAD(tmpVarC)
    $ => SR         :SSTORE
                    :JMP(readCode)