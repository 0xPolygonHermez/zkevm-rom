
/**
 * @link [Link EVM behaviour --> evm.codes?]
 * @zk-counters
 *  - 1 binary
 *  - 120 steps
 * @process-opcode
 *  - stack input: [a, b]
 *  - stack output: [a + b]
 */
opADD:
    ; checks zk-counters
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    ; check stack underflow
    SP - 2          :JMPN(stackUnderflow)

    ; check out-of-gas
    GAS-3 => GAS    :JMPN(outOfGas)

    ; read two items from the stack
    SP - 1 => SP
    $ => A          :MLOAD(SP--) ; [a => A]
    $ => B          :MLOAD(SP) ; [b => B]

    ; call arith state machine and push to the stack
    $               :ADD, MSTORE(SP++) ; [a + b => SP]

    ; continue read bytecode
                    :JMP(readCode)

opMUL:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; Mul operation with Arith
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => E          :MLOAD(arithRes1)
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSUB:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    $ => E          :SUB
    E               :MSTORE(SP++)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDIV:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSDIV:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 8 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
                    :CALL(abs)
    A => E
    B => C
    $ => A          :MLOAD(SP)
                    :CALL(abs)
    A               :MSTORE(tmpVarA)
    C => A
    $ => A          :XOR
    1 => B
    $ => B          :XOR
    $ => A          :MLOAD(tmpVarA)
    B - 1           :JMPN(opSDIVNeg) ;0 negative, 1 positive
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSDIVNeg:

    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)

    0 => A
    $ => A          :SUB
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; Mod operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 8 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
                    :CALL(abs)
    A => E
    B => C
    $ => A          :MLOAD(SP)
                    :CALL(abs)
    A               :MSTORE(tmpVarA)
    C => A
    1 => B
    $ => B          :XOR
    $ => A          :MLOAD(tmpVarA)
    B - 1           :JMPN(opSMODNeg)  ; 0 negative, 1 positive
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSMODNeg:

    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes2)
    0 => A
    $ => A          :SUB
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opADDMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 80 :JMPN(outOfCountersStep)

    GAS-8 => GAS    :JMPN(outOfGas)

    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP--)
    ; Add operation with Arith
    ${var _addMod = A + B} ; TODO $$

    1 => D
    $ => A          :ADD, JMPC(AddModJumpCarry) ; or arith
    0 => D

AddModJumpCarry:
    A => E          ; Store sumResult on E

    $ => A          :MLOAD(SP) ; load modulus
    2 => B
    $               :LT, JMPC(zeroOneMod)

    ${_addMod / A} => B        ; k: Max should be (2^256 -1) * 2 / 2 --> smaller than 2^256
    ${_addMod % A} => C        ; addModResult

    ; k * N + addModResult = D*2^256 + sumResult
    ; B * A + C = D*2^256 + E

    ; Check addModResult is less than modulus
    E               :ARITH

    A => B          ; modulus
    C => A          ; addModResult
    $ => A          :LT
    1               :ASSERT
    C               :MSTORE(SP++)
                    :JMP(readCode)

opMULMOD:
    %MAX_CNT_ARITH - CNT_ARITH - 3 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 150 :JMPN(outOfCountersStep)

    GAS-8 => GAS    :JMPN(outOfGas)
    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP

    ; The following approach will be followed in order to verify the mulmod operation
    ; A * B + 0 = D*2^256 + E
    ; K * N + mulModResult = D*2^256 + E

    ; Since the k can be bigger than 2²⁵⁶ and therefore does not fit in a register we divedit in the
    ; most significan and less significant part:

    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E
    ; And divide this operation in 2 which fits in 2²⁵⁶ digits

    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP--)

    ; Mul operation with Arith
    ${var _mulMod = A * B} ; TODO $$
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
    ; here we perform the: A * B + 0 = D*2^256 + E
    ; result is stored in: arithRes1(E) and arithOverflow(D)
                    :CALL(mulARITH)

    $ => A          :MLOAD(SP) ; Modulus N
    ; Check if modulus is 0 or 1
    2 => B
    $               :LT, JMPC(zeroOneMod)

    ; Now we will try to perform the following equation:
    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E
    A => C ; modulus on C
    ${(_mulMod / C) >> 256} => B     ; k.h
    ; We can jump with Js, because later it's all verified by the ARITH
    ${cond(B == 0)}  :JMPN(mulModNoKH)

    ; Since there's k.h we will split the equation in those 2
    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2

    ; k.h  * N  = D2
    ; B * A + 0 = 0 * 2²⁵⁶ + E
    ; D2 must be less than 2²⁵⁶
    C => A ; Modulus
    0 => C, D
    ${B * A} => E   :MSTORE(tmpVarD), ARITH ; D2

    ; k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ; B * A + C = D*2^256 + E
    ; remember that:
    ; result of mul is stored in: arithRes1(E) and arithOverflow(D)

    ${(_mulMod / A) % (2 << 256)} => B   ; k.l
    ${_mulMod % A} => C        ; mulModResult
    ${(B * A + C) >> 256} => D ; D1
    $               :MLOAD(arithRes1), ARITH

    ; Finally we need to assert the following:
    ; N>resultModulus
    ; D1 + D2 = D

    ; N>resultModulus   ; LT; ASSERT
    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT

    ; Assert D1 + D2 = D ; ADD ;ASSERT
    D => A ; D1
    $ => B          :MLOAD(tmpVarD) ;D2
    $ => A          :ADD
    $               :MLOAD(arithOverflow), ASSERT

    C               :MSTORE(SP++)
                    :JMP(readCode)

mulModNoKH:
    ; if theres no K.h the equation is simplified as:
    ; K * N + mulModResult = D*2^256 + E
    ; B * A + C = D*2^256 + E

    C => A ; Modulus on A
    ${(_mulMod / A)} => B   ; k
    ${_mulMod % A} => C     ; mulModResult
    $ => D         :MLOAD(arithOverflow)
    $              :MLOAD(arithRes1), ARITH ; Can this be on the same line of MLOAD?

    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT
    C               :MSTORE(SP++)
                    :JMP(readCode)
zeroOneMod:
    0               :MSTORE(SP++)
                    :JMP(readCode)

opEXP: ; //TODO: test exp == 0

    %MAX_CNT_ARITH - CNT_ARITH - 512 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 1025 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2              :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A              :MLOAD(SP--)
    $ => B              :MLOAD(SP)
    ${exp(A,B)} => A
    A                   :MSTORE(SP++)
    1024 - SP           :JMPN(stackOverflow)
                        :CALL(getLenBytes)
    GAS-10-50*A => GAS  :JMPN(outOfGas)
                        :JMP(readCode)

opSIGNEXTEND: ; following this impl https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/vm/src/evm/opcodes/functions.ts#L193

    %MAX_CNT_ARITH - CNT_ARITH - 6 :JMPN(outOfCountersArith)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--) ; sign byte --> sign bit = 8 * A + 7
    $ => D          :MLOAD(SP)   ; number to convert
    30 => A
    $               :LT, JMPC(opSIGNEXTENDEnd); if signByte is 31 or more, means basically let the number as it is
    ; TODO we could divide this opcode in a table with constants, only 31 cases
    B * 8  + 7 => B ; B is less than 31, no need for binary
    ${exp(2, B)} => A  ; signBit TODO table for shifting + multipliyng

    ;Store mask
    1 => B
    $ => C          :SUB ; mask

    D => B               ; number to convert
    $ => B          :AND ; check sign bit
    0 => A
    $               :EQ, JMPC(opSIGNEXTENDPositive) ; If 0 means the sign bit was 0 --> positive
    C => A ; mask
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn => B
    $ => B          :XOR ; not mask
    D => A
    $ => D          :OR
                    :JMP(opSIGNEXTENDEnd)

opSIGNEXTENDPositive:
    C => B
    D => A
    $ => D          :AND

opSIGNEXTENDEnd:
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)