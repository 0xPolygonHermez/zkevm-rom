/**
 * @link [https://www.evm.codes/precompiled#0x05?fork=shanghai]
 * @zk-counters
 *  - dynamic steps:
 *  - dynamic arith:
 *  - dynamic binary:
 * @process-precompiled
 *  - stack input: [x1, y1, x2, y2]
 *  - stack output: [x, y]
 */
INCLUDE "../modexp/modexp.zkasm"
INCLUDE "../modexp/modexp_utils.zkasm"

INCLUDE "../modexp/array_lib/utils/array_is_zero.zkasm"
INCLUDE "../modexp/array_lib/utils/array_is_one.zkasm"
INCLUDE "../modexp/array_lib/utils/array_is_odd.zkasm"

INCLUDE "../modexp/array_lib/unused/array_sub_AGTB.zkasm"

INCLUDE "../modexp/array_lib/utils/array_trim.zkasm"
INCLUDE "../modexp/array_lib/utils/array_compare.zkasm"

INCLUDE "../modexp/array_lib/array_add_short.zkasm"
INCLUDE "../modexp/array_lib/array_add_AGTB.zkasm"
INCLUDE "../modexp/array_lib/array_add.zkasm"

; INCLUDE "array_mul_karatsuba.zkasm"
INCLUDE "../modexp/array_lib/array_mul_long.zkasm"
INCLUDE "../modexp/array_lib/array_mul_short.zkasm"
INCLUDE "../modexp/array_lib/array_mul.zkasm"
INCLUDE "../modexp/array_lib/array_square.zkasm"
INCLUDE "../modexp/array_lib/array_div_mod_long.zkasm"
INCLUDE "../modexp/array_lib/array_div_mod_short.zkasm"
INCLUDE "../modexp/array_lib/array_div_mod.zkasm"

VAR GLOBAL multiplication_complexity

VAR GLOBAL modexp_Bsize
VAR GLOBAL modexp_Esize
VAR GLOBAL modexp_Msize

funcModexp:

    ;%MAX_CNT_BINARY - CNT_BINARY - X   :JMPN(outOfCountersBinary)
    ;%MAX_CNT_ARITH - CNT_ARITH - X     :JMPN(outOfCountersArith)
    ;%MAX_CNT_STEPS - STEP - X         :JMPN(outOfCountersStep)

    ; Move balances if value > 0 just before executing the contract CALL
    $ => B                              :MLOAD(txValue)
    0 => A
    zkPC+2 => RR
    $                                   :LT, JMPC(moveBalances)

    ; read data stored in argsOffsetCall
    ; Bsize [32 bytes], Esize [32 bytes], Msize [32 bytes]
    $ => CTX        :MLOAD(originCTX)
    $ => E          :MLOAD(argsOffsetCall)
                    :CALL(MLOAD32)
    ${log(A,modexp_Bsize)}
    A               :MSTORE(modexp_Bsize)           ;Bsize = base size
                    :CALL(MLOAD32)
    ${log(A,modexp_Esize)}
    A               :MSTORE(modexp_Esize)           ;Esize = exp size
                    :CALL(MLOAD32)
    ${log(A,modexp_Msize)}
    A               :MSTORE(modexp_Msize)           ;Msize = mod size
    $ => C          :MLOAD(modexp_Bsize)
                    :CALL(modexp_getBase)
    $ => C          :MLOAD(modexp_Esize)
                    :CALL(modexp_getExp)
    $ => C          :MLOAD(modexp_Msize)
                    :CALL(modexp_getMod)
    $ => A          :MLOAD(modexp_Elen),JMPZ(modexpExp0)
    $ => A          :MLOAD(modexp_Bsize)
    $ => B          :MLOAD(modexp_Msize)
    $               :LT, JMPC(calculateGas)
    A => B          :JMP(calculateGas)              ;B: max_length = max(Blen, Mlen)

/*
Gas

max_length = max(Bsize, Msize)
words = (max_length + 7) / 8
multiplication_complexity = words**2

iteration_count = 0
if Esize <= 32 and exponent == 0: iteration_count = 0
elif Esize <= 32: iteration_count = exponent.bit_length() - 1
elif Esize > 32: iteration_count = (8 * (Esize - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)
calculate_iteration_count = max(iteration_count, 1)

static_gas = 0
dynamic_gas = max(200, multiplication_complexity * iteration_count / 3)
 */

; E = iteration_count

VAR GLOBAL iteration_count
calculateGas:
    0 => E
    ; B = max(Bsize, Msize)
    ${log(B,maxSize)}
    B + 7                               :MSTORE(arithA)
    8                                   :MSTORE(arithB),CALL(divARITH)
    $ => C                              :MLOAD(arithRes1)   ;C: words = (max_length + 7) / 8
    ${log(C,words)}
    C                                   :MSTORE(arithA)
    C                                   :MSTORE(arithB),CALL(mulARITH)
    $ => A                              :MLOAD(arithRes1)   ;A: multiplication_complexity = words**2
    ${log(A,multiplication_complexity)}
    A                                   :MSTORE(multiplication_complexity)

continueGas:
    $ => A                              :MLOAD(modexp_Esize)
    ${log(A,Esize)}
    33 => B
    $ => B                              :LT,JMPC(modexp_expLT32)    ;if Esize <= 32 --> modexp_expLT32
    ;elif Esize > 32: iteration_count = (8 * (Esize - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)
    ${log(A,Esize)}
    A - 32                              :MSTORE(arithA)
    8                                   :MSTORE(arithB),CALL(mulARITH)
    $ => A                              :MLOAD(arithRes1)   ; A = 8 * (Esize - 32)
    ${log(A,iteration_count)}
    A                                   :MSTORE(iteration_count)    ;interation_count = 8 * (Esize - 32)
    $ => E                              :MLOAD(modexp_Elen)
    E                                   :JMPZ(continueGas2)         ;if Esize without 0's === 0 --> continueGas2
    $ => B                              :MLOAD(modexp_B)
                                        :CALL(getLenBits)
    ${log(A,lenbits_firstbyte)}
    $ => B                              :MLOAD(iteration_count)
    ${log(B,iteration_count)}
    A + B                               :MSTORE(iteration_count) ; iteration_count = (8 * (Esize - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)

continueGas2:
    ; calculates the bits of the first byte
    1 => C                              :CALL(MLOADX)
    31 => D                             :CALL(SHRarith)
    A => B                              :CALL(getLenBits)
    $ => A                              :MLOAD(iteration_count)
    B + A - 1 => E                      :MSTORE(iteration_count),JMP(finalGas) ; iteration_count = (8 * (Esize - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)

modexp_expLT32:
    $ => B                              :MLOAD(modexp_E),JMPZ(finalGas) ;if Exp === 0 --> finalGas
                                        :CALL(getLenBits)   ;A = exponent.bit_length()
    A - 1 => E                                              ;E = exponent.bit_length() - 1

finalGas:
    1 => A
    E => B
    $                                   :LT,JMPC(dinamicGas)
    1 => E

dinamicGas:
    ; E = calculate_iteration_count = max(iteration_count, 1)
    $ => A                              :MLOAD(multiplication_complexity)
    A                                   :MSTORE(arithA)
    E                                   :MSTORE(arithB),CALL(mulARITH)
    $ => A                              :MLOAD(arithRes1)   ; A = multiplication_complexity * iteration_count
    A                                   :MSTORE(arithA)
    3                                   :MSTORE(arithB),CALL(divARITH)
    $ => A                              :MLOAD(arithRes1)   ; A = multiplication_complexity * iteration_count / 3
    200 => B
    $                                   :LT,JMPC(callMODEXP)
    A => B

callMODEXP:
    ; B = max(200, multiplication_complexity * iteration_count / 3)
    ${log(B, gas)}
    $ => CTX                            :MLOAD(currentCTX)
    GAS - B => GAS                      :JMPN(outOfGas)
    $ => A                              :MLOAD(modexp_Mlen),JMPZ(modexpMod0)
    $ => A                              :MLOAD(modexp_Blen),JMPZ(modexpBase0)
                                        :CALL(modexp)
                                        :JMP(finalMODEXP)

modexpBase0:
    $ => A                              :MLOAD(modexp_Elen)
    A                                   :JMPZ(save1out)
    0                                   :MSTORE(modexp_out),JMP(finalMODEXP)

modexpExp0:
    $ => CTX                            :MLOAD(currentCTX)
    GAS - 200 => GAS                    :JMPN(outOfGas)
modexpMod0:
    $ => A                              :MLOAD(modexp_Mlen)
    0                                   :MSTORE(modexp_out)
    A                                   :JMPZ(finalMODEXP)
    A - 1                               :JMPNZ(save1out)
    $ => A                              :MLOAD(modexp_M)
    A - 1                               :JMPZ(finalMODEXP)
save1out:
    1                                   :MSTORE(modexp_out)

finalMODEXP:
    ; write data into memory
    0 => E
    $ => C                              :MLOAD(modexp_Msize)
    ; TODO: change modexp_out --> modexp_out[300]
    $ => A                              :MLOAD(modexp_out)
    A                                   :MSTORE(bytesToStore), CALL(MSTOREX); in: [bytesToStore, E: offset] out: [E: new offset]

    ; prepare return data
    0                                   :MSTORE(retDataOffset)
    C                                   :MSTORE(retDataLength)
    $ => A                              :MLOAD(originCTX),JMPZ(handleGas)
    ; set retDataCTX
    $ => B                              :MLOAD(currentCTX)
    A => CTX
    B                                   :MSTORE(retDataCTX)
    B => CTX

    ; write result modexp into previous context memory
    $ => C                              :MLOAD(modexp_Msize), JMPZ(preEndMODEXP)
    $ => E                              :MLOAD(retCallOffset)

    ; result is in bytesToStore
    C - 32                              :JMPN(continueMODEXP)
    ; TODO: change modexp_out --> modexp_out[300]
    32 => C

continueMODEXP:
    $ => A                              :MLOAD(modexp_out)
    32 - C => D                         :CALL(SHLarith)
    A                                   :MSTORE(bytesToStore)
    $ => CTX                            :MLOAD(originCTX), CALL(MSTOREX) ; in: [bytesToStore, E: offset] out: [E: new offset]
                                        :JMP(endMODEXP)

modexpSizeMod0:
    $ => CTX                            :MLOAD(currentCTX)
endMODEXPFail:
    $ => A                              :MLOAD(originCTX), JMPZ(handleGas)
    A => CTX
    0                                   :MSTORE(retDataCTX)
    0 => GAS
    CTX                                 :MSTORE(currentCTX), JMP(preEndFail)

preEndMODEXP:
    $ => CTX                            :MLOAD(originCTX)

endMODEXP:
    CTX                                 :MSTORE(currentCTX), JMP(preEnd)
