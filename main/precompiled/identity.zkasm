IDENTITY:
    ; Move balances if value > 0 just before executing the contract CALL
    $ => B          :MLOAD(txValue)
    0 => A
    zkPC+2 => RR
    $               :LT, JMPC(moveBalances)
    
    GAS - 15 => GAS :JMPN(outOfGas)
    $ => C          :MLOAD(argsLengthCall)
    ${(C+31)/32} => A
    GAS - 3*A => GAS:JMPN(outOfGas)
    CTX             :MSTORE(currentCTX)
    CTX => A
    $ => CTX        :MLOAD(originCTX)
    CTX - 1         :JMPN(handleGas)
    A               :MSTORE(retDataCTX)
    A => CTX
    0 => B
    0 => E
    0 => A
    B               :MSTORE(retDataOffset)
    C               :MSTORE(retDataLength)

IDENTITYinit:
    ; Copy from Stack to memory
    C - 1           :JMPN(IDENTITYreturn)
    C - 32          :JMPN(IDENTITYfinal)
    1024 + A => SP
    $ => B          :MLOAD(SP)
    B               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    A + 1 => A
    C - 32 => C
    B + 32 => B
                    :JMP(IDENTITYinit)
IDENTITYfinal:
    1024 + A => SP
    $ => A          :MLOAD(SP)
    32 - C => D
                    :CALL(SHRarith)
                    :CALL(SHLarith)
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
IDENTITYreturn:
    ; Copy from memory current CTX to memory origin CTX
    0 => E
    $ => C          :MLOAD(retCallLength)
    $ => B          :MLOAD(retCallOffset)

IDENTITYreturnLoop:
    C - 1           :JMPN(IDENTITYend)
    C - 32          :JMPN(IDENTITYreturnFinal)
                    :CALL(MLOAD32)
    E => D
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => B
    D => E
    C - 32 => C
    $ => CTX        :MLOAD(currentCTX)
                    :JMP(IDENTITYreturnLoop)
IDENTITYreturnFinal:
                    :CALL(MLOADX)
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
    $ => CTX        :MLOAD(currentCTX)

IDENTITYend:
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
                    :JMP(preEnd)
