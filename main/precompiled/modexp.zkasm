/**
 * Comptutation modexp: A^B mod C
 * @param - A - Base
 * @param - B - Exponent
 * @param - C - Modulo
 * @returns - acc - accumulate final value operation
function modExp(A, B, C){
    // rom: (divARITH) --> B % 2 --> get last bit
    const arrayBitsB = convertToBits(B);
    let acc = 1;
    let bp = A;

    // rom: until B != 0
    for (let i = 0; i < arrayBitsB.length; i++){ -----> MODEXPloop1
        const bit = arrayBitsB[i];
        if (bit == 1) {
            acc = acc * bp % C    
        }
        bp = bp * bp % C
    }
    return acc;
}
*/

VAR CTX Bsize
VAR CTX Binit
VAR CTX Bpos
VAR CTX Bend
VAR CTX Esize
VAR CTX Einit
VAR CTX Epos
VAR CTX Eend
VAR CTX Msize
VAR CTX Minit
VAR CTX Mpos
VAR CTX Mend

VAR CTX base
VAR CTX exp
VAR CTX newExp
VAR CTX mod
VAR CTX res
VAR CTX bp
VAR CTX exp0

CONST %MAX_SIZE = 0x7fffffffn

;TODO: incorrect inputs (argslength < 32 + 32 + 32 + lenB + lenE + lenM)
;TODO: size > 32
MODEXP:

    %MAX_CNT_BINARY - CNT_BINARY - 3   :JMPN(outOfCountersBinary)

    $ => C          :MLOAD(argsLengthCall)
    $ => CTX        :MLOAD(originCTX)
    $ => E          :MLOAD(argsOffsetCall)
                    :CALL(MLOAD32)
    A               :MSTORE(Bsize)          ;Bsize = base size
                    :CALL(MLOAD32)
    A               :MSTORE(Esize)          ;Esize = exp size
                    :CALL(MLOAD32)
    A               :MSTORE(Msize)          ;Msize = mod size
    E               :MSTORE(Binit)
    E               :MSTORE(Bpos)
    $ => B          :MLOAD(Bsize)
    %MAX_SIZE => A
    $               :LT,JMPC(MODEXPfinalOOG)
    E + B => E      :MSTORE(Bend)

    E               :MSTORE(Einit)
    $ => B          :MLOAD(Esize)
    0 => A
    $               :EQ,JMPC(MODEXPexp0)
    %MAX_SIZE => A
    $               :LT,JMPC(MODEXPfinalOOG)
    E + B => E      :MSTORE(Eend)
    E               :MSTORE(Epos)

    E               :MSTORE(Minit)
    E               :MSTORE(Mpos)
    $ => B          :MLOAD(Msize)
    0 => A
    $               :EQ,JMPC(MODEXPmod0)
    %MAX_SIZE => A
    $               :LT,JMPC(MODEXPfinalOOG)
    E + B => E      :MSTORE(Mend)

    $ => E          :MLOAD(Binit)
    $ => C          :MLOAD(Bsize)
                    :CALL(MLOADX)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    A               :MSTORE(base)
    $ => C          :MLOAD(Esize)
    E + C => E

    $ => C          :MLOAD(Msize)
                    :CALL(MLOADX)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    A               :MSTORE(mod)
    0 => B
    $               :EQ,JMPC(MODEXPmod0)    ;if mod == 0 --> MODEXPreturn0
    $ => A          :MLOAD(base)
    A               :MSTORE(bp)
    1               :MSTORE(res)

MODEXPexpLoop:
    $ => E          :MLOAD(Epos)
    $ => A          :MLOAD(Einit)
    ;E - 32 < Einit --> newExp MLOAD32
    ;E - 32 > Einit --> newExp MLOADX C = Epos - Einit (if C > 0)
    32 => C
    E - 32 => E
    E => B
    $               :LT,JMPC(MODEXPexpX)
    $ => E          :MLOAD(Epos)
    E - A => C
    E - C => E
    C - 1           :JMPN(MODEXPloopEnd)

MODEXPexpX:
    E               :MSTORE(Epos)
                    :CALL(MLOADX)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    A               :MSTORE(exp)
    A               :MSTORE(newExp)

MODEXPloop1:

    %MAX_CNT_BINARY - CNT_BINARY - 2    :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    %MAX_CNT_ARITH - CNT_ARITH - 1      :JMPN(outOfCountersArith)

    $ => A          :MLOAD(newExp)
    0 => B
    $               :EQ,JMPC(MODEXPloopEnd) ;if exp = 0 --> MODEXPloopEnd
    A               :MSTORE(arithA)
    2               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH)          ;divARITH --> exp/2
    $ => D          :MLOAD(arithRes1)       ;D = exp/2
    D               :MSTORE(newExp)
    $ => A          :MLOAD(arithRes2)       ;A = exp%2 (0 or 1)
    0 => B
    $               :EQ,JMPC(MODEXPloop10)  ;if A = 0 --> MODEXPloop10
    $ => A          :MLOAD(res)
    $ => B          :MLOAD(bp)
    $ => C          :MLOAD(mod)
                    :CALL(utilMULMOD)
    C               :MSTORE(res)

MODEXPloop10:
    $ => E          :MLOAD(bp)
    E => A                              ; bp1 = bp0*bp0 (bp²), bp2 = bp1*bp1 (bp⁴), bp3 = bp2*bp2 (bp⁸), ...
    0 => B
    $               :EQ,JMPC(MODEXPreturn0)
    E => B
    $ => C          :MLOAD(mod)
                    :CALL(utilMULMOD)
    C               :MSTORE(bp)
                    :JMP(MODEXPloop1)

MODEXPexp0:
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)

    1               :MSTORE(exp0)
    1 => A
    $ => B          :MLOAD(mod)
    $               :EQ,JMPC(MODEXPreturn0)
    1               :MSTORE(res)
                    :JMP(MODEXPfinal)

MODEXPloopEnd:
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)

    $ => B          :MLOAD(bp)
    $ => A          :MLOAD(base)
    $               :EQ,JMPC(MODEXPexp0)
    $ => A          :MLOAD(res)
                    :JMP(MODEXPfinal)

MODEXPmod0:
    200 => B
    0 => A
                    :JMP(MODEXPend)

MODEXPreturn0:
    0 => A

MODEXPfinal:
    $ => D          :MLOAD(Msize)
    $ => CTX        :MLOAD(currentCTX)
    D               :MSTORE(retDataLength)
    $ => E          :MLOAD(retCallOffset)
    D => C
    ;$ => C          :MLOAD(retCallLength)
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
    E               :MSTORE(retDataCTX)  ;(?)

    ;ASSERT C == D
    ;Result of the computation, with the same number of bytes as M
    A => B
                    :CALL(getLenBytes)
    C - A - 1       :JMPN(MODEXPfinal2)
    zkPC+1 => RR    :JMP(MODEXPstore0)

MODEXPfinal2:
    C => D
    B => A
    32 - D => D
                    :CALL(SHLarith)
    A               :MSTORE(bytesToStore)
    C - 32          :JMPN(MODEXPstoreX)
                    :CALL(MSTORE32)
                    :JMP(MODEXPgas)

MODEXPstoreX:
                    :CALL(MSTOREX)

MODEXPgas:

    %MAX_CNT_BINARY - CNT_BINARY - 8    :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    %MAX_CNT_ARITH - CNT_ARITH - 3      :JMPN(outOfCountersArith)


    $ => A              :MLOAD(Bsize)
    $ => B              :MLOAD(Msize)
    $ => D              :LT
    D - 1               :JMPN(MODEXPgas2)
    B => A

MODEXPgas2:
    7 => B
    $ => A              :ADD,MSTORE(arithA)
    8 => B              :MSTORE(arithB)
    zkPC+1 => RR        :JMP(divARITH)
    $ => A              :MLOAD(arithRes1)   ;words
    2 => D
    zkPC+1 => RR        :JMP(expAD)         ;A multiplication_complexity
    0 => D              ;iteration_count
    A                   :MSTORE(tmpVarA)
    ;$ => B              :MLOAD(exp)
    ;                    :CALL(getLenBits)
    $ => B              :MLOAD(Esize)
    B*8 => A
    zkPC+1 => RR        :JMP(checkSizeE)
    A => C
    $ => A              :MLOAD(Esize)
    32 => B
    $                   :LT,JMPC(MODEXPgas3)
    $                   :EQ,JMPC(MODEXPgas3)
    ;TODO +32 bytes

MODEXPgas32:
    $ => A              :SUB
    8*A => A
    A => C
    $ => E              :MLOAD(Eend)
    E => A
    32 => B
    E - 32 => E
                        :CALL(MLOAD32)
    A => B
                        :CALL(getLenBits)
    A + C => D          ;iteration_count
                        :JMP(MODEXPgasEnd)

MODEXPgas3:
    $ => A              :MLOAD(exp0)
    -A                  :JMPN(MODEXPgas4)
    C - 1 => D          ;iteration_count

MODEXPgas4:
    1 => B
    D => A
    $ => A              :LT
    A - 1               :JMPN(MODEXPgasEnd)
    1 => D              ;iteration_count

MODEXPgasEnd:
    $ => A              :MLOAD(tmpVarA)
    A                   :MSTORE(arithA)
    D                   :MSTORE(arithB)
    zkPC+1 => RR        :JMP(mulARITH)
    $ => A              :MLOAD(arithRes1)
    A                   :MSTORE(arithA)
    3                   :MSTORE(arithB)
    zkPC+1 => RR        :JMP(divARITH)
    $ => A              :MLOAD(arithRes1)
    200 => B
    $ => C              :LT
    A => B
    C - 1               :JMPN(MODEXPend)
    200 => B

MODEXPend:
    GAS - B => GAS      :JMPN(outOfGas)
                        :JMP(preEnd)

MODEXPfinalOOG:
                        :JMP(outOfGas)

VAR CTX tmpZkPCMODEXP

MODEXPstore0:
    ; A = lenBytes
    ; C = returnLength
    RR                  :MSTORE(tmpZkPCMODEXP)
    D                   :MSTORE(tmpVarD3)
    B                   :MSTORE(tmpVarB3)
    ;E                   :MSTORE(tmpVarE3)

MODEXPstore0loop:
    C => B
    $                   :LT,JMPC(store0)
                        :JMP(endStore0)

store0:
    0                   :MSTORE(bytesToStore)
    1 => C
                        :CALL(MSTOREX)
    B - 1 => C
                        :JMP(MODEXPstore0loop)

endStore0:
    $ => D              :MLOAD(tmpVarD3)
    $ => B              :MLOAD(tmpVarB3)
    ;$ => E              :MLOAD(tmpVarE3)
    $ => RR             :MLOAD(tmpZkPCMODEXP)
                        :JMP(RR)

checkSizeE:
    RR                  :MSTORE(tmpZkPCMODEXP)
    A                   :MSTORE(tmpVarA3)
    B                   :MSTORE(tmpVarB3)
    C                   :MSTORE(tmpVarC3)
    D                   :MSTORE(tmpVarD3)
    E                   :MSTORE(tmpVarE3)
    $ => D              :MLOAD(Esize)
    $ => E              :MLOAD(Einit)
    1 => C

checkSizeLoop:
    D - 1 => D          :JMPN(checkSizeEnd0)
    $ => A              :MLOAD(tmpVarA3)
    A - 8 => A          :MSTORE(tmpVarA3)
                        :CALL(MLOADX)
    D => B
    31 => D
                        :CALL(SHRarith)
    B => D
    A => B
                        :CALL(getLenBits)
    0 => B
    $                   :EQ,JMPC(checkSizeLoop)
    8 => B
    $                   :EQ,JMPC(checkSizeEnd0)
    $ => D              :MLOAD(tmpVarA3)
    D + A => A
                        :JMP(checkSizeEnd)

checkSizeEnd0:
    $ => A              :MLOAD(tmpVarA3)
    A + 8 => A

checkSizeEnd:
    $ => B              :MLOAD(tmpVarB3)
    $ => C              :MLOAD(tmpVarC3)
    $ => D              :MLOAD(tmpVarD3)
    $ => E              :MLOAD(tmpVarE3)
    $ => RR             :MLOAD(tmpZkPCMODEXP)
                        :JMP(RR)