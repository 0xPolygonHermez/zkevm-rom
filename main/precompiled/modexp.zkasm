VAR CTX Bsize
VAR CTX Esize
VAR CTX Msize
VAR CTX base
VAR CTX exp
VAR CTX newExp
VAR CTX mod
VAR CTX exp2
VAR CTX res
VAR CTX bp
;TODO: incorrect inputs (argslength < 32 + 32 + 32 + lenB + lenE + lenM)
;TODO: size > 32
MODEXP:
    $ => C          :MLOAD(argsLengthCall)
    $ => CTX        :MLOAD(originCTX)
    $ => E          :MLOAD(argsOffsetCall)
                    :CALL(MLOAD32)
    A               :MSTORE(Bsize)
                    :CALL(MLOAD32)
    A               :MSTORE(Esize)
                    :CALL(MLOAD32)
    A               :MSTORE(Msize)
    $ => C          :MLOAD(Bsize)
                    :CALL(MLOADX)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    A               :MSTORE(base)
    $ => C          :MLOAD(Esize)
                    :CALL(MLOADX)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    A               :MSTORE(exp)
    A               :MSTORE(newExp)
    $ => C          :MLOAD(Msize)
                    :CALL(MLOADX)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    A               :MSTORE(mod)
    0 => B
    $               :EQ,JMPC(MODEXPreturn0)
    $ => A          :MLOAD(exp)
    $               :EQ,JMPC(MODEXPexp0)
    $ => B          :MLOAD(base)
    0 => A
    $               :EQ,JMPC(MODEXPreturn0)
    1 => C
    $ => D          :MLOAD(exp)
    ;$ => E          :MLOAD(base)
    1               :MSTORE(exp2)
    1               :MSTORE(res)
    D => A

MODEXPloop1:

    %MAX_CNT_BINARY - CNT_BINARY - 10   :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    %MAX_CNT_ARITH - CNT_ARITH - 3      :JMPN(outOfCountersArith)

    $ => A          :MLOAD(newExp)
    0 => B
    $               :EQ,JMPC(MODEXPloopEnd)
    A               :MSTORE(arithA)
    2               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH)
    $ => D          :MLOAD(arithRes1)
    D               :MSTORE(newExp)
    $ => A          :MLOAD(arithRes2)
    0 => B
    $               :EQ,JMPC(MODEXPloop10)
    1 => C
    $ => D          :MLOAD(exp2)
    $ => E          :MLOAD(base)

MODEXPloop2:

    %MAX_CNT_BINARY - CNT_BINARY - 2   :JMPN(outOfCountersBinary)

    E => B
    C => A
    $ => C          :MLOAD(mod)
                    :CALL(utilMULMOD)
    D => A
    1 => B
    $ => A          :SUB
    0 => B
    $               :EQ,JMPC(MODEXPloop2End)
    A => D
                    :JMP(MODEXPloop2)

MODEXPloop2End:

    %MAX_CNT_ARITH - CNT_ARITH - 1      :JMPN(outOfCountersArith)

    $ => E          :MLOAD(res)
    E               :MSTORE(arithA)
    C               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(mulARITH)
    $ => C          :MLOAD(arithRes1)
    C               :MSTORE(res)

MODEXPloop10:

    %MAX_CNT_ARITH - CNT_ARITH - 1      :JMPN(outOfCountersArith)

    $ => E          :MLOAD(bp)
    E               :MSTORE(arithA)
    E               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(mulARITH)
    $ => E          :MLOAD(arithRes1)
    E               :MSTORE(bp)
    $ => E          :MLOAD(exp2)
    E*2             :MSTORE(exp2)
                    :JMP(MODEXPloop1)

MODEXPexp0:

    %MAX_CNT_BINARY - CNT_BINARY - 2   :JMPN(outOfCountersBinary)

    1 => A
    $ => B          :MLOAD(mod)
    $               :EQ,JMPC(MODEXPreturn0)
    1 => C

MODEXPloopEnd:

    %MAX_CNT_ARITH - CNT_ARITH - 1      :JMPN(outOfCountersArith)

    C               :MSTORE(arithA)
    $ => A          :MLOAD(mod)
    A               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH)
    $ => A          :MLOAD(arithRes2)
                    :JMP(MODEXPfinal)

MODEXPreturn0:
    0 => A

MODEXPfinal:
    $ => D          :MLOAD(Msize)
    $ => CTX        :MLOAD(currentCTX)
    D               :MSTORE(retDataLength)
    $ => E          :MLOAD(retCallOffset)
    $ => C          :MLOAD(retCallLength)
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
    B               :MSTORE(retDataCTX)

    ;ASSERT C == D
    ;Result of the computation, with the same number of bytes as M
    32 - D => D
                    :CALL(SHLarith)
    A               :MSTORE(bytesToStore)
    C - 32          :JMPN(MODEXPstoreX)
                    :CALL(MSTORE32)
                    :JMP(MODEXPgas)

MODEXPstoreX:
                    :CALL(MSTOREX)

MODEXPgas:

    %MAX_CNT_BINARY - CNT_BINARY - 8    :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    %MAX_CNT_ARITH - CNT_ARITH - 2      :JMPN(outOfCountersArith)


    $ => A              :MLOAD(Bsize)
    $ => B              :MLOAD(Msize)
    $ => D              :LT
    D - 1               :JMPN(MODEXPgas2)
    B => A

MODEXPgas2:
    7 => B
    $ => A              :ADD,MSTORE(arithA)
    8 => B              :MSTORE(arithB)
    zkPC+1 => RR        :JMP(divARITH)
    $ => A              :MLOAD(arithRes1);words
    2 => D
    zkPC+1 => RR        :JMP(expAD)
    0 => D              ;iteration_count
    A                   :MSTORE(tmpVarA)
    $ => B              :MLOAD(exp)
                        :CALL(getLenBytes)
    A => C
    32 => B
    $                   :LT,JMPC(MODEXPgas3)
    $                   :EQ,JMPC(MODEXPgas3)
    ;TODO +32 bytes
                        :JMP(MODEXPgas4)

MODEXPgas3:
    $ => B              :MLOAD(exp)
    0 => A
    $                   :EQ,JMPC(MODEXPgas4)
    8*C - 1 => D        ;iteration_count

MODEXPgas4:
    1 => B
    D => A
    $ => A              :LT
    A - 1               :JMPN(MODEXPgasEnd)
    1 => D              ;iteration_count

MODEXPgasEnd:
    $ => A              :MLOAD(tmpVarA)
    A                   :MSTORE(arithA)
    D                   :MSTORE(arithB)
    zkPC+1 => RR        :JMP(mulARITH)
    $ => A              :MLOAD(arithRes1)
    A                   :MSTORE(arithA)
    3                   :MSTORE(arithB)
    zkPC+1 => RR        :JMP(divARITH)
    $ => A              :MLOAD(arithRes1)
    200 => B
    $ => C              :LT
    A => B
    C - 1               :JMPN(MODEXPend)
    200 => B

MODEXPend:
    GAS - B => GAS      :JMPN(outOfGas)
                        :JMP(preEnd)