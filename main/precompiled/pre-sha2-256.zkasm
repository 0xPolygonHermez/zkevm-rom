/**
 * @link [https://www.evm.codes/precompiled#0x02?fork=shanghai]
 * @zk-counters
 *  - dynamic steps:
 *  - dynamic binary:
 * @process-precompiled
 *  - stack input: [data]
 *  - stack output: [hash]
 */
funcSHA2256:
    ;%MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    ;%MAX_CNT_BINARY - CNT_BINARY - 1   :JMPN(outOfCountersBinary)

    ; Move balances if value > 0 just before executing the contract CALL
    $ => B          :MLOAD(txValue)
    0 => A
    zkPC+2 => RR
    $               :LT, JMPC(moveBalances)

    GAS - %SHA2_256_GAS => GAS :JMPN(outOfGas)
    $ => C          :MLOAD(txCalldataLen)
    ;(C+31)/32 => A
    C + 31 => A
    A               :MSTORE(arithA)
    32              :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A          :MLOAD(arithRes1)

    GAS - %SHA2_256_WORD_GAS*A => GAS   :JMPN(outOfGas)
    0               :MSTORE(retDataOffset)
    32              :MSTORE(retDataLength)
    32              :MSTORE(readXFromCalldataLength)
    0 => E

SHA2256dataLoop:
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    ; Copy from calldata to hashS (TODO)
    C               :JMPZ(SHA2256dataReturn)
    C - 32          :JMPN(SHA2256dataFinal)
    E               :MSTORE(readXFromCalldataOffset), CALL(readFromCalldataOffset); in: [readXFromCalldataOffset: offset value, readXFromCalldataLength: length value], out: [readXFromCalldataResult: result value]
    $ => A          :MLOAD(readXFromCalldataResult)
    E + 32 => E

    ; TODO
    ${mockSHA256(A,32)}
    ;A               :HASHS(E)

    C - 32 => C     :JMP(SHA2256dataLoop)

SHA2256dataFinal:
    C               :MSTORE(readXFromCalldataLength)
    E               :MSTORE(readXFromCalldataOffset), CALL(readFromCalldataOffset); in: [readXFromCalldataOffset: offset value, readXFromCalldataLength: length value], out: [readXFromCalldataResult: result value]
    $ => A          :MLOAD(readXFromCalldataResult)
    ; TODO
    ${mockSHA256(A,C)}
    ;A               :HASHS(E)

SHA2256dataReturn:
    ; handle CTX
    $ => A          :MLOAD(originCTX), JMPZ(handleGas)
    ; set retDataCTX
    $ => B          :MLOAD(currentCTX)
    A => CTX
    B               :MSTORE(retDataCTX)
    ; Copy from memory current CTX to memory origin CTX
    0 => E
    ; TODO
    ${mockSHA256(0,0)} => A

    A               :MSTORE(bytesToStore), CALL(MSTORE32); in: [bytesToStore, E: offset] out: [E: new offset]
    CTX             :MSTORE(currentCTX), JMP(preEnd)