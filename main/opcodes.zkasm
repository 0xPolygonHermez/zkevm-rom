INCLUDE "utils.zkasm"

opSTOP:
    $ => B          :MLOAD(originCTX)
    B - 1           :JMPN(handleGas)
    $ => A          :MLOAD(gasRefund)
    $ => C          :MLOAD(isCreate)
    1 => D
    C - 1           :JMPN(opSTOPend)
    $ => D          :MLOAD(createContractAddress)

opSTOPend:
    B => CTX
    CTX             :MSTORE(currentCTX)
    0               :MSTORE(retDataCTX)
    $ => B          :MLOAD(gasCTX)
    $ => C          :MLOAD(gasRefund)
    A + C           :MSTORE(gasRefund)
    GAS + B => GAS
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opADD:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => C          :MLOAD(SP)

    ; Add operation with Arith
    A               :MSTORE(arithA)
    C               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => E          :MLOAD(arithRes1)
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opMUL:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; Mul operation with Arith
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => E          :MLOAD(arithRes1)
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSUB:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => C          :MLOAD(SP)
    ; Sub operation with Arith
    E               :MSTORE(arithA)
    C               :MSTORE(arithB)
                    :CALL(subARITH)
    $ => A          :MLOAD(arithRes1)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDIV:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSDIV:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 8 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
                    :CALL(abs)
    A => E
    B => C
    $ => A          :MLOAD(SP)
                    :CALL(abs)
    A               :MSTORE(tmpVarA)
    C => A
    $ => A          :XOR
    1 => B
    $ => B          :XOR
    $ => A          :MLOAD(tmpVarA)
    B - 1           :JMPN(opSDIVNeg) ;0 negative, 1 positive
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSDIVNeg:

    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)

    0 => A
    $ => A          :SUB
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; Mod operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 8 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
                    :CALL(abs)
    A => E
    B => C
    $ => A          :MLOAD(SP)
                    :CALL(abs)
    A               :MSTORE(tmpVarA)
    C => A
    1 => B
    $ => B          :XOR
    $ => A          :MLOAD(tmpVarA)
    B - 1           :JMPN(opSMODNeg)  ; 0 negative, 1 positive
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSMODNeg:

    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes2)
    0 => A
    $ => A          :SUB
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opADDMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCounters)

    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP--)
    ; Add operation with Arith
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => E          :MLOAD(arithRes1)
    $ => A          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-8 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opMULMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 2 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCounters)

    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP--)
    ; Mul operation with Arith
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => E          :MLOAD(arithRes1)
    $ => A          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-8 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opEXP: ; //TODO: test exp == 0

    %MAX_CNT_ARITH - CNT_ARITH - 512 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 1025 :JMPN(outOfCounters)

    SP - 2              :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A              :MLOAD(SP--)
    $ => B              :MLOAD(SP)
    ${exp(A,B)} => A
    A                   :MSTORE(SP++)
    1024 - SP           :JMPN(stackOverflow)
                        :CALL(getLenBytes)
    GAS-10-50*A => GAS  :JMPN(outOfGas)
                        :JMP(readCode)

opSIGNEXTEND: ; following this impl https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/vm/src/evm/opcodes/functions.ts#L193

    %MAX_CNT_ARITH - CNT_ARITH - 6 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => D          :MLOAD(SP)
    31 => B
    $ => B          :LT
    B - 1           :JMPN(opSIGNEXTENDEnd)
    D => B
   ; Add operation with Arith
   ${A * 8}         :MSTORE(arithA)
   7                :MSTORE(arithB)
                    :CALL(addARITH)
   $ => A           :MLOAD(arithRes1)
   ${exp(2, A)} => C ; signBit
    C => A
    $ => B          :AND
    0 => A
    $ => A          :LT
    A - 1           :JMPN(opSIGNEXTENDPositive) ; 0 if negative, -1 if positive
    C - 1 => A
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn => B
    $ => B          :XOR
    D => A
    $ => D          :OR
                    :JMP(opSIGNEXTENDEnd)

opSIGNEXTENDPositive:
    C - 1 => B
    D => A
    $ => D          :AND

opSIGNEXTENDEnd:
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSLT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :SLT,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opLT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :LT,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opSGT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :SLT,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opGT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :LT,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opEQ:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :EQ,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opISZERO:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    0 => B
    $               :EQ,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opAND:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :AND,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opOR:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :OR,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opXOR:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :XOR,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opNOT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn => B
    $ => A          :XOR,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opBYTE:

    %MAX_CNT_ARITH - CNT_ARITH - 2 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    31 - B => D
                    :CALL(SHRarith)
    GAS-3 => GAS    :JMPN(outOfGas)
    255 => B
    $               :AND,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opSHR:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
                    :CALL(SHRarithBit)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSHL:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
                    :CALL(SHLarithBit)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; TODO: Adapt to multiplication
; https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/vm/src/evm/opcodes/functions.ts#L342
opSAR:

    %MAX_CNT_ARITH - CNT_ARITH - 2 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 10 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)
    ${D/8} => D
    D => B
    32 => A
    $ => A          :LT
    1 => B
    $ => B          :XOR
    ${A * 32 + B * D} => D
    $ => A          :MLOAD(SP)
                    :CALL(abs)
                    ; if more than 32 set to 32
                    :CALL(SHRarith)
    A => C
    B => A
    1 => B
    $ => B          :XOR
    B - 1           :JMPN(opSARNeg)  ; 0 negative, 1 positive
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSARNeg:
    C => A
    1 => B
    $ => B          :LT
    ${A + B} => B                   ; TODO: This is UNSAFE
    0 => A
    $ => A          :SUB
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSHA3:

    %MAX_CNT_ARITH - CNT_ARITH - 192 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 193 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCounters)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - 2 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 10 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ; offset
    $ => C          :MLOAD(SP) ; length
    E               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)
    ; gas
    GAS - 30 => GAS :JMPN(outOfGas); gas static = 30
                    :CALL(saveMem)
    ; Div operation with Arith
    ;${6*((C+31)/32)}
    C+31 => A
    ;(C+31)/32
    A               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes1)
    ; Mul operation with Arith
    ; 6*((C+31)/32)
    6               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => A          :MLOAD(arithRes1)
    GAS - A => GAS  :JMPN(outOfGas)  ; dynamic_gas = dynamic_gas = 6 * minimum_word_size + memory_expansion_cost
    ; new hash id
    $ => B           :MLOAD(lastHashKIdUsed)
    B + 1 => B       :MSTORE(lastHashKIdUsed)
    32 => D
    ; A new hash with position 0 is started
    0 => HASHPOS

opSHA3Loop:

    %MAX_CNT_ARITH - CNT_ARITH - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCounters)

    C - 1           :JMPN(opSHA3End)
    C - 32          :JMPN(opSHA3Final)
                    :CALL(MLOAD32)
    E => B
    $ => E          :MLOAD(lastHashKIdUsed)
    A               :HASHK(E)
    B => E
    C - 32 => C
                    :JMP(opSHA3Loop)
opSHA3Final:
                    :CALL(MLOADX)
    32 - C => D
                    :CALL(SHRarith)
    $ => E          :MLOAD(lastHashKIdUsed)
    C => D
    A               :HASHK(E)

opSHA3End:
    $ => E          :MLOAD(lastHashKIdUsed)
    HASHPOS         :HASHKLEN(E)
    $ => A          :HASHKDIGEST(E)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opADDRESS:
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(opADDRESSdeploy)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opADDRESSend)

opADDRESSdeploy:
    $ => A          :MLOAD(createContractAddress)

opADDRESSend:
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opBALANCE:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 252 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    0 => B,C        ; balance smt key
    $ => D          :SLOAD
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    ${touchedAddress(A)} => D
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opORIGIN:
    $ => A          :MLOAD(txSrcOriginAddr)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCALLER:
    $ => A          :MLOAD(txSrcAddr)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCALLVALUE:
    $ => A          :MLOAD(txValue)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; // TODO: Check when a contract is deployed with CREATE
opCALLDATALOAD:

    %MAX_CNT_ARITH - CNT_ARITH - 64 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 66 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => E          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    $ => A          :MLOAD(arithRes2)

    0 - A           :JMPN(opCALLDATALOAD2)
    SP => C
    1024 + B => SP
    $ => B          :MLOAD(SP)
    C => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCALLDATALOAD2:
    SP => C
    A => D
    1024 + B => SP
    $ => A          :MLOAD(SP++)
                    :CALL(SHLarith)
    A => B
    32 - D => D
    $ => A          :MLOAD(SP)
                    :CALL(SHRarith)
    C => SP
    B + A           :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)

opCALLDATASIZE:
    $ => B          :MLOAD(txCalldataLen)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; // TODO: check overflow length datacopy
opCALLDATACOPY:

    %MAX_CNT_ARITH - CNT_ARITH - 192 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 192 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1 :JMPN(outOfCounters)

    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;destOffset - offset memory
    $ => B          :MLOAD(SP--) ;offset calldata
    $ => C          :MLOAD(SP)   ;length calldata
    E               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)
    GAS - 3 => GAS  :JMPN(outOfGas)
    GAS - ${3*((C+31)/32)} => GAS    :JMPN(outOfGas) ; Arith
                    :CALL(saveMem)
    SP              :MSTORE(SPw)
                    :JMP(opCALLDATACOPYinit)

opCALLDATACOPYinit:


    %MAX_CNT_ARITH - CNT_ARITH - 192 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 192 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1 :JMPN(outOfCounters)

    C - 1           :JMPN(opCALLDATACOPYend)
    C - 32          :JMPN(opCALLDATACOPYfinal)
    B               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => D          :MLOAD(arithRes2)
    $ => A          :MLOAD(arithRes1)
    1024 + A => SP
    $ => A          :MLOAD(SP)
                    :CALL(SHLarith)
    A => C
    $ => A          :MLOAD(arithRes1)
    1024 + A + 1 => SP
    32 - D => D
    $ => A          :MLOAD(SP)
                    :CALL(SHRarith)
    A + C           :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    $ => SP         :MLOAD(SPw)
    $ => C          :MLOAD(SP)   ;length
    C - 32 => C
    C               :MSTORE(SP)
    B + 32 => B
                    :JMP(opCALLDATACOPYinit)

opCALLDATACOPYfinal:
    ${B%32} => D
    1024 + ${B/32} => SP
    $ => A          :MLOAD(SP)
                    :CALL(SHLarith)
    $ => SP         :MLOAD(SPw)
    $ => C          :MLOAD(SP)   ;length
    1024 + ${B/32} + 1 => SP
    C - 32 + D => D
    D               :JMPN(opCALLDATACOPYxor)
    A => B
    $ => A          :MLOAD(SP)
    32 - D => D
                    :CALL(SHRarith)
    32 - C => D
                    :CALL(SHLarith)
    B + A => A
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
                    :JMP(opCALLDATACOPYend)

opCALLDATACOPYxor:
    32 - C => D
                    ;SHR/SHL could be optimized
                    :CALL(SHRarith)
                    :CALL(SHLarith)
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)

opCALLDATACOPYend:
    $ => SP         :MLOAD(SPw)
                    :JMP(readCode)

opCODESIZE:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 252 :JMPN(outOfCounters)

    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(opCODESIZEdep)
    $ => A          :MLOAD(txDestAddr)
    %SMT_KEY_SC_LENGTH => B
    0 => C
    $ => A          :SLOAD
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCODESIZEdep: ;//TODO: create/create2, constructor parameters, initBytcode vs deployed Bytecode
    $ => B          :MLOAD(txCalldataLen)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

VAR GLOBAL memOffset
VAR GLOBAL remainingBytes
VAR GLOBAL previousValue
VAR GLOBAL codecopyHashId
VAR GLOBAL codecopyBytecodeLength
VAR GLOBAL memInteger
opCODECOPY:

    SP - 3          :JMPN(stackUnderflow)
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(opCALLDATACOPY) ; //TODO: delegateCall ? use of storageAddr? same in process_tx ?
    SP - 1 => SP
    $ => C          :MLOAD(SP--) ;destOffset, memory offset
    $ => D          :MLOAD(SP--) ;offset, bytecode offset
    $ => E          :MLOAD(SP)   ;bytecode length
    C               :MSTORE(lastMemOffset)
    E               :MSTORE(lastMemLength)

    ; Check counters
    %MAX_CNT_BINARY - CNT_BINARY - 2*E :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2*E :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)

    GAS - 3 => GAS  :JMPN(outOfGas)
    GAS - ${3*((E+31)/32)} => GAS    :JMPN(outOfGas)
                    :CALL(saveMem)
    ; check memory limits
    0x200000 => A
    C + E => B
    $               :LT,JMPC(errorMLOADMSTORE)
    ; init vars for copy the code
    D => HASHPOS
    C => A ; memory offset
    E => B ; bytes to copy
    $ => D          :MLOAD(contractHashId)
    D               :MSTORE(codecopyHashId) ; set hashId to get bytes from
    $ => D          :MLOAD(bytecodeLength)
    D               :MSTORE(codecopyBytecodeLength) ; set contract bytecode length
    A               :MSTORE(memOffset)
    B               :MSTORE(remainingBytes)

opCODECOPYinit:
    $ => B          :MLOAD(remainingBytes)
    B - 1           :JMPN(readCode)
    $ => A          :MLOAD(memOffset)
                    :CALL(offsetUtil) ; E (integer) / C (remaining)
    E               :MSTORE(memInteger)
    $ => A          :MLOAD(MEM:E) ; read M0 previous value
    A               :MSTORE(previousValue)
                    :CALL(opCODECOPYLoadBytes)
    $ => A          :MLOAD(previousValue)
    ${memAlignWR8_W0(A,B,C)} => D  ; no trust calculate W0
    B               :MEM_ALIGN_WR8 ; only use LSB of B, rest of bytes could be non zero
    $ => E          :MLOAD(memInteger)
    D               :MSTORE(MEM:E) ; write W0
    ; update vars loop
    $ => B          :MLOAD(remainingBytes)
    B - 1 => B  ; decrease 1 byte from length
    B               :MSTORE(remainingBytes)
    $ => A          :MLOAD(memOffset)
    A + 1 => A  ; increment offset to write the next byte
    A               :MSTORE(memOffset)
                    :JMP(opCODECOPYinit)


; @info Load 0 if read bytecode position is above bytecode length
opCODECOPYLoadBytes:
    0 => A
    $ => B          :MLOAD(codecopyBytecodeLength)
    $               :EQ, JMPC(readZero)
    HASHPOS => A
    $               :LT, JMPC(readValueBytecode)
readZero:
    0 => B
                    :RETURN
readValueBytecode:
    1 => D
    $ => E          :MLOAD(codecopyHashId)
    $ => B          :HASHP(E)   ; read value to write in memory
                    :RETURN


opGASPRICE:
    $ => A          :MLOAD(txGasPrice)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opEXTCODESIZE:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    ${touchedAddress(A)} => D
    %SMT_KEY_SC_LENGTH => B
    0 => C
    $ => A          :SLOAD
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; read hash smt
; put 32 by 32 bytes in the hashP
; assert bytes with hash smt

; read byte from hashP and copy into memory
; over length => set 0's
VAR GLOBAL tmpContractHashId
VAR GLOBAL tmpContractLength
opEXTCODECOPY:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCounters)
    %MAX_CNT_PADDING_PG - CNT_PADDING_PG - 11 :JMPN(outOfCounters)

    SP - 4          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--) ;addr
                    :CALL(maskAddress) ; Mask address to 20 bytes
    ${touchedAddress(A)} => D
    GAS-100-D*2500 => GAS            :JMPN(outOfGas)
                    :CALL(opEXTCODECOPYCheckHash)
    $ => C          :MLOAD(SP--) ;destOffset, memory offset
    $ => D          :MLOAD(SP--) ;offset to read from bytecode
    $ => E          :MLOAD(SP)   ; bytes to read from bytecode
    D               :MSTORE(lastMemOffset)
    E               :MSTORE(lastMemLength)
    
    ; Check counters
    %MAX_CNT_BINARY - CNT_BINARY - 2*E :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2*E :JMPN(outOfCounters)

    GAS - ${3*((E+31)/32)} => GAS    :JMPN(outOfGas)
                    :CALL(saveMem)
    ; check memory limits
    0x200000 => A
    C + E => B
    $               :LT,JMPC(errorMLOADMSTORE)
    ; init vars for copy the code
    D => HASHPOS
    C => A ; memory offset
    E => B ; bytes to copy
    $ => D          :MLOAD(tmpContractHashId)
    D               :MSTORE(codecopyHashId) ; set hashId to get bytes from
    $ => D          :MLOAD(tmpContractLength)
    D               :MSTORE(codecopyBytecodeLength) ; set contract bytecode length
    A               :MSTORE(memOffset)
    B               :MSTORE(remainingBytes)
                    :JMP(opCODECOPYinit)

opEXTCODECOPYCheckHash:
    ; get contract length
    %SMT_KEY_SC_LENGTH => B
    0 => C
    $ => D                          :SLOAD
    D                               :MSTORE(tmpContractLength)
    ; If len is 0 nothing to check
    A => E
    0 => A
    D => B
    $                               :EQ, JMPC(opEXTCODECOPYCheckHashEnd)
    E => A
    ; get hash contract
    %SMT_KEY_SC_CODE => B
    0 => C
    $ => A          :SLOAD
    ; get a new hashPId
    $ => E                          :MLOAD(nextHashPId)
    E                               :MSTORE(tmpContractHashId)
    E + 1                           :MSTORE(nextHashPId)

    ; set vars prior to loop
    D => B
    0 => HASHPOS
                                    :JMP(opEXTCODECOPYCheckHashLoop)

; @info bytes are inserted byte by byte
; TODO: it could be improved by computing how many 32 bytes slots are needed
opEXTCODECOPYCheckHashLoop:
        B - 1                                   :JMPN(opEXTCODECOPYCheckHashLoopEnd) ; finish reading bytecode
        1 => D
        ${getBytecode(A, HASHPOS, 1)}           :HASHP(E)                   ; add bytes to hash contract bytecode
        B - 1 => B
                                                :JMP(opEXTCODECOPYCheckHashLoop)

opEXTCODECOPYCheckHashLoopEnd:
        HASHPOS                         :HASHPLEN(E)
        $ => E                          :HASHPDIGEST(E)
        ; check hash computed matches hash in the smt leaf
        E                               :ASSERT
opEXTCODECOPYCheckHashEnd:
                                        :RETURN

opEXTCODECOPYinit:
    C - 1           :JMPN(readCode)
    C - 32          :JMPN(opEXTCODECOPYfinal)
    ${getBytecode(A,B,32)} => D
    D               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    C - 32 => C
    B + 32 => B
                    :JMP(opEXTCODECOPYinit)

opEXTCODECOPYfinal:
    ${getBytecode(A,B,C)} => A
    32 - C  => D
                    :CALL(SHLarith)
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
                    :JMP(readCode)

opRETURNDATASIZE:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCounters)

    ; Load ret data length from last ctx
    ; If no retDataCTX(0), retDataLength = 0
    GAS - 2 => GAS  :JMPN(outOfGas)
    $ => B          :MLOAD(retDataCTX)
    0 => A
    $               :EQ, JMPC(endOpRETURNDATASIZE)
    B => CTX
    $ => A          :MLOAD(retDataLength)
    ; Restore current context
    $ => CTX        :MLOAD(currentCTX)

endOpRETURNDATASIZE:
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opRETURNDATACOPY:
    SP - 3          :JMPN(stackUnderflow)
    GAS - 3 => GAS  :JMPN(outOfGas)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)            ;destOffset
    $ => B          :MLOAD(SP--)            ;offset - offset in return data
    $ => C          :MLOAD(SP)              ;length - length return data
    D               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - C*4 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - C*4 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 2 :JMPN(outOfCounters)

                    :CALL(saveMem)
    ; if retDataCTX is 0, end opcode execution
    B => E
    $ => B          :MLOAD(retDataCTX)
    0 => A
    $               :EQ, JMPC(opRETURNDATACOPYEmpty)
    ; Load ret data length from last ctx
    B => CTX
    E => B
    $ => A          :MLOAD(retDataLength)
    $ => E          :MLOAD(retDataOffset)
    $ => CTX        :MLOAD(currentCTX)
    ; if retdataOffset + dataLen > retDataSize -> OOG
    E + B => E
    A + 1 => A
    B + C => B
    $               :LT, JMPC(outOfGas)
    $               :EQ, JMPC(outOfGas)
    E => B
    ;${3*((C+31)/32)}
    C+31 => A
    ;(C+31)/32
    A               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes1)
    ; Mul operation with Arith
    ; 3*((C+31)/32)
    3               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => A          :MLOAD(arithRes1)
    GAS - A => GAS  :JMPN(outOfGas)

opRETURNDATACOPYinit:
    C - 1           :JMPN(readCode)
    C - 32          :JMPN(opRETURNDATACOPYfinal)
    B => E
    ; Load memory from last context used
    $ => CTX        :MLOAD(retDataCTX)
                    :CALL(MLOAD32)
    ; Save memory to the current context
    $ => CTX        :MLOAD(currentCTX)
    E => B
    D => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => D
    C - 32 => C
                    :JMP(opRETURNDATACOPYinit)

opRETURNDATACOPYfinal:
    B => E
    ; Load memory from last context used
    $ => CTX        :MLOAD(retDataCTX)
                    :CALL(MLOADX)
    ; Save memory to the current context
    $ => CTX        :MLOAD(currentCTX)
    E => B
    D => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
                    :JMP(readCode)

opRETURNDATACOPYEmpty:
    E + C => B ; offset return data + len return data must be 0
    $               :EQ, JMPC(readCode)
                    :JMP(outOfGas)

opEXTCODEHASH:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    ${touchedAddress(A)} => D
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
    %SMT_KEY_SC_CODE => B
    0 => C
    $ => A          :SLOAD
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

; @info opEXTCODEHASHL2 returns the keccak of the bytecode
; opEXTCODEHASH returns the hash bytecode stored in the smt (poseidon linear hash)
;opEXTCODEHASHL2:
;    SP - 1 => SP    :JMPN(stackUnderflow)
;    $ => A          :MLOAD(SP)
;    ${touchedAddress(A)} => D
;    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
;    %SMT_KEY_SC_CODE => B
;    0 => C
;    $ => A          :SLOAD
;    $${p = 0}
;    ${getBytecodeLength(A)} => C
;    $ => E           :MLOAD(lastHashKIdUsed)
;    E+1 => E         :MSTORE(lastHashKIdUsed)
;    ; A new hash with position 0 is started
;    0 => HASHPOS
;
;opEXTCODEHASHinit:
;    32 => D
;    C - 1           :JMPN(opEXTCODEHASHend)
;    C - 32          :JMPN(opEXTCODEHASHfinal)
;    ${getBytecode(A,p,D)} => B
;    B               :HASHK(E)
;    C - D => C
;    $${p = p + D}
;                    :JMP(opEXTCODEHASHinit)
;
;opEXTCODEHASHfinal:
;    C => D
;    ${getBytecode(A,p,C)} => B
;    B               :HASHK(E)
;
;opEXTCODEHASHend:
;    HASHPOS         :HASHKLEN(E)
;    $ => A          :HASHKDIGEST(E)
;    A               :MSTORE(SP++)
;    1024 - SP       :JMPN(stackOverflow)
;                    :JMP(readCode)

opBLOCKHASH:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - 2 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    GAS-20 => GAS   :JMPN(outOfGas)
    $ => A          :MLOAD(SP) ; batch number

    ; Check batch number is lt current batch number, else return 0
    $ => B          :MLOAD(numBatch)
    B - A - 1       :JMPN(opBLOCKHASHzero)

    ; Create key for the batch hash mapping key
    $ => E          :MLOAD(lastHashKIdUsed)
    E+1 => E        :MSTORE(lastHashKIdUsed)
    ; A new hash with position 0 is started
    0 => HASHPOS
    32 => D
    A               :HASHK(E)
    0               :HASHK(E) ; Storage position of the batch hash
    HASHPOS         :HASHKLEN(E)
    $ => C          :HASHKDIGEST(E)
    ; Load value from hashed key
    %ADDRESS_SYSTEM => A
    ; Set B to 3 to load from storage of address stored in A
    %SMT_KEY_SC_STORAGE => B
    $ => E          :SLOAD

    ; Store result value in the stack
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

; Handle when is asking for the hash of a not computed batch, return 0
opBLOCKHASHzero:
    0               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opCOINBASE:
    $ => A          :MLOAD(sequencerAddr)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)


opTIMESTAMP:
    $ => A          :MLOAD(timestamp)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opNUMBER:
    $ => A          :MLOAD(numBatch)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDIFFICULTY:
    %BATCH_DIFFICULTY => A
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opGASLIMIT:
    %BATCH_GAS_LIMIT => A
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCHAINID:
    %ZKEVM_CHAINID => A
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSELFBALANCE:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)

    $ => A          :MLOAD(storageAddr)
    0 => B,C        ; balance key smt
    $ => D          :SLOAD
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opPOP:
    SP - 1 => SP    :JMPN(stackUnderflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opMLOAD:

    %MAX_CNT_ARITH - CNT_ARITH - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => E          :MLOAD(SP)                  ;offset
    E               :MSTORE(lastMemOffset)
                    :CALL(MLOAD32)
    32              :MSTORE(lastMemLength)
                    :CALL(saveMem)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)

;MSTORE 32 bytes
opMSTORE:

    %MAX_CNT_ARITH - CNT_ARITH - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)                ;offset
    $ => B          :MLOAD(SP)                  ;value
    B               :MSTORE(bytesToStore)
    E               :MSTORE(lastMemOffset)
    E => A
                    :CALL(MSTORE32)
    32              :MSTORE(lastMemLength)
                    :CALL(saveMem)
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)


opMSTORE8:

    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)                ;offset
    B               :MSTORE(lastMemOffset)
    1               :MSTORE(lastMemLength)
    0x200000 => A
    $               :LT,JMPC(errorMLOADMSTORE)
    B => A
                    :CALL(offsetUtil)
    $ => B          :MLOAD(SP)                  ;value
    $ => A          :MLOAD(MEM:E) ; read M0
    ${memAlignWR8_W0(A,B,C)} => D  ; no trust calculate W0
    B               :MEM_ALIGN_WR8 ; only use LSB of B, rest of bytes could be non zero.
    D               :MSTORE(MEM:E)     ; write W0
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :CALL(saveMem)
                    :JMP(readCode)

opSLOAD:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCounters)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => C          :MLOAD(SP) ;key
    $ => A          :MLOAD(storageAddr)
    %SMT_KEY_SC_STORAGE => B
    $ => E          :SLOAD ;current value
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    ${touchedStorageSlots(A,C)} => A
    GAS - %SLOAD_GAS - A*2000 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSSTORE:
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 765 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 10 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1 :JMPN(outOfCounters)

    SP - 2          :JMPN(stackUnderflow)
    ; If GAS <= 2300 --> OOG
    GAS - 2300 - 1  :JMPN(outOfGas)
    $ => A          :MLOAD(isStaticCall)
    0 - A           :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => C          :MLOAD(SP--) ;key
    C               :MSTORE(tmpVarC)
    $ => D          :MLOAD(SP) ; new value
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(deploymentSSTORE)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opSSTOREinit)

deploymentSSTORE:
    $ => A          :MLOAD(createContractAddress)

opSSTOREinit:
    %SMT_KEY_SC_STORAGE => B
    $ => E          :SLOAD ;current value
    SR              :MSTORE(auxSR)
    $ => SR         :MLOAD(originSR)
    $ => B          :SLOAD ;origin value
    $ => SR         :MLOAD(auxSR)
    ${touchedStorageSlots(A,C)} => A
    B => C           ;origin value
    GAS - A*2100 => GAS    :JMPN(outOfGas)
    E => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdif)
    ;if new_val == current_val
    GAS - 100 => GAS:JMPN(outOfGas)
                    :JMP(opSSTOREend)

opSSTOREdif:
    ;if new_val != current_val
    C => A
    E => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA)
    ;if current_val == orig_val
    0 => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifB)
    ;if origin_val == 0
    GAS - %SSTORE_SET_GAS => GAS    :JMPN(outOfGas)
                    :JMP(opSSTOREend)

opSSTOREdifA:
    ;if current_val != orig_val
    GAS - 100 => GAS:JMPN(outOfGas)
    0 => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA1)
    ;if origin_value == 0

opSSTOREdifAB:
    ;if origin_value == 0
    D => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREend)
    ;if new_val == orig_val
    0 => A
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA2)
    ;if orig_val == 0
    $ => A          :MLOAD(gasRefund)
    A + 19900 => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREdifA1:
    ;if orig_val != 0
    0 => A
    E => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA12)
    ;if current_val == 0
    $ => A          :MLOAD(gasRefund)
    A - %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREdifAB)
opSSTOREdifA12:
    ;if current_val != 0
    0 => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifAB)
    ;if new_val == 0
    $ => A          :MLOAD(gasRefund)
    A + %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREdifAB)

opSSTOREdifA2:
    ;if orig_val != 0
    $ => A          :MLOAD(gasRefund)
    A + 2800 => A   :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREdifB:
    ;if orig_val != 0
    GAS - %SSTORE_RESET_GAS => GAS    :JMPN(outOfGas)
    0 => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREend)
    ;if new_val == 0
    $ => A          :MLOAD(gasRefund)
    A + %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREend:
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(mloadContract)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opSSTOREsr)

mloadContract:
    $ => A          :MLOAD(createContractAddress)

opSSTOREsr:
    %SMT_KEY_SC_STORAGE => B
    $ => C          :MLOAD(tmpVarC)
    $ => SR         :SSTORE
                    :JMP(readCode)

opJUMP:

    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCounters)

    SP - 1 => SP                    :JMPN(stackUnderflow)
    $ => PC                         :MLOAD(SP)
    GAS - 8 => GAS                  :JMPN(outOfGas)
    ; Check PC is a JUMPDEST
    :JMP(checkJumpDest)

opJUMPI:
    SP - 2 => SP                    :JMPN(stackUnderflow)
    $ => B                          :MLOAD(SP)
    GAS - 10 => GAS                 :JMPN(outOfGas)
    0 => A
    $                               :EQ, JMPC(readCode)
    SP + 1 => SP
    $ => PC                         :MLOAD(SP--) ;
    PC => B
    ; Check PC is a JUMPDEST
                                    :JMP(checkJumpDest)

; TODO check do not overflow
checkJumpDest:
    ; If it is a deploy we have to check the data from the calldata (not the bytecode)
    $ => A                          :MLOAD(isCreateContract)
    -A                              :JMPN(checkJumpDestDeployment)
    PC => HASHPOS
    HASHPOS => D
    1 => D
    $ => E                          :MLOAD(contractHashId) ; hash index
    $ => A                          :HASHP(E)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)
checkJumpDestDeployment:
    1 => A
    $ => B                          :MLOAD(isCreate)
    $                               :EQ,JMPC(checkJumpDestDeploymentCreate)
    $ => HASHPOS                    :MLOAD(dataStarts)
    HASHPOS + PC => HASHPOS
    $ => E                          :MLOAD(batchHashDataId)
    1 => D
    $ => A                          :HASHK(E)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)

checkJumpDestDeploymentCreate:

    %MAX_CNT_ARITH - CNT_ARITH - 224 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 225 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCounters)

    $ => CTX                        :MLOAD(originCTX)
    $ => E                          :MLOAD(argsOffsetCall)
    E + PC => E
    1 => C
                                    :CALL(MLOADX)
    $ => CTX                        :MLOAD(currentCTX)
    31 => D
                                    :CALL(SHRarith)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)

opPC:
    GAS - 2 => GAS      :JMPN(outOfGas)
    PC - 1              :MSTORE(SP++) ; TODO: check PC
    1024 - SP           :JMPN(stackOverflow)
                        :JMP(readCode)

opMSIZE:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCounters)

    GAS - 2 => GAS      :JMPN(outOfGas)
    $ => E              :MLOAD(memLength)
    ; MSIZE should be multiple of a word (32 bytes)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes1)
    $ => B          :MLOAD(arithRes2)
    0 => A
    $               :EQ, JMPC(MSIZEend)
    ; Round size to 32bytes multiple
    C + 1 => C
    C * 32 => E

MSIZEend:
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)


opGAS:
    GAS - 2 => GAS  :JMPN(outOfGas)
    GAS             :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opJUMPDEST:
    GAS - 1 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)

opAuxPUSHA:

    %MAX_CNT_BINARY - CNT_BINARY - 6 :JMPN(outOfCounters)

    GAS-3 => GAS        :JMPN(outOfGas)
                        :CALL(readPush)
    E                   :MSTORE(SP++)
    1024 - SP           :JMPN(stackOverflow)
    PC + D => PC
                        :JMP(readCode)

opAuxPUSHB:

    %MAX_CNT_BINARY - CNT_BINARY - 6 :JMPN(outOfCounters)

    1 => A
    $ => B                          :MLOAD(isCreate)
    $                               :EQ,JMPC(opAuxPUSHBcreate)
    D - 1 => C
    0 => A

opAuxPUSHBloop:
    1 => D
    $ => HASHPOS                    :MLOAD(dataStarts)
    HASHPOS + PC => HASHPOS
    PC + 1 => PC
    $ => E                          :MLOAD(batchHashDataId)
    $ => B                          :HASHK(E)
    A + B => A
    C - 1 => C                      :JMPN(opAuxPUSHBend)
                                    :CALL(SHLarith)
                                    :JMP(opAuxPUSHBloop)

opAuxPUSHBend:
    GAS-3 => GAS                    :JMPN(outOfGas)
    A                               :MSTORE(SP++)
                                    :JMP(readCode)

opAuxPUSHBcreate:

    %MAX_CNT_ARITH - CNT_ARITH - 224 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 225 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCounters)

    0 => B
    $ => CTX                        :MLOAD(originCTX)
    $ => E                          :MLOAD(argsOffsetCall)
    E + PC => E
    D => C
                                    :CALL(MLOADX)
    PC + C => PC
    32 - C => D
                                    :CALL(SHRarith)
    $ => CTX                        :MLOAD(currentCTX)
                                    :JMP(opAuxPUSHBend)


opPUSH1:
    1 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH2:
    2 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH3:
    3 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH4:
    4 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH5:
    5 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH6:
    6 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH7:
    7 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH8:
    8 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH9:
    9 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH10:
    10 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH11:
    11 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH12:
    12 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH13:
    13 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH14:
    14 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH15:
    15 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH16:
    16 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH17:
    17 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH18:
    18 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH19:
    19 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH20:
    20 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH21:
    21 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH22:
    22 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH23:
    23 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH24:
    24 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH25:
    25 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH26:
    26 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH27:
    27 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH28:
    28 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH29:
    29 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH30:
    30 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH31:
    31 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH32:
    32 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opDUP1:
    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP++)
    1024 - SP       :JMPN(stackOverflow)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP2:
    SP - 2 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 2 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP3:
    SP - 3 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 3 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP4:
    SP - 4 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 4 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP5:
    SP - 5 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 5 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP6:
    SP - 6 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 6 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP7:
    SP - 7 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 7 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP8:
    SP - 8 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 8 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP9:
    SP - 9 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 9 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP10:
    SP - 10 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 10 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP11:
    SP - 11 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 11 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP12:
    SP - 12 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 12 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP13:
    SP - 13 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 13 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP14:
    SP - 14 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 14 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP15:
    SP - 15 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 15 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP16:
    SP - 16 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 16 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP1:
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP2:
    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 2 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 2 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP3:
    SP - 4          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 3 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 3 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP4:
    SP - 5          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 4 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 4 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP5:
    SP - 6          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 5 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 5 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP6:
    SP - 7          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 6 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 6 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP7:
    SP - 8          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 7 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 7 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP8:
    SP - 9          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 8 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 8 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP9:
    SP - 10         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 9 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 9 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP10:
    SP - 11         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 10 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 10 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP11:
    SP - 12         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 11 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 11 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP12:
    SP - 13         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 12 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 12 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP13:
    SP - 14         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 13 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 13 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP14:
    SP - 15         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 14 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 14 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP15:
    SP - 16         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 15 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 15 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP16:
    SP - 17         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 16 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 16 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; gas_cost = 375 + 375 * num_topics + 8 * data_size + mem_expansion_cost
opLOG0:
    SP - 2              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    0                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8 * C => B
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG1:
    SP - 3              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    1                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8 * C => B
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG2:
    SP - 4              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    2                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8 * C => B
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG3:
    SP - 5              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    3                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8 * C => B
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG4:
    SP - 6              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    4                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8 * C => B
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOGLoop:

    %MAX_CNT_ARITH - CNT_ARITH - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 2 :JMPN(outOfCounters)

    C - 1           :JMPN(opSaveTopicsInit)
    C - 32          :JMPN(opLOGFinal)
                    :CALL(MLOAD32)
    ${storeLog(B, 0, A)} ; storeLog(indexLog, isTopic, bytesToStore)
    C - 32 => C
                    :JMP(opLOGLoop)

opLOGFinal:
                    :CALL(MLOADX)
    ${storeLog(B, 0, A)}

opSaveTopicsInit:
    $ => A          :MLOAD(numTopics)

opSaveTopicsLoop:
    A - 1               :JMPN(readCode)
    SP - 1 => SP        :JMPN(stackUnderflow)
    GAS - 375 => GAS    :JMPN(outOfGas)
    $ => C              :MLOAD(SP)   ; topicX
    ${storeLog(B, 1, C)}     ; storeLog(indexLog, isTopic, bytesToStore)
    A - 1 =>  A
                        :JMP(opSaveTopicsLoop)


; // TODO Check with DElEGATE CALL txDestAddr/txSrcAddr ( same as other calls)
; // TODO check revert create
opCREATE:
    SP - 3              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => D              :MLOAD(SP--)            ;value
    D                   :MSTORE(valueCall)
    $ => E              :MLOAD(SP--)            ;offset
    E                   :MSTORE(argsOffsetCall)
    $ => C              :MLOAD(SP)      ;length
    C                   :MSTORE(argsLengthCall)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - C - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - C -32 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCounters)

    ; Substract gas cost

    ; Mem expansion gas cost
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    CTX                 :MSTORE(originAuxCTX)
    GAS - 32000 => GAS  :JMPN(outOfGas)
    GAS                 :MSTORE(gasCall)

    ; Check correctness of Create: depth, can transfer, nonce overlfow, 
    ; depth overflow

    ; can transfer
    $ => A              :MLOAD(txDestAddr)
    %SMT_KEY_BALANCE => B                                             ; balance key smt
    0 => C                                                            ; 3rd parameter does not apply to nonce or balance
    $ => A              :SLOAD
    D => B              
    $                   :LT,JMPC(opCreateFail)

    ; nonce overlow
    $ => A             :MLOAD(txDestAddr)
    %SMT_KEY_NONCE => B                                                  ; Constant for nonce
    $ => B              :SLOAD
    A => C
    %MAX_NONCE => A
    $                   :EQ,JMPC(opCreateFail)


    ;change to a new CTX
    SP                  :MSTORE(lastSP)
    PC                  :MSTORE(lastPC)
    $ => A              :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX          :MSTORE(lastCtxUsed)
    CTX                 :MSTORE(currentCTX)
    1                   :MSTORE(isCreateContract)
    1                   :MSTORE(isCreate)
    $ => A              :MLOAD(originAuxCTX)
    A                   :MSTORE(originCTX)

    ; get nonce & update SR
    C => A
    0 => C
    B                  :MSTORE(txNonce)
    B + 1 => D
    %SMT_KEY_NONCE => B                                                  ; Constant for nonce
    $ => SR             :SSTORE
    SR                  :MSTORE(initSR)

                        :CALL(computeGasSendCall)
    $ => CTX            :MLOAD(originCTX)
    $ => C              :MLOAD(txGasPrice)
    $ => B              :MLOAD(txDestAddr)
    GAS - A             :MSTORE(gasCTX)
    $ => CTX            :MLOAD(currentCTX)
    C                   :MSTORE(txGasPrice)
    A => GAS
    B                   :MSTORE(txSrcAddr)
    ; TODO is not encesesaary to load and store GAS, bc is global var
                        :CALL(copySP)

    $ => B              :MLOAD(txNonce)
                        :CALL(getLenBytes)
    A                   :MSTORE(lengthNonce)
    $ => A              :MLOAD(argsLengthCall)
    A                   :MSTORE(txCalldataLen)
    $ => A              :MLOAD(valueCall)
    A                   :MSTORE(txValue)

                        :JMP(txType)

opCreateFail:
    0                   :MSTORE(retDataCTX)
    0                   :MSTORE(SP++)
                        :JMP(readCode)
                                   
; // Shpuld be set ? what happen if they are not set ?
; // Return buffer should be written always
; // If retOffet, retSize === 0 --> just not write in memory
; // Affects to opcodes related to RETURN
; // https://eips.ethereum.org/EIPS/eip-211
opCALL:
    SP - 7          :JMPN(stackUnderflow)
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    ; Store gas call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    ; Store address call
    $ => A          :MLOAD(SP--)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    A               :MSTORE(addrCall)
    ; Store value call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(valueCall)
    ; If is static and value is not 0 -> revert
    $ => B          :MLOAD(isStaticCall)
    B - 1           :JMPN(opCALL2)
    0 - A           :JMPN(invalidStaticTx)

opCALL2:
    ; Store bytes offset int the memory, the calldata of the subcontext
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    A               :MSTORE(lastMemOffset)

    ; Byte size to copy, size of the calldata of the subcontext
    $ => C          :MLOAD(SP--)
    C               :MSTORE(argsLengthCall)
    C               :MSTORE(lastMemLength)
    ; Mem expansion gas cost call args
                    :CALL(saveMem)

    ; Store byte offset in the memory in bytes, where to store the return data of the sub context.
    $ => B          :MLOAD(SP--)
    B               :MSTORE(lastMemOffset)

    ; Store byte size to copy (size of the return data).
    $ => D          :MLOAD(SP)
    D               :MSTORE(lastMemLength)
    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - C - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - C -32 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCounters)
                    :CALL(saveMem)

    $ => C          :MLOAD(storageAddr)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    C               :MSTORE(txSrcAddr)
    SR              :MSTORE(initSR)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    A               :MSTORE(storageAddr)
    B               :MSTORE(retCallOffset)
    D               :MSTORE(retCallLength)

    ; If addr in touched addres D = 0, else D = 1
    ${touchedAddress(A)} => D

    ;gas_cost = memory_expansion_cost + code_execution_cost + address_access_cost + positive_value_cost + value_to_empty_account_cost
    ; Calculate address_access_cost: 100 for warm account, 2600 for cold account
    GAS-100-D*2500 => GAS :JMPN(outOfGas)
    ; Calculate positive_value_cost, if value call > 0 -> 9000
    $ => B          :MLOAD(valueCall)
    B               :MSTORE(txValue)
    0 => A
    0 => C
    $               :EQ,JMPC(opCALLend)
    1 => C

    GAS - 9000 => GAS :JMPN(outOfGas)
    ; If destAddress is an empty account, we should add 25k of gas to base cost
    $ => E          :MLOAD(txDestAddr)
                    :CALL(isEmptyAccount)
    GAS - 25000*E => GAS :JMPN(outOfGas)

opCALLend:
                        :CALL(computeGasSendCall)
    ; Add estipend (2300) in case of tx with value
    $ => CTX            :MLOAD(originCTX)
    GAS - A             :MSTORE(gasCTX)
    A + 2300*C => A
    $ => C              :MLOAD(txGasPrice)
    $ => CTX            :MLOAD(currentCTX)
    C                   :MSTORE(txGasPrice)
    A => GAS

    $ => A              :MLOAD(argsLengthCall)
    A                   :MSTORE(txCalldataLen)
                        :CALL(copySP)
                        :JMP(txType)

; TODO if theres a delegate call inside a callCode, who is the msg.sender?
; should be the caller of the callCode? ( but we do not store this info yet)
opCALLCODE: ; TODO check staticCall
    SP - 7          :JMPN(stackUnderflow)
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    ; Store gas call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    ; Store address call
    $ => A          :MLOAD(SP--)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    A               :MSTORE(addrCall)
    ; Store value call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(valueCall)
    ; If is static and value is not 0 -> revert
    $ => B          :MLOAD(isStaticCall)
    B - 1           :JMPN(opCALLCODE2)
    0 - A           :JMPN(invalidStaticTx)

opCALLCODE2:
    ; Store bytes offset int the memory, the calldata of the subcontext
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    A               :MSTORE(lastMemOffset)
    ; Byte size to copy, size of the calldata of the subcontext
    $ => C          :MLOAD(SP--)
    C               :MSTORE(argsLengthCall)
    C               :MSTORE(lastMemLength)
    ; Mem expansion gas cost call args
                    :CALL(saveMem)

    ; Store byte offset in the memory in bytes, where to store the return data of the sub context.
    $ => B          :MLOAD(SP--)
    B               :MSTORE(lastMemOffset)
    ; Store byte size to copy (size of the return data).
    $ => D          :MLOAD(SP)
    D               :MSTORE(lastMemLength)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - C - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - C -32 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCounters)
                    :CALL(saveMem)

    $ => E          :MLOAD(storageAddr)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    E               :MSTORE(txSrcAddr)
    E               :MSTORE(storageAddr)
    SR              :MSTORE(initSR)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    B               :MSTORE(retCallOffset)
    D               :MSTORE(retCallLength)

    ; If addr in touched addres D = 0, else D = 1
    ${touchedAddress(A)} => D

    ;gas_cost = memory_expansion_cost + code_execution_cost + address_access_cost + positive_value_cost
    ; Calculate address_access_cost: 100 for warm account, 2600 for cold account
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
    ; Calculate positive_value_cost, if value call > 0 -> 9000
    $ => B                   :MLOAD(valueCall)
    B                        :MSTORE(txValue)
    0 => A
    $ => C                   :LT
    ; Substract gas if the call has value
    GAS - 9000*C => GAS      :JMPN(outOfGas)

opCALLCODEend:
                    :CALL(computeGasSendCall)
    ; Add estipend (2300) in case of tx with value
    A + 2300*C => A
    $ => CTX        :MLOAD(originCTX)
    $ => B          :MLOAD(txGasPrice)
    GAS - A + 2300*C:MSTORE(gasCTX)
    $ => CTX        :MLOAD(currentCTX)
    A => GAS
    B               :MSTORE(txGasPrice)
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
                    :CALL(copySP)
                    :JMP(txType)

opRETURN:
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;offset
    $ => C          :MLOAD(SP)   ;length

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 32 => A
    C => B
    $ => B                  :SUB
    B                       :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 32 => A
    C => B
    $ => B                  :SUB
    B                       :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCounters)

    E               :MSTORE(retDataOffset)
    C               :MSTORE(retDataLength)
    E               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)
                    :CALL(saveMem)
    $ => D          :MLOAD(isCreateContract)
    0 - D           :JMPN(opRETURNdeploy)
    $ => B          :MLOAD(originCTX)
    B - 1           :JMPN(handleGas)
    $ => B          :MLOAD(gasRefund)
    $ => A          :MLOAD(currentCTX)
    $ => CTX        :MLOAD(originCTX)
    ; Add return data context value to origin context
    A               :MSTORE(retDataCTX)
    $ => A          :MLOAD(gasRefund)
    A + B           :MSTORE(gasRefund)
    $ => B          :MLOAD(gasCTX)
    B + GAS => GAS

    $ => CTX        :MLOAD(currentCTX)
    $ => D          :MLOAD(retCallLength)
    C => A
    D => B
    $               :LT,JMPC(opRETURN32) ; Take the smaller one
    D => C

; Copy from memory current CTX to memory origin CTX
opRETURN32:
    $ => B          :MLOAD(retCallOffset)
    C - 1           :JMPN(opRETURNend)
    C - 32          :JMPN(opRETURNfinal)
                    :CALL(MLOAD32)
    E => D
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => B
    D => E
    C - 32 => C
    $ => CTX        :MLOAD(currentCTX)
                    :JMP(opRETURN32)

opRETURNfinal:
                    :CALL(MLOADX)
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
    $ => CTX        :MLOAD(currentCTX)

opRETURNend:
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    1               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)


opRETURNdeploy:
; TODO check what does return?  what assures returned_code_size is correct?
    GAS - 200 * C => GAS    :JMPN(outOfGas) ;code_deposit_cost = 200 * returned_code_size
    $ => B          :MLOAD(originCTX)       ;last ctx
    0 - B           :JMPN(opRETURNcreate)
                    :JMP(endDeploy)

; TODO: not in RETURN, but in CREATE process
opRETURNcreate:

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 192 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - 192 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 1020 :JMPN(outOfCounters)

    ; save offset memory and length to compute contract hash
    E               :MSTORE(memOffsetLinearPoseidon)
    C               :MSTORE(memSizeLinearPoseidon)

    CTX             :MSTORE(currentCTX)
    $ => B          :MLOAD(gasRefund)
    $ => CTX        :MLOAD(originCTX)
    $ => A          :MLOAD(gasRefund)
    A + B           :MSTORE(gasRefund)
    $ => B          :MLOAD(gasCTX)
    ; TODO Should be substracted first the gas
    B + GAS => GAS
    $ => CTX        :MLOAD(currentCTX)
    $ => A          :MLOAD(txSrcAddr)
    $ => D          :MLOAD(txNonce)

    ; set bytecode length
    $ => A          :MLOAD(createContractAddress)
    %SMT_KEY_SC_LENGTH => B
    C => D
    0 => C
    $ => SR         :SSTORE

    ; get bytecode and hash it
                        :CALL(hashPoseidonLinearFromMemory)
    $ => A              :MLOAD(createContractAddress)
    0 => C
    %SMT_KEY_SC_CODE => B

    $ => SR                         :SSTORE

opRETURNcreateEnd:
    $ => A          :MLOAD(createContractAddress)
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
    0               :MSTORE(retDataCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

; TODO if theres a delegate call, there should be not moveBalances
opDELEGATECALL:
    SP - 6          :JMPN(stackUnderflow)
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    ; Store gas call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    ; Store address call
    $ => A          :MLOAD(SP--)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    A               :MSTORE(addrCall)
    ; Store bytes offset int the memory, the calldata of the subcontext
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    A               :MSTORE(lastMemOffset)

    ; Byte size to copy, size of the calldata of the subcontext
    $ => C          :MLOAD(SP--)
    C               :MSTORE(argsLengthCall)
    C               :MSTORE(lastMemLength)
    ; Mem expansion gas cost call args
                    :CALL(saveMem)

    ; Store byte offset in the memory in bytes, where to store the return data of the sub context.
    $ => B          :MLOAD(SP--)
    B               :MSTORE(lastMemOffset)
    ; Store byte size to copy (size of the return data).
    $ => D          :MLOAD(SP)
    D               :MSTORE(lastMemLength)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - C - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - C -32 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCounters)
    ;  Mem expansion gas cost return args
                    :CALL(saveMem)

    $ => C          :MLOAD(txSrcAddr)
    $ => E          :MLOAD(storageAddr)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    C               :MSTORE(txSrcAddr)
    E               :MSTORE(storageAddr)
    1               :MSTORE(isDelegateCall)
    SR              :MSTORE(initSR)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)

    B               :MSTORE(retCallOffset)
    D               :MSTORE(retCallLength)

    ${touchedAddress(A)} => D
    ;gas_cost = base_gas + gas_sent_with_call
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
                    :CALL(computeGasSendCall)
    $ => CTX        :MLOAD(originCTX)
    $ => C          :MLOAD(txGasPrice)
    GAS - A         :MSTORE(gasCTX)
    $ => B          :MLOAD(txValue)
    $ => CTX        :MLOAD(currentCTX)
    B               :MSTORE(txValue)
    C               :MSTORE(txGasPrice)
    A => GAS

opDELEGATECALLend:
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
                    :CALL(copySP)
                    :JMP(txType)

; // TODO Check with DElEGATE CALL txDestAddr/txSrcAddr ( same as other calls)
; // TODO check revert create
opCREATE2:
    SP - 4              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => A              :MLOAD(SP--)    ;value
    A                   :MSTORE(valueCall)
    $ => E              :MLOAD(SP--)    ;offset
    E                   :MSTORE(argsOffsetCall)
    $ => C              :MLOAD(SP--)      ;length
    C                   :MSTORE(argsLengthCall)
    $ => D              :MLOAD(SP)    ;salt

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - C - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - C -32 :JMPN(outOfCounters)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCounters)

    ; Mem expansion gas cost
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    CTX                 :MSTORE(originAuxCTX)
    $ => E              :MLOAD(txDestAddr)
    GAS - 32000 => GAS  :JMPN(outOfGas)
    ; Cost to hash the initialisation code before
    ; Div operation with Arith
    ${C+31}             :MSTORE(arithA)
    32                  :MSTORE(arithB)
                        :CALL(divARITH)
    $ => C              :MLOAD(arithRes1)
    GAS => A
    6*C => B
    $                   :LT,JMPC(outOfGas)
    A - B => GAS

    GAS => C            :MSTORE(gasCall)
    SP                  :MSTORE(lastSP)
    PC                  :MSTORE(lastPC)
    ;change new CTX
    $ => A              :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX          :MSTORE(lastCtxUsed)
    CTX                 :MSTORE(currentCTX)
    1                   :MSTORE(isCreateContract)
    1                   :MSTORE(isCreate)
    1                   :MSTORE(isCreate2)
    D                   :MSTORE(salt)
    $ => A              :MLOAD(originAuxCTX)
    A                   :MSTORE(originCTX)
    C => GAS
                        :CALL(computeGasSendCall)
    $ => CTX            :MLOAD(originCTX)
    GAS - A             :MSTORE(gasCTX)
    $ => CTX            :MLOAD(currentCTX)
    A => GAS
    E                   :MSTORE(txSrcAddr)
                        :CALL(copySP)
    $ => A              :MLOAD(txSrcAddr)
    %SMT_KEY_NONCE => B
    0 => C                                                                                  ; 3rd parameter does not apply to nonce
    $ => B              :SLOAD
    B                   :MSTORE(txNonce)
    B + 1 => D
    %SMT_KEY_NONCE => B
    0 => C
    $ => SR             :SSTORE
    SR                  :MSTORE(initSR)
    $ => B              :MLOAD(txNonce)
                        :CALL(getLenBytes)
    A                   :MSTORE(lengthNonce)
    $ => A              :MLOAD(argsLengthCall)
    A                   :MSTORE(txCalldataLen)
    $ => A              :MLOAD(valueCall)
    A                   :MSTORE(txValue)
; TODO: memory?
;    $ => B             :MLOAD(memLength)
;    B - X              :JMPN(saveMemLength)
                        :JMP(txType)

;TODO same as other calls
opSTATICCALL:
    SP - 6          :JMPN(stackUnderflow)
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    $ => A          :MLOAD(SP--)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    A               :MSTORE(addrCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    A               :MSTORE(lastMemOffset)

    $ => B          :MLOAD(SP--)
    B               :MSTORE(argsLengthCall)
    B               :MSTORE(lastMemLength)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - B - 32 :JMPN(outOfCounters)
    %MAX_CNT_BINARY - CNT_BINARY - B -32 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCounters)

    ; Mem expansion gas cost call args
                    :CALL(saveMem)

    $ => B          :MLOAD(SP--)
    B               :MSTORE(lastMemOffset)

    $ => D          :MLOAD(SP)
    D               :MSTORE(lastMemLength)
    ;  Mem expansion gas cost return args
                    :CALL(saveMem)

    $ => C          :MLOAD(txDestAddr)
    SR              :MSTORE(initSR)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    0               :MSTORE(txValue)
    1               :MSTORE(isStaticCall)
    C               :MSTORE(txSrcAddr)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    A               :MSTORE(storageAddr)
    B               :MSTORE(retCallOffset)
    D               :MSTORE(retCallLength)

    ${touchedAddress(A)} => D
    ;gas_cost = base_gas + gas_sent_with_call
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
                    :CALL(computeGasSendCall)
    $ => CTX        :MLOAD(originCTX)
    $ => C          :MLOAD(txGasPrice)
    GAS - A         :MSTORE(gasCTX)
    $ => CTX        :MLOAD(currentCTX)
    A => GAS
    C               :MSTORE(txGasPrice)
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
                    :CALL(copySP)
                    :JMP(txType)

; TODO logs, creates (shpoudl revert the call also?), calls(back to initSR)
; TODO memExpansion just like Return
opREVERT:
    SP - 2          :JMPN(stackUnderflow)
    $ => SR         :MLOAD(initSR)
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;offset
    $ => C          :MLOAD(SP) ;length
    E               :MSTORE(retDataOffset)
    C               :MSTORE(retDataLength)
    E               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)
                    :CALL(saveMem)

    $ => B          :MLOAD(originCTX)
    ${eventLog(onError, revert)}
    B - 1           :JMPN(handleGas)
    $ => A          :MLOAD(currentCTX)
    B => CTX
    ; Add return data context value to origin context
    A               :MSTORE(retDataCTX)

    $ => B          :MLOAD(gasCTX)
    GAS + B => GAS

    A => CTX; current context
    $ => D          :MLOAD(retCallLength)
    C => A
    D => B
    $               :LT,JMPC(opREVERT32)
    D => C

; Copy from memory current CTX to memory origin CTX
opREVERT32:
    $ => B          :MLOAD(retCallOffset)
    C - 1           :JMPN(opREVERTend)
    C - 32          :JMPN(opREVERTfinal)
                    :CALL(MLOAD32)
    E => D
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => B
    D => E
    C - 32 => C
    $ => CTX        :MLOAD(currentCTX)
                    :JMP(opREVERT32)

opREVERTfinal:
                    :CALL(MLOADX)
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
    $ => CTX        :MLOAD(currentCTX)

opREVERTend:
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

; // TODO: handle if depth is over 0
; DelegateCAll + selfdestruct, should destroy the caller bytecode
; Test selfDestruct: sent value to another contract
; TODO selfdestrut should destory the contract at the end of the transaction
opSELFDESTRUCT:

    ;Check counters
    %MAX_CNT_BINARY - CNT_BINARY - 10 :JMPN(outOfCounters)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 2040 :JMPN(outOfCounters)

    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    $ => A              :MLOAD(gasRefund)
    A + 24000           :MSTORE(gasRefund)
    GAS - 5000 => GAS   :JMPN(outOfGas)

    ; clean bytecode
    $ => A              :MLOAD(storageAddr)
    %SMT_KEY_SC_CODE => B
    0 => C
    0 => D
    $ => SR             :SSTORE

    ; clean contract length
    %SMT_KEY_SC_LENGTH => B
    $ => SR             :SSTORE

    ; get contract balance
    0 => B,C            ; balance key smt
    $ => E              :SLOAD
    E => D

    ; read receiver
    SP - 1 => SP        :JMPN(stackUnderflow)
    $ => A              :MLOAD(SP)
                        :CALL(maskAddress) ; Mask address to 20 bytes
    ; gas: check receiver is empty and balance gt 0
    A => C
    A => E
    0 => A
    D => B
    $                   :EQ,JMPC(opSELFDESTRUCT2)
                        :CALL(isEmptyAccount)
    GAS - 25000 * E => GAS    :JMPN(outOfGas)
opSELFDESTRUCT2:
    ; gas: check touched address
    C => A
    ${touchedAddress(A)} => E
    GAS - 2600 * E => GAS     :JMPN(outOfGas)

    ; read previous balance receiver
    0 => B,C            ; balance key smt
    $ => E              :SLOAD

    ; compute new receiver balance
    ; Add operation with Arith
    D               :MSTORE(arithA)
    E               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => D          :MLOAD(arithRes1)

    ; transfer balance to receiver
    $ => A                  :MLOAD(SP)
    0 => B,C                ; balance key smt
    $ => SR                 :SSTORE

    ; set contract balance to 0
    $ => A                  :MLOAD(storageAddr)
    0 => D
    $ => SR                 :SSTORE

    $ => A                  :MLOAD(originCTX)
    $                       :EQ,JMPC(handleGas)
    $ => B                  :MLOAD(gasRefund)
    $ => C                  :MLOAD(isCreate)
    1 => D
    C - 1                   :JMPN(opSELFDESTRUCTCend)
    $ => D                  :MLOAD(createContractAddress)

opSELFDESTRUCTCend:
    A => CTX
    0                       :MSTORE(retDataCTX)
    CTX                     :MSTORE(currentCTX)
    $ => A                  :MLOAD(gasRefund)
    A + B                   :MSTORE(gasRefund)
    $ => C                  :MLOAD(gasCTX)
    GAS + C => GAS
    $ => SP                 :MLOAD(lastSP)
    $ => PC                 :MLOAD(lastPC)
    D                       :MSTORE(SP++)
    1024 - SP               :JMPN(stackOverflow)
                            :JMP(readCode)

opINVALID:
    ; Equivalent to REVERT with 0,0 as stack parameters
    ; Remaining gas is consumed
    0 => GAS
    ; if main context, halt execution
    $ => B          :MLOAD(originCTX)
                    :JMP(invalidProcess)
