INCLUDE "utils.zkasm"
; // TODO: handle error not enough stack to read at the beginning of each opcode
; // TODO: handle error not enough GAS (OOG)
; // TODO: handle error too much stack (stack over 1024 - stack overflow)
opSTOP:
    $ => B          :MLOAD(originCTX)       ;last ctx
    B - 1           :JMPC(opSTOPend)
    B => CTX
    $ => B          :MLOAD(gasCTX)
    GAS + B => GAS
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    1               :MSTORE(SP++) ; // TODO: call to an EOA address, what is going on ?
                    :JMP(readCode)

opSTOPend:
                    :JMP(endCode)

opADD:
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => C          :MLOAD(SP)

    ; Add operation with Arith
    A               :MSTORE(arithA)
    C               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => E          :MLOAD(arithRes1)
    E               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opMUL:
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; Mul operation with Arith
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => E          :MLOAD(arithRes1)
    E               :MSTORE(SP++)
    GAS-5 => GAS
                    :JMP(readCode)

opSUB:
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => C          :MLOAD(SP)
    ; Sub operation with Arith
    E               :MSTORE(arithA)
    C               :MSTORE(arithB)
                    :CALL(subARITH)
    $ => A          :MLOAD(arithRes1)
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDIV:
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    B               :MSTORE(SP++)
    GAS-5 => GAS
                    :JMP(readCode)

opSDIV:
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
                    :CALL(abs)
    A => E
    B => C
    $ => A          :MLOAD(SP)
                    :CALL(abs)
    ; //TODO: save constrains
    ${bitwise_xor(bitwise_xor(C, B), 1)} - 1 :JMPC(opSDIVNeg)  ;0 negative, 1 positive
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    B               :MSTORE(SP++)
    GAS-5 => GAS
                   :JMP(readCode)
                   
opSDIVNeg:
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes1)

                   :CALL(ca2)
    A              :MSTORE(SP++)
    GAS-5 => GAS
                   :JMP(readCode)

opMOD:
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; Mod operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    GAS-5 => GAS
                    :JMP(readCode)

opSMOD:
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
                    :CALL(abs)
    A => E
    B => C
    $ => A          :MLOAD(SP)
                    :CALL(abs)

    ${bitwise_xor(C, 1)} - 1 :JMPC(opSMODNeg)  ; 0 negative, 1 positive

    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    GAS-5 => GAS
                    :JMP(readCode)

opSMODNeg:
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes2)
                    :CALL(ca2)
    A               :MSTORE(SP++)
    GAS-5 => GAS
                    :JMP(readCode)

opADDMOD:
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP--)
    ; Add operation with Arith
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => E          :MLOAD(arithRes1)
    $ => A          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    GAS-8 => GAS
                    :JMP(readCode)

opMULMOD:
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP--)
    ; Mul operation with Arith
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => E          :MLOAD(arithRes1) 
    $ => A          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    GAS-8 => GAS
                    :JMP(readCode)

opEXP: ; //TODO: test exp == 0
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ${exp(A,B)} => A
    A               :MSTORE(SP++)
                    :CALL(getLenBytes)
    GAS-10-50*A => GAS
                    :JMP(readCode)

opSIGNEXTEND: ; following this impl https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/vm/src/evm/opcodes/functions.ts#L193
   SP - 1 => SP
   $ => A          :MLOAD(SP--)
   $ => B          :MLOAD(SP)
   ${comp_lt(A, 31)} - 1  :JMPC(opSIGNEXTENDEnd)
   ; Add operation with Arith
   ${A * 8}         :MSTORE(arithA)
   7                :MSTORE(arithB)
                    :CALL(addARITH)
   $ => A           :MLOAD(arithRes1)
   ${exp(2, A)} => C ; signBit
   ${comp_gt(bitwise_and(C, B) , 0)} - 1 :JMPC(opSIGNEXTENDPositive) ; 0 if negative, -1 if positive
   ${bitwise_or(B, bitwise_not(C - 1))} => B
                  :JMP(opSIGNEXTENDEnd)

opSIGNEXTENDPositive:
    ; Sub operation with Arith
    C               :MSTORE(arithA)
    1               :MSTORE(arithB)
                    :CALL(subARITH)
    $ => A          :MLOAD(arithRes1)
    ${bitwise_and(B, A)} => B

opSIGNEXTENDEnd:
    B               :MSTORE(SP++)
    GAS-5 => GAS
                    :JMP(readCode)

; // TODO: "set0" and "set1" move to utils
set0:
    0               :MSTORE(SP++)
                    :JMP(readCode)

set1:
    1               :MSTORE(SP++)
                    :JMP(readCode)

opSLT:
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => C          :MLOAD(SP)
    1 => B
    0 => D
    ${E-C} => A
    ;E               :ARITH
    GAS-3 => GAS
    ${comp_gt(A, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)} :MSTORE(SP++)
                        :JMP(readCode)
opLT:
    SP - 1 => SP
    $ => A              :MLOAD(SP--)
    $ => B              :MLOAD(SP)
    GAS-3 => GAS
    ${comp_lt(A, B)}    :MSTORE(SP++)
                        :JMP(readCode)

opSGT:
    SP - 1 => SP
    $ => C          :MLOAD(SP--)
    $ => E          :MLOAD(SP)
    1 => B
    0 => D
    ${E-C} => A
    ;E               :ARITH
    GAS-3 => GAS
    ${comp_gt(A, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)}   :MSTORE(SP++)
                        :JMP(readCode)
opGT:
    SP - 1 => SP
    $ => A              :MLOAD(SP--)
    $ => B              :MLOAD(SP)
    GAS-3 => GAS
    ${comp_gt(A, B)}    :MSTORE(SP++)
                        :JMP(readCode)
opEQ:
    SP - 1 => SP
    $ => A              :MLOAD(SP--)
    $ => B              :MLOAD(SP)
    GAS-3 => GAS
    ${comp_eq(A, B)}    :MSTORE(SP++)
                        :JMP(readCode)

opISZERO:
    SP - 1 => SP
    $ => A              :MLOAD(SP)
    GAS-3 => GAS
    ${comp_eq(A, 0)}    :MSTORE(SP++)
                        :JMP(readCode)

opAND:
    SP - 1 => SP
    $ => A                  :MLOAD(SP--)
    $ => B                  :MLOAD(SP)
    GAS-3 => GAS
    ${bitwise_and(A, B)}    :MSTORE(SP++)
                            :JMP(readCode)

opOR:
    SP - 1 => SP
    $ => A                  :MLOAD(SP--)
    $ => B                  :MLOAD(SP)
    GAS-3 => GAS
    ${bitwise_or(A, B)}     :MSTORE(SP++)
                            :JMP(readCode)

opXOR:
    SP - 1 => SP
    $ => A                  :MLOAD(SP--)
    $ => B                  :MLOAD(SP)
    GAS-3 => GAS
    ${bitwise_xor(A, B)}    :MSTORE(SP++)
                            :JMP(readCode)

opNOT:
    SP - 1 => SP
    $ => A                  :MLOAD(SP)
    GAS-3 => GAS
    ${bitwise_not(A)}       :MSTORE(SP++)
                            :JMP(readCode)

opBYTE:
    SP - 1 => SP
    $ => B                  :MLOAD(SP--)
    $ => A                  :MLOAD(SP)
    31 - B => D
    $ => B                  :SHR
    GAS-3 => GAS
    ${bitwise_and(B, 255)}  :MSTORE(SP++)
                            :JMP(readCode)

; TODO: Adapt to division
opSHR:  ; //TODO: SHR byte by byte working fine. Not working when shifting bits. Could be done by: [B / 2**(A%8)] or SHR bits directly
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    8               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => D          :MLOAD(arithRes1)
    $ => C          :MLOAD(arithRes2)

    ${comp_gt(D, 32)} => B
    ${B * 32 + bitwise_xor(B, 1) * D} => D

    $ => A          :MLOAD(SP)
    $ => A          :SHR
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

; TODO: Adapt to multiplication
opSHL:  ; //TODO: SHL byte by byte working fine. Not working when shifting bits. Could be done by: [B / 2**(A%8)] or SHR bits directly
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    8               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => D          :MLOAD(arithRes1)
    $ => C          :MLOAD(arithRes2)
    ${comp_gt(D, 32)} => B
    ${B * 32 + bitwise_xor(B, 1) * D} => D

    $ => A          :MLOAD(SP)
    $ => A          :SHL
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

; TODO: Adapt to multiplication
; https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/vm/src/evm/opcodes/functions.ts#L342
opSAR:
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    8               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => D          :MLOAD(arithRes1)
    ${comp_gt(D, 32)} => B
    ${B * 32 + bitwise_xor(B, 1) * D} => D

    $ => A          :MLOAD(SP)
                    :CALL(abs)
                    ; if more than 32 set to 32
    $ => A          :SHR
    ${bitwise_xor(B, 1)} - 1 :JMPC(opSARNeg)  ; 0 negative, 1 positive
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSARNeg:
    ; Add operation with Arith
    ${comp_gt(1, A)}:MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => A          :MLOAD(arithRes1)
    ; TODO: add comments
                    :CALL(ca2)
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSHA3:
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ; offset
    $ => C          :MLOAD(SP) ; length
    E + C           :MSTORE(lastMemLength)
    ; gas
    GAS - 30 => GAS ; gas static = 30
    ; Div operation with Arith
    ;${6*((C+31)/32)}
    C+31 => A
    ;(C+31)/32
    A               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes1)
    ; Mul operation with Arith
    ; 6*((C+31)/32)
    6               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => A          :MLOAD(arithRes1)
    GAS - A => GAS  ; dynamic_gas = dynamic_gas = 6 * minimum_word_size + memory_expansion_cost
    ; new hash id
    $ => B           :MLOAD(lastHashIdUsed)
    B + 1 => B       :MSTORE(lastHashIdUsed)
    32 => D

opSHA3Loop:
    C - 1           :JMPC(opSHA3End)
    C - 32          :JMPC(opSHA3Final)
                    :CALL(MLOAD32)
    E => B
    $ => E          :MLOAD(lastHashIdUsed)
    A               :HASHW(E)
    B => E
    C - 32 => C
                    :JMP(opSHA3Loop)
opSHA3Final:
                    :CALL(MLOADX)
    32 - C => D
    $ => A          :SHR
    $ => E          :MLOAD(lastHashIdUsed)
    C => D
    A               :HASHW(E)

opSHA3End:
    $ => E          :MLOAD(lastHashIdUsed)
                    :HASHE(E)
    $ => A          :HASHR(E)
    A               :MSTORE(SP++)
    $ => E          :MLOAD(lastMemLength)
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

; // TODO: check opcode with DelegateCall (storage or implementation address)
opADDRESS:
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPC(opADDRESSdeploy)
    $ => A          :MLOAD(txDestAddr)
                    :JMP(opADDRESSend)

opADDRESSdeploy:
    $ => A          :MLOAD(createContractAddress)

opADDRESSend:
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opBALANCE:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    0 => B,C
    $ => D          :SLOAD
    D               :MSTORE(SP++)
    ${touchedAddress(A,CTX)} => D
    GAS-100-D*2500 => GAS
                    :JMP(readCode)

opORIGIN:
    $ => A          :MLOAD(txSrcOriginAddr)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opCALLER:
    $ => A          :MLOAD(txSrcAddr)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opCALLVALUE:
    $ => A          :MLOAD(txValue)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

; // TODO: Check when a contract is deployed with CREATE
opCALLDATALOAD:
    SP - 1 => SP
    $ => E          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    $ => A          :MLOAD(arithRes2)
    0 - A           :JMPC(opCALLDATALOAD2)
    SP => C
    1024 + B => SP
    $ => B          :MLOAD(SP)
    C => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opCALLDATALOAD2:
    SP => C
    A => D
    1024 + B => SP
    $ => A          :MLOAD(SP++)
    $ => B          :SHL
    32 - D => D
    $ => A          :MLOAD(SP)
    $ => A          :SHR
    C => SP
    B + A           :MSTORE(SP++)
    GAS - 3 => GAS
                    :JMP(readCode)

opCALLDATASIZE:
    $ => B          :MLOAD(txCalldataLen)
    B               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

; // TODO: check overflow length datacopy
opCALLDATACOPY:
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;destOffset - offset memory
    $ => B          :MLOAD(SP--) ;offset calldata
    $ => C          :MLOAD(SP)   ;length calldata
    E+C             :MSTORE(lastMemLength)
    GAS - 3 => GAS
    GAS - ${3*((C+31)/32)} => GAS
    SP              :MSTORE(SPw)
                    :JMP(opCALLDATACOPYinit)

opCALLDATACOPYinit:
    C - 1           :JMPC(opCALLDATACOPYend)
    C - 32          :JMPC(opCALLDATACOPYfinal)
    B               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => D          :MLOAD(arithRes2)            
    $ => A          :MLOAD(arithRes1)    
    1024 + A => SP
    $ => A          :MLOAD(SP)
    $ => C          :SHL
    $ => A          :MLOAD(arithRes1) 
    1024 + A + 1 => SP
    32 - D => D
    $ => A          :MLOAD(SP)
    $ => A          :SHR
    A + C           :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    $ => SP         :MLOAD(SPw)
    $ => C          :MLOAD(SP)   ;length
    C - 32 => C
    C               :MSTORE(SP)
    B + 32 => B
                    :JMP(opCALLDATACOPYinit)

opCALLDATACOPYfinal:
    ${B%32} => D
    1024 + ${B/32} => SP
    $ => A          :MLOAD(SP)
    $ => A          :SHL
    $ => SP         :MLOAD(SPw)
    $ => C          :MLOAD(SP)   ;length
    1024 + ${B/32} + 1 => SP
    C - 32 + D => D
    D               :JMPC(opCALLDATACOPYxor)
    A => B
    $ => A          :MLOAD(SP)
    32 - D => D
    $ => A          :SHR
    32 - C => D
    $ => A          :SHL
    B + A => A
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
                    :JMP(opCALLDATACOPYend)

opCALLDATACOPYxor:
    32 - C => D
    $ => A          :SHR
    $ => A          :SHL
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)

opCALLDATACOPYend:
    $ => SP         :MLOAD(SPw)
    $ => E          :MLOAD(lastMemLength)
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

; missing verification --> hash table needed
opCODESIZE:
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPC(opCODESIZEdep)
    $ => A          :MLOAD(txDestAddr)
    2 => B
    0 => C
    $ => A          :SLOAD
    ${getBytecodeLength(A)} => B
    B               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opCODESIZEdep: ;//TODO: create/create2, constructor parameters, initBytcode vs deployed Bytecode
    $ => B          :MLOAD(txCalldataLen)
    B               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opCODECOPY:
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPC(opCALLDATACOPY) ; //TODO:
    $ => A          :MLOAD(txDestAddr) ; //TODO: delegate call ?
    2 => B
    0 => C
    $ => A          :SLOAD
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;destOffset, memory offset
    $ => B          :MLOAD(SP--) ;offset, bytecode offset
    $ => C          :MLOAD(SP)   ;length
    E+C             :MSTORE(lastMemLength)
    GAS - 3 => GAS
    GAS - ${3*((C+31)/32)} => GAS

opCODECOPYinit:
    C - 1           :JMPC(opCODECOPYend)
    C - 32          :JMPC(opCODECOPYfinal)
    ${getBytecode(A,B,32)} => D
    D               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    C - 32 => C
    B + 32 => B
                    :JMP(opCODECOPYinit)

opCODECOPYfinal:
    ${getBytecode(A,B,C)} => A
    32 - C  => D
    $ => A          :SHL
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)

opCODECOPYend:
    $ => E          :MLOAD(lastMemLength)
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

opGASPRICE:
    $ => A          :MLOAD(txGasPrice)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opEXTCODESIZE: ; // TODO: check precompiled? should return 0?
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    ${touchedAddress(A,CTX)} => D
    2 => B
    0 => C
    $ => A          :SLOAD
    ${getBytecodeLength(A)} => B
    B               :MSTORE(SP++)
    GAS-100-D*2500 => GAS
                    :JMP(readCode)

opEXTCODECOPY: ; // TODO: check precompiled?
    SP - 1 => SP
    $ => A          :MLOAD(SP--) ;addr
    ${touchedAddress(A,CTX)} => D
    2 => B
    0 => C
    $ => A          :SLOAD       ;hash
    $ => E          :MLOAD(SP--) ;destOffset; memory offset
    $ => B          :MLOAD(SP--) ;offset ; bytecode offset
    $ => C          :MLOAD(SP)   ;length
    E+C             :MSTORE(lastMemLength)
    GAS-100-D*2500 => GAS
    GAS - ${3*((C+31)/32)} => GAS

opEXTCODECOPYinit:
    C - 1           :JMPC(opEXTCODECOPYend)
    C - 32          :JMPC(opEXTCODECOPYfinal)
    ${getBytecode(A,B,32)} => D
    D               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    C - 32 => C
    B + 32 => B
                    :JMP(opEXTCODECOPYinit)

opEXTCODECOPYfinal:
    ${getBytecode(A,B,C)} => A
    32 - C  => D
    $ => A          :SHL
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)

opEXTCODECOPYend:
    $ => E          :MLOAD(lastMemLength)
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

; // TODO: should read from return buffer
opRETURNDATASIZE:
    $ => A          :MLOAD(retLength)
    A               :MSTORE(SP++)
    GAS - 2 => GAS
                    :JMP(readCode)

; // TODO: check enough data, otherwise expection OOG
; // TODO: should read from return buffer
opRETURNDATACOPY:
    SP - 1 => SP
    $ => D          :MLOAD(SP--)            ;destOffset - destination memory
    $ => B          :MLOAD(SP--)            ;offset - offset in return data
    ;TODO: offset is only offset or returndata + offset?
    $ => C          :MLOAD(retOffset)       ;RETURNDATA
    B + C => B                              ;RETURNDATA[offset:offset+length]
    $ => C          :MLOAD(SP)              ;length - length return data
    GAS - 3 => GAS
    ;${3*((C+31)/32)}
    C+31 => A
    ;(C+31)/32
    A               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes1)
    ; Mul operation with Arith
    ; 3*((C+31)/32)
    3               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => A          :MLOAD(arithRes1)
    GAS - A => GAS 
    B + C           :MSTORE(lastMemLength)

opRETURNDATACOPYinit:
    C - 1           :JMPC(opRETURNDATACOPYend)
    C - 32          :JMPC(opRETURNDATACOPYfinal)
    B => E
                    :CALL(MLOAD32)
    E => B
    D => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => D
    C - 32 => C
                    :JMP(opRETURNDATACOPYinit)

opRETURNDATACOPYfinal:
    B => E
                    :CALL(MLOADX)
    E => B
    D => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)

opRETURNDATACOPYend:
    $ => E          :MLOAD(lastMemLength)
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

opEXTCODEHASH:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    ${touchedAddress(A,CTX)} => D
    GAS-100-D*2500 => GAS
    2 => B
    0 => C
    $ => A          :SLOAD
    $${p = 0}
    ${getBytecodeLength(A)} => C
    $ => E           :MLOAD(lastHashIdUsed)
    E+1 => E         :MSTORE(lastHashIdUsed)

opEXTCODEHASHinit:
    32 => D
    C - 1           :JMPC(opEXTCODEHASHend)
    C - 32          :JMPC(opEXTCODEHASHfinal)
    ${getBytecode(A,p,D)} => B ; //TODO: add state machine :READ_BYTECODE(A, P)
    B               :HASHW(E)
    C - D => C
    $${p = p + D}
                    :JMP(opEXTCODEHASHinit)

opEXTCODEHASHfinal:
    C => D
    ${getBytecode(A,p,C)} => B
    B               :HASHW(E)

opEXTCODEHASHend:
                    :HASHE(E)
    $ => A          :HASHR(E)
    A               :MSTORE(SP++)
                    :JMP(readCode)

opBLOCKHASH:
    SP - 1 => SP
    GAS-20 => GAS
    $ => A          :MLOAD(SP) ; batch number
    
    ; Check batch number is lt current batch number, else return 0
    $ => B          :MLOAD(numBatch)
    B - A - 1       :JMPC(opBLOCKHASHzero)
    
    ; Create key for the batch hash mapping key
    $ => E          :MLOAD(lastHashIdUsed)
    E+1 => E        :MSTORE(lastHashIdUsed)
    32 => D
    A               :HASHW(E)
    0               :HASHW(E) ; Storage position of the batch hash
                    :HASHE(E)
    $ => C          :HASHR(E)

    ; Load value from hashed key
    $ => A          :MLOAD(systemAddr)
    ; Set B to 3 to load from storage of address stored in A
    3 => B
    $ => E          :SLOAD

    ; Store result value in the stack
    E               :MSTORE(SP++)
                    :JMP(readCode)

; Handle when is asking for the hash of a not computed batch, return 0                   
opBLOCKHASHzero:
    0               :MSTORE(SP++)
                    :JMP(readCode)

opCOINBASE:
    $ => A          :MLOAD(sequencerAddr)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)


opTIMESTAMP:
    $ => A          :MLOAD(timestamp)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opNUMBER:
    $ => A          :MLOAD(numBatch)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opDIFFICULTY:
    $ => A         :MLOAD(batchDifficulty)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opGASLIMIT:
    $ => A          :MLOAD(batchGasLimit)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

opCHAINID:
    $ => A          :MLOAD(defaultChainId)
    A               :MSTORE(SP++)
    GAS-2 => GAS
                    :JMP(readCode)

; // TODO: check delegate call
opSELFBALANCE:
    $ => A          :MLOAD(txDestAddr)
    0 => B,C
    $ => D          :SLOAD
    D               :MSTORE(SP++)
    GAS-5 => GAS
                    :JMP(readCode)

opPOP:
    SP - 1 => SP
    GAS-2 => GAS
                    :JMP(readCode)

opMLOAD:
    SP - 1 => SP
    $ => E          :MLOAD(SP)                  ;offset
                    :CALL(MLOAD32)
    A               :MSTORE(SP++)
    GAS - 3 => GAS
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

opMSTORE:                                       ;MSTORE 32 bytes
    SP - 1 => SP
    $ => E          :MLOAD(SP--)                ;offset
    $ => B          :MLOAD(SP)                  ;value
    B               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    GAS - 3 => GAS
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

; // TODO: move to utils
saveMemLength:
                    :CALL(saveMem)
                    :JMP(readCode)

opMSTORE8:
    SP - 1 => SP
    $ => E          :MLOAD(SP--)                ;offset
    $ => A          :MLOAD(SP)                  ;value
    1 => C
    32 - C => D
    $ => A          :SHL
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
    GAS - 3 => GAS
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

opSLOAD:
    SP - 1 => SP
    $ => C          :MLOAD(SP) ;key
    $ => A          :MLOAD(storageAddr)
    3 => B
    $ => E          :SLOAD ;current value
    E               :MSTORE(SP++)
    ${touchedStorageSlots(A,C,CTX)} => A
    GAS - 100 - A*2000 => GAS
                    :JMP(readCode)

opSSTORE:
    $ => A          :MLOAD(iSstaticCall)
    0 - A           :JMPC(invalidStaticTx)
    SP - 1 => SP
    $ => C          :MLOAD(SP--) ;key
    $ => D          :MLOAD(SP) ; new value
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPC(deploymentSSTORE)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opSSTOREinit)

deploymentSSTORE:
    $ => A          :MLOAD(createContractAddress)

opSSTOREinit:
    3 => B
    $ => E          :SLOAD ;current value
    SR              :MSTORE(auxSR)
    $ => SR         :MLOAD(initSR)
    $ => B          :SLOAD ;origin value
    $ => SR         :MLOAD(auxSR)
    ${touchedStorageSlots(A,C,CTX)} => A
    GAS - A*2100 => GAS
    ${comp_eq(E, D)} - 1 :JMPC(opSSTOREdif)
    ;if new_val == current_val
    GAS - 100 => GAS
                    :JMP(opSSTOREend)

opSSTOREdif:
    ;if new_val != current_val
    ${comp_eq(B, E)} - 1 :JMPC(opSSTOREdifA)
    ;if current_val == orig_val
    ${comp_eq(0, B)} - 1 :JMPC(opSSTOREdifB)
    ;if origin_val == 0
    GAS - 20000 => GAS
                    :JMP(opSSTOREend)

opSSTOREdifA:
    ;if current_val != orig_val
    GAS - 100 => GAS

opSSTOREdifAA:
    ${comp_eq(0, B)} - 1 :JMPC(opSSTOREdifA1)
    ;if origin_value == 0
                    :JMP(opSSTOREdifAB)

opSSTOREdifAB:
    ${comp_eq(D, B)} - 1 :JMPC(opSSTOREend)
    ;if new_val == orig_val
    ${comp_eq(0, B)} - 1 :JMPC(opSSTOREdifA2)
    ;if orig_val == 0
    $ => A          :MLOAD(gasRefund)
    A + 19900 => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREdifA1:
    ;if orig_val != 0
    ${comp_eq(0, E)} - 1 :JMPC(opSSTOREdifA12)
    ;if current_val == 0
    $ => A          :MLOAD(gasRefund)
    A - 15000 => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREdifAB)
opSSTOREdifA12:
    ;if current_val != 0
    ${comp_eq(0, D)} - 1 :JMPC(opSSTOREdifAB)
    ;if new_val == 0
    $ => A          :MLOAD(gasRefund)
    A + 15000 => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREdifAB)

opSSTOREdifA2:
    ;if orig_val != 0
    $ => A          :MLOAD(gasRefund)
    A + 2800 => A   :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREdifB:
    ;if orig_val != 0
    GAS - 2900 => GAS
    ${comp_eq(0, D)} - 1 :JMPC(opSSTOREend)
    ;if new_val == 0
    $ => A          :MLOAD(gasRefund)
    A + 15000 => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREend:
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPC(mloadContract)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opSSTOREsr)

mloadContract:
    $ => A          :MLOAD(createContractAddress)

opSSTOREsr:
    3 => B
    $ => SR         :SSTORE
                    :JMP(readCode)

; // TODO: Check error: addrOp("E") == 5B (JUMPDEST)
opJUMP:
    SP - 1 => SP
    $ => E          :MLOAD(SP) ; //TODO: $ => PC
    E => PC
    GAS - 8 => GAS
                    :JMP(readCode)

; // TODO: Check error: addrOp("E") == 5B (JUMPDEST)
opJUMPI:
    SP - 2 => SP
    $ => B                  :MLOAD(SP)
    GAS - 10 => GAS
    ${comp_gt(B, 0)} - 1    :JMPC(readCode)
    SP + 1 => SP
    $ => E                  :MLOAD(SP--) ; //TODO: $ => PC
    E => PC
                            :JMP(readCode)

; // TODO: check in YUL
opPC:
GAS - 2 => GAS
PC                 :MSTORE(SP++)
                   :JMP(readCode)

opMSIZE:
GAS - 2 => GAS
$ => A             :MLOAD(memLength)
A                  :MSTORE(SP++)
                   :JMP(readCode)

opGAS:
    GAS - 2 => GAS
    GAS             :MSTORE(SP++)
                    :JMP(readCode)

opJUMPDEST:
    GAS - 1 => GAS
                    :JMP(readCode)

opAuxPUSHA:
    ${getBytecode(A,PC,D)} => B
    B                           :MSTORE(SP++)
    PC + D => PC
    GAS-3 => GAS
                                :JMP(readCode)

opAuxPUSHB:
    SP                          :MSTORE(SPw)
    $ => SP                     :MLOAD(SPr) ; SPr == 1024
    ; Div operation with Arith
    PC              :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes1)
    $ => C          :MLOAD(arithRes2)
    SP + A => SP
    A - ${(PC+D)/32}            :JMPC(opAuxPUSHC)
    $ => A                      :MLOAD(SP)
    $ => SP                     :MLOAD(SPw)
    ${getByte(A,C,D)} => B
    B                           :MSTORE(SP++)
    PC + D => PC
    GAS-3 => GAS
                                :JMP(readCode)

opAuxPUSHC:
    32 - C => E
    $ => A                      :MLOAD(SP++)
    ${getByte(A,C,E)} => A
    0 => C
    PC + D => PC
    D - E => D
    $ => B                      :MLOAD(SP)
    ${getByte(B,C,D)} => B
    $ => A                      :SHR
    $ => SP                     :MLOAD(SPw)
    A + B                       :MSTORE(SP++)
    GAS-3 => GAS
                                :JMP(readCode)

opPUSH1:
    1 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH2:
    2 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH3:
    3 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH4:
    4 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH5:
    5 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH6:
    6 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH7:
    7 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH8:
    8 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH9:
    9 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH10:
    10 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH11:
    11 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH12:
    12 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH13:
    13 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH14:
    14 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH15:
    15 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH16:
    16 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH17:
    17 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH18:
    18 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH19:
    19 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH20:
    20 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH21:
    21 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH22:
    22 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH23:
    23 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH24:
    24 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH25:
    25 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH26:
    26 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH27:
    27 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH28:
    28 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH29:
    29 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH30:
    30 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH31:
    31 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH32:
    32 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPC(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opDUP1:
    SP - 1 => SP
    $ => A          :MLOAD(SP++)
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP2:
    SP - 2 => SP
    $ => A          :MLOAD(SP)
    SP + 2 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP3:
    SP - 3 => SP
    $ => A          :MLOAD(SP)
    SP + 3 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP4:
    SP - 4 => SP
    $ => A          :MLOAD(SP)
    SP + 4 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP5:
    SP - 5 => SP
    $ => A          :MLOAD(SP)
    SP + 5 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP6:
    SP - 6 => SP
    $ => A          :MLOAD(SP)
    SP + 6 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP7:
    SP - 7 => SP
    $ => A          :MLOAD(SP)
    SP + 7 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP8:
    SP - 8 => SP
    $ => A          :MLOAD(SP)
    SP + 8 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP9:
    SP - 9 => SP
    $ => A          :MLOAD(SP)
    SP + 9 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP10:
    SP - 10 => SP
    $ => A          :MLOAD(SP)
    SP + 10 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP11:
    SP - 11 => SP
    $ => A          :MLOAD(SP)
    SP + 11 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP12:
    SP - 12 => SP
    $ => A          :MLOAD(SP)
    SP + 12 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP13:
    SP - 13 => SP
    $ => A          :MLOAD(SP)
    SP + 13 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP14:
    SP - 14 => SP
    $ => A          :MLOAD(SP)
    SP + 14 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP15:
    SP - 15 => SP
    $ => A          :MLOAD(SP)
    SP + 15 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opDUP16:
    SP - 16 => SP
    $ => A          :MLOAD(SP)
    SP + 16 => SP
    A               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP1:
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP++)
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP2:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 2 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 2 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP3:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 3 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 3 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP4:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 4 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 4 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP5:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 5 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 5 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP6:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 6 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 6 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP7:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 7 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 7 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP8:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 8 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 8 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP9:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 9 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 9 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP10:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 10 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 10 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP11:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 11 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 11 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP12:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 12 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 12 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP13:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 13 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 13 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP14:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 14 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 14 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP15:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 15 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 15 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

opSWAP16:
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 16 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 16 => SP
    B               :MSTORE(SP++)
    GAS-3 => GAS
                    :JMP(readCode)

; // TODO: save logs in memory and consolidate them once the tx is succesfull
; gas_cost = 375 + 375 * num_topics + 8 * data_size + mem_expansion_cost
opLOG0:
    $ => A              :MLOAD(iSstaticCall)
    0 - A               :JMPC(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E + C               :MSTORE(lastMemLength)
    0                   :MSTORE(numTopics)
    GAS - 375 => GAS                 ; static gas
    GAS - 8 * C => GAS               ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG1:
    $ => A              :MLOAD(iSstaticCall)
    0 - A               :JMPC(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E + C               :MSTORE(lastMemLength)
    1                   :MSTORE(numTopics)
    GAS - 375 => GAS                 ; static gas
    GAS - 8 * C => GAS               ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG2:
    $ => A              :MLOAD(iSstaticCall)
    0 - A               :JMPC(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E + C               :MSTORE(lastMemLength)
    2                   :MSTORE(numTopics)
    GAS - 375 => GAS                 ; static gas
    GAS - 8 * C => GAS               ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG3:
    $ => A              :MLOAD(iSstaticCall)
    0 - A               :JMPC(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E + C               :MSTORE(lastMemLength)
    3                   :MSTORE(numTopics)
    GAS - 375 => GAS                 ; static gas
    GAS - 8 * C => GAS               ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG4:
    $ => A              :MLOAD(iSstaticCall)
    0 - A               :JMPC(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E + C               :MSTORE(lastMemLength)
    4                   :MSTORE(numTopics)
    GAS - 375 => GAS                 ; static gas
    GAS - 8 * C => GAS               ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOGLoop:
    C - 1           :JMPC(opSaveTopicsInit)
    C - 32          :JMPC(opLOGFinal)
                    :CALL(MLOAD32)
    ${storeLog(B, 0, A)} ; storeLog(indexLog, isTopic, bytesToStore)
    C - 32 => C
                    :JMP(opLOGLoop)

opLOGFinal:
                    :CALL(MLOADX)
    ${storeLog(B, 0, A)}

opSaveTopicsInit:
    $ => A          :MLOAD(numTopics)

opSaveTopicsLoop:
    A - 1           :JMPC(opLOGend)
    SP - 1 => SP
    GAS - 375 => GAS
    $ => C          :MLOAD(SP)   ; topicX
    ${storeLog(B, 1, C)}     ; storeLog(indexLog, isTopic, bytesToStore)
    A - 1 =>  A
                    :JMP(opSaveTopicsLoop)

opLOGend:
    $ => E          :MLOAD(lastMemLength)
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

; // TODO Check with DElEGATE CALL txDestAddr/txSrcAddr ( same as other calls)
; // TODO check revert create
opCREATE:
    $ => A              :MLOAD(iSstaticCall)
    0 - A               :JMPC(invalidStaticTx)
    SP - 1 => SP
    $ => A              :MLOAD(SP--)    ;value
    A                   :MSTORE(valueCall)
    $ => E              :MLOAD(SP--)    ;offset
    E                   :MSTORE(argsOffsetCall)
    $ => C              :MLOAD(SP)      ;length
    C                   :MSTORE(argsLengthCall)
    CTX                 :MSTORE(originAuxCTX)
    $ => B              :MLOAD(txDestAddr)
    GAS => C
    SP                  :MSTORE(lastSP)
    PC                  :MSTORE(lastPC)
    ;change new CTX
    $ => A              :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX          :MSTORE(lastCtxUsed)
    1                   :MSTORE(isCreateContract)
    $ => A              :MLOAD(originAuxCTX)
    A                   :MSTORE(originCTX)
    B                   :MSTORE(txSrcAddr)
    B                   :MSTORE(txSrcOriginAddr)
    ; TODO is not encesesaary to load and store GAS, bc is global var
    C => GAS            
                        :CALL(copySP)
    B => A
    1 => B                                                                                  ; Constant for nonce
    0 => C                                                                                  ; 3rd parameter does not apply to nonce
    $ => B              :SLOAD
    B                   :MSTORE(txNonce)
                        :CALL(getLenBytes)
    A                   :MSTORE(lengthNonce)
    $ => A              :MLOAD(argsLengthCall)
    A                   :MSTORE(txCalldataLen)
    $ => A              :MLOAD(valueCall)
    A                   :MSTORE(txValue)
; TODO: memory?
;    $ => B          :MLOAD(memLength)
;    B - X           :JMPC(saveMemLength)
                        :JMP(txType)

; // TODO: Check returnOffset and returnSize parameters
; // Shpuld be set ? what happen if they are not set ?
; // Return buffer should be written always
; // If retOffet, retSize === 0 --> just not write in memory
; // Affects to opcodes related to RETURN
; // https://eips.ethereum.org/EIPS/eip-211

; TODO If inside a delegate/callcode, a call is made, the srcAddress 
; Should be the previous `srcAddress` but not the `txDestAddr`
; TODO ALL calls, initSR context var
opCALL:
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(addrCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(valueCall)
    $ => B          :MLOAD(iSstaticCall) ; TODO isStaticCall
    B - 1           :JMPC(opCALL2)
    0 - A           :JMPC(invalidStaticTx)

opCALL2:
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    $ => B          :MLOAD(SP--)
    B               :MSTORE(argsLengthCall)
    A + B => E
    $ => A          :MLOAD(SP--)
    A               :MSTORE(retOffset)
    $ => B          :MLOAD(SP)
    B               :MSTORE(retLength)
    A + B => D
    ${comp_lt(E,D)} - 1 :JMPC(opCALL3)
    D => E

opCALL3:
    $ => B          :MLOAD(memLength)
    E - B           :JMPC(opCALL4)
                    :CALL(saveMem)

opCALL4:
    $ => B          :MLOAD(txDestAddr)
    $ => D          :MLOAD(txSrcOriginAddr)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    B               :MSTORE(txSrcAddr)
    D               :MSTORE(txSrcOriginAddr)
    ${copyTouchedAddress(A,CTX)} ; // TODO: Check security copy same addresses
    ; // TODO: copyTouchedAddress once the depth CTX is returned
    ; // TODO: subcontext ?
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    A               :MSTORE(storageAddr)
    ${touchedAddress(A,CTX)} => D
    ;gas_cost = base_gas + gas_sent_with_call
    GAS-100-D*2500 => GAS
    $ => A          :MLOAD(valueCall)
    A               :MSTORE(txValue)
    0 - ${comp_eq(0, A)} :JMPC(opCALLend)
    GAS - 9000 => GAS
    ; // TODO: usage of ISEMPTY and add 25000 if needed
    ; if is_empty(target_addr) (forcing a new account to be created)
    ; GAS - 25000 => GAS

opCALLend:
                    :CALL(computeGasSendCall)
    $ => CTX        :MLOAD(originCTX)
    GAS - A         :MSTORE(gasCTX)
    $ => CTX        :MLOAD(currentCTX)
    A => GAS
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
    $ => E          :MLOAD(argsOffsetCall) ;offset
    $ => C          :MLOAD(argsLengthCall) ;length ; // TODO: duplicate MLOAD
                    :CALL(copySP)
                    :JMP(txType)

; TODO if theres a delegate call inside a callCode, who is the msg.sender?
; should be the caller of the callCode? ( but we do not store this info yet)
opCALLCODE: ; TODO check staticCall
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(addrCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(valueCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    $ => B          :MLOAD(SP--)
    B               :MSTORE(argsLengthCall)
    A + B => E
    $ => A          :MLOAD(SP--)
    A               :MSTORE(retOffset)
    $ => B          :MLOAD(SP)
    B               :MSTORE(retLength)
    A + B => D
    ${comp_lt(E,D)} - 1 :JMPC(opCALLCODE2)
    D => E

opCALLCODE2:
    $ => B          :MLOAD(memLength)
    E - B           :JMPC(opCALLCODE3)
                    :CALL(saveMem)

opCALLCODE3:
    $ => B          :MLOAD(txDestAddr)
    $ => C          :MLOAD(txSrcAddr)
    $ => D          :MLOAD(txSrcOriginAddr)
    $ => E          :MLOAD(storageAddr)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    B               :MSTORE(txSrcAddr)
    E               :MSTORE(storageAddr)
    D               :MSTORE(txSrcOriginAddr)
    ${copyTouchedAddress(A,CTX)}
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    ${touchedAddress(A,CTX)} => D
    ;gas_cost = base_gas + gas_sent_with_call
    GAS-100-D*2500 => GAS
    $ => A          :MLOAD(valueCall)
    A               :MSTORE(txValue)
    A - 1           :JMPC(opCALLCODEend)
    ; Substract gas if the call has value
    GAS - 9000 => GAS
    ; TODO: check gas_sent_with_call

opCALLCODEend:
                    :CALL(computeGasSendCall)
    $ => CTX        :MLOAD(originCTX)
    GAS - A         :MSTORE(gasCTX)
    $ => CTX        :MLOAD(currentCTX)
    A => GAS
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
    $ => E          :MLOAD(argsOffsetCall) ;offset
    $ => C          :MLOAD(argsLengthCall) ;length
                    :CALL(copySP)
                    :JMP(txType)

; // TODO: Redo to copy "return buffer"
;TODO RETURN + 32 bytes
opRETURN:
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;offset
    $ => C          :MLOAD(SP)   ;length
    E+C             :MSTORE(lastMemLength)
    $ => D          :MLOAD(isCreateContract)
    0 - D           :JMPC(opRETURNdeploy)
    $ => B          :MLOAD(originCTX)       ;last ctx
    B - 1           :JMPC(opRETURNend2)
    CTX             :MSTORE(currentCTX)
    $ => CTX        :MLOAD(originCTX)
    $ => B          :MLOAD(gasCTX)
    ; TODO Should be substracted first the gas
    B + GAS => GAS
    $ => B          :MLOAD(retOffset)
    ; TODO  Origin memory len != return memory len ?
    $ => CTX        :MLOAD(currentCTX)

; Copy from memory current CTX to memory origin CTX
opRETURN32:
    C - 1           :JMPC(opRETURNend)
    C - 32          :JMPC(opRETURNfinal)
                    :CALL(MLOAD32)
    E => D
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => B
    D => E
    C - 32 => C
    $ => CTX        :MLOAD(currentCTX)
                    :JMP(opRETURN32)

opRETURNfinal:
                    :CALL(MLOADX)
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
    $ => CTX        :MLOAD(currentCTX)

opRETURNend:
    $ => CTX        :MLOAD(originCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    1               :MSTORE(SP++)
    $ => E          :MLOAD(lastMemLength)
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(readCode)

; Return to last CTX
opRETURNend2:
    $ => E          :MLOAD(lastMemLength)
    $ => B          :MLOAD(memLength)
    B - E           :JMPC(saveMemLength)
                    :JMP(endCode)

opRETURNdeploy:
; TODO check what does return?  what assures returned_code_size is correct?
    GAS - 200 * C => GAS ;code_deposit_cost = 200 * returned_code_size
    $ => B          :MLOAD(originCTX)       ;last ctx
    0 - B           :JMPC(opRETURNcreate)
                    :JMP(endCode)

; TODO: not in RETURN, but in CREATE process
opRETURNcreate:
    $ => A          :MLOAD(txSrcAddr)
    $ => D          :MLOAD(txNonce)
    D + 1 => D
    1 => B
    0 => C
    $ => SR         :SSTORE
    ; Update contract SR
    $ => A          :MLOAD(createContractAddress)
    1 => B                                                                                  ; Constant for nonce
    0 => C
    1 => D
    $ => SR         :SSTORE

    ;TODO: deploy with value
    ${getHashBytecode(A)} => D
    2 => B
    0 => C
    $ => SR                         :SSTORE

    $ => B                          :MLOAD(txValue)
    0 - ${comp_eq(B,0)}             :JMPC(opRETURNcreateEnd)

; Decrement original balance
    $ => A                          :MLOAD(txSrcAddr)
    0 => B,C
    $ => E                          :SLOAD                                                  ; Original Balance in E
    $ => C                          :MLOAD(txValue)                                         ; A = E - C
    ; Sub operation with Arith
    E               :MSTORE(arithA)
    C               :MSTORE(arithB)
                    :CALL(subARITH)
    $ => A          :MLOAD(arithRes1)

    31 => D
    $ => B                          :SHR
    0x7F - B                        :JMPC(invalidTx)                                        ; If A is a negative value --> invalidTx
    1 => B
    0 => D
    A => D                                                                                  ; originalBalance -value in D
    $ => A                          :MLOAD(txSrcAddr)
    0 => B,C
    $ => SR                         :SSTORE
    ; Increment destination balance
    $ => A                          :MLOAD(createContractAddress)
    0 => B,C
    $ => C                          :SLOAD      ; Original Balance in E
    $ => A                          :MLOAD(txValue)
    ; Add operation with Arith
    A               :MSTORE(arithA)
    C               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => D          :MLOAD(arithRes1) ; originalBalance + value in D

    $ => A                          :MLOAD(createContractAddress)
    0 => B,C
    $ => SR                         :SSTORE

opRETURNcreateEnd:
    $ => B          :MLOAD(originCTX)       ;last ctx
    B => CTX
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    A               :MSTORE(SP++)
                    :JMP(readCode)
; TODO if theres a delegate call, there should be not moveBalances
opDELEGATECALL:
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(addrCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    $ => B          :MLOAD(SP--)
    B               :MSTORE(argsLengthCall)
    A + B => E
    $ => A          :MLOAD(SP--)
    A               :MSTORE(retOffset)
    $ => B          :MLOAD(SP)
    B               :MSTORE(retLength)
    A + B => D
    ${comp_lt(E,D)} - 1 :JMPC(opDELEGATECALL2)
    D => E

opDELEGATECALL2:
    $ => B          :MLOAD(memLength)
    E - B           :JMPC(opDELEGATECALL3)
                    :CALL(saveMem)

opDELEGATECALL3:
    $ => B          :MLOAD(txValue)
    $ => C          :MLOAD(txSrcAddr)
    $ => D          :MLOAD(txSrcOriginAddr)
    $ => E          :MLOAD(storageAddr)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    C               :MSTORE(txSrcAddr)
    E               :MSTORE(storageAddr)
    D               :MSTORE(txSrcOriginAddr)
    ${copyTouchedAddress(A,CTX)}
    B               :MSTORE(txValue)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    ${touchedAddress(A,CTX)} => D
    ;gas_cost = base_gas + gas_sent_with_call
    GAS-100-D*2500 => GAS
                    :CALL(computeGasSendCall)
    $ => CTX        :MLOAD(originCTX)
    GAS - A         :MSTORE(gasCTX)
    $ => CTX        :MLOAD(currentCTX)
    A => GAS

opDELEGATECALLend:
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
    $ => E          :MLOAD(argsOffsetCall) ;offset
    $ => C          :MLOAD(argsLengthCall) ;length
                    :CALL(copySP)
;    $ => B          :MLOAD(memLength)
;    B - X           :JMPC(saveMemLength)
                    :JMP(txType)

; // TODO Check with DElEGATE CALL txDestAddr/txSrcAddr ( same as other calls)
; // TODO check revert create
opCREATE2:
    $ => A              :MLOAD(iSstaticCall)
    0 - A               :JMPC(invalidStaticTx)
    SP - 1 => SP
    $ => A              :MLOAD(SP--)    ;value
    A                   :MSTORE(valueCall)
    $ => E              :MLOAD(SP--)    ;offset
    E                   :MSTORE(argsOffsetCall)
    $ => C              :MLOAD(SP--)      ;length
    C                   :MSTORE(argsLengthCall)
    $ => D              :MLOAD(SP)    ;salt
    CTX                 :MSTORE(originAuxCTX)
    $ => B              :MLOAD(txDestAddr)
    GAS => C
    SP                  :MSTORE(lastSP)
    PC                  :MSTORE(lastPC)
    ;change new CTX
    $ => A              :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX          :MSTORE(lastCtxUsed)
    1                   :MSTORE(isCreateContract)
    1                   :MSTORE(isCreate2)
    D                   :MSTORE(salt)
    $ => A              :MLOAD(originAuxCTX)
    A                   :MSTORE(originCTX)
    B                   :MSTORE(txSrcAddr)
    B                   :MSTORE(txSrcOriginAddr)
    ; TODO is not encesesaary to load and store GAS, bc is global var
    C => GAS
                        :CALL(copySP)
    B => A
    1 => B                                                                                  ; Constant for nonce
    0 => C                                                                                  ; 3rd parameter does not apply to nonce
    $ => B              :SLOAD
    B                   :MSTORE(txNonce)
                        :CALL(getLenBytes)
    A                   :MSTORE(lengthNonce)
    $ => A              :MLOAD(argsLengthCall)
    A                   :MSTORE(txCalldataLen)
    $ => A              :MLOAD(valueCall)
    A                   :MSTORE(txValue)
; TODO: memory?
;    $ => B          :MLOAD(memLength)
;    B - X           :JMPC(saveMemLength)
                        :JMP(txType)

;TODO same as other calls
opSTATICCALL:
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(addrCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    $ => B          :MLOAD(SP--)
    B               :MSTORE(argsLengthCall)
    A + B => E
    $ => A          :MLOAD(SP--)
    A               :MSTORE(retOffset)
    $ => B          :MLOAD(SP)
    B               :MSTORE(retLength)
    A + B => D
    ${comp_lt(E,D)} - 1 :JMPC(opSTATICCALL2)
    D => E

opSTATICCALL2:
    $ => B          :MLOAD(memLength)
    E - B           :JMPC(opSTATICCALL3)
                    :CALL(saveMem)

opSTATICCALL3:
    $ => B          :MLOAD(txDestAddr)
    $ => D          :MLOAD(txSrcOriginAddr)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    0               :MSTORE(txValue)
    1               :MSTORE(iSstaticCall)
    B               :MSTORE(txSrcAddr)
    D               :MSTORE(txSrcOriginAddr)
    ${copyTouchedAddress(A,CTX)}
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    A               :MSTORE(storageAddr)
    ${touchedAddress(A,CTX)} => D
    ;gas_cost = base_gas + gas_sent_with_call
    GAS-100-D*2500 => GAS
                    :CALL(computeGasSendCall)
    $ => CTX        :MLOAD(originCTX)
    GAS - A         :MSTORE(gasCTX)
    $ => CTX        :MLOAD(currentCTX)
    A => GAS
    ; TODO: check gas_sent_with_call
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
    $ => E          :MLOAD(argsOffsetCall) ;offset
    $ => C          :MLOAD(argsLengthCall) ;length
                    :CALL(copySP)
; TODO: memory?
;    $ => B          :MLOAD(memLength)
;    B - X           :JMPC(saveMemLength)
                    :JMP(txType)

; TODO revert should go back to the last state before a call
; TODO should be accounted the remaining gas to return to to the last ctx
; TODO logs, creates (shpoudl revert the call also?), calls(back to initSR)
; TODO initSR
opREVERT:
    SP - 1 => SP
    $ => A          :MLOAD(SP--) ;offset
    $ => B          :MLOAD(SP) ; length
    $ => C          :MLOAD(originCTX)       ;last ctx
    C - 1           :JMPC(opREVERTend)
    C => CTX
    $ => C          :MLOAD(gasCTX)
    GAS + C => GAS
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++)
                    :JMP(readCode)

opREVERTend:
    $ => SR         :MLOAD(initSR)
                    :JMP(endCode)

; // TODO: handle if depth is over 0
; DelegateCAll + selfdestruct, should destro the caller bytecode
; Test selfDestruct: sent value to another contract
opSELFDESTRUCT:
    $ => A              :MLOAD(iSstaticCall)
    0 - A               :JMPC(invalidStaticTx)
    24000               :MSTORE(gasRefund)
    GAS - 5000 => GAS

    ; clean bytecode
    $ => A              :MLOAD(txDestAddr)
    2 => B
    0 => C
    0 => D
    $ => SR             :SSTORE

    ; get contract balance
    0 => B,C
    $ => E              :SLOAD

    ; set contract balance to 0
    $ => SR             :SSTORE
    E => D              ; contract balance in D

    ; read receiver
    SP - 1 => SP
    $ => A              :MLOAD(SP)

    ; gas: check receiver is empty
    A => E
                        :CALL(ISEMPTY)
    GAS - 25000 * E => GAS

    ; gas: check touched address
    ${touchedAddress(A,CTX)} => E
    GAS - 2600 * E => GAS

    ; read previous balance receiver
    0 => B,C
    $ => E              :SLOAD

    ; compute new receiver balance
    ; Add operation with Arith
    D               :MSTORE(arithA)
    E               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => D          :MLOAD(arithRes1)

    ; transfer balance to receiver
    $ => A                  :MLOAD(SP)
    0 => B,C
    $ => SR                 :SSTORE

                            :JMP(endCode)

; TODO INVALID should go back to the last state before a call same as revert
opINVALID:
    ; Equivalent to REVERT with 0,0 as stack parameters
    ; Remaining gas is consumed
    0 => GAS
    ; if main context, halt execution
    $ => B          :MLOAD(originCTX)       ;last ctx
    B - 1           :JMPC(opINVALIDend)
    ; Decrease context and continue execution
    B => CTX
    ; Set values from source context, no need to refund GAS because is 0
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
                    :JMP(readCode)
opINVALIDend:
    ; TODO: should revert to initSR
                    :JMP(endCode)

invalidStaticTx:
    $ => CTX        :MLOAD(originCTX)       ;last ctx
    $ => A          :MLOAD(gasCTX)
    A => GAS
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    1               :MSTORE(SP++)
                    :JMP(readCode)
