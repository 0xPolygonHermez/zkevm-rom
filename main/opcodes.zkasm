INCLUDE "utils.zkasm"

opSTOP:
    $ => B          :MLOAD(originCTX)
    B - 1           :JMPN(handleGas)
    $ => A          :MLOAD(gasRefund)
    $ => C          :MLOAD(isCreate)
    1 => D
    C - 1           :JMPN(opSTOPend)
    $ => D          :MLOAD(createContractAddress)

opSTOPend:
    B => CTX
    CTX             :MSTORE(currentCTX)
    0               :MSTORE(retDataCTX)
    $ => B          :MLOAD(gasCTX)
    A               :MSTORE(gasRefund)
    GAS + B => GAS
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    $ => A          :MLOAD(depth)
    A - 1           :MSTORE(depth)
    ${commit()}
                    :JMP(readCode)

opADD:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)

    ; Add operation with Arith
    $ => E          :ADD

    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opMUL:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    ; Mul operation with Arith
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => E          :MLOAD(arithRes1)
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSUB:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    $ => E          :SUB
    E               :MSTORE(SP++)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDIV:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSDIV:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 8 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
                    :CALL(abs)
    A => E
    B => C
    $ => A          :MLOAD(SP)
                    :CALL(abs)
    A               :MSTORE(tmpVarA)
    C => A
    $ => A          :XOR
    1 => B
    $ => B          :XOR
    $ => A          :MLOAD(tmpVarA)
    B - 1           :JMPN(opSDIVNeg) ;0 negative, 1 positive
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSDIVNeg:

    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)

    0 => A
    $ => A          :SUB
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    ; Mod operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 8 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
                    :CALL(abs)
    A => E
    B => C
    $ => A          :MLOAD(SP)
                    :CALL(abs)
    A               :MSTORE(tmpVarA)
    C => A
    1 => B
    $ => B          :XOR
    $ => A          :MLOAD(tmpVarA)
    B - 1           :JMPN(opSMODNeg)  ; 0 negative, 1 positive
    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes2)
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSMODNeg:

    ; Div operation with Arith
    E               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes2)
    0 => A
    $ => A          :SUB
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opADDMOD:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 80 :JMPN(outOfCountersStep)

    GAS-8 => GAS    :JMPN(outOfGas)

    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP--)
    ; Add operation with Arith
    ${var _addMod = A + B} ; TODO $$

    1 => D
    $ => A          :ADD, JMPC(AddModJumpCarry) ; or arith
    0 => D 
       
AddModJumpCarry:
    A => E          ; Store sumResult on E

    $ => A          :MLOAD(SP) ; load modulus
    2 => B 
    $               :LT, JMPC(zeroOneMod)

    ${_addMod / A} => B        ; k: Max should be (2^256 -1) * 2 / 2 --> smaller than 2^256
    ${_addMod % A} => C        ; addModResult

    ; k * N + addModResult = D*2^256 + sumResult
    ; B * A + C = D*2^256 + E

    ; Check addModResult is less than modulus
    E               :ARITH

    A => B          ; modulus
    C => A          ; addModResult
    $ => A          :LT
    1               :ASSERT
    C               :MSTORE(SP++)
                    :JMP(readCode)

opMULMOD:
    %MAX_CNT_ARITH - CNT_ARITH - 3 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 150 :JMPN(outOfCountersStep)

    GAS-8 => GAS    :JMPN(outOfGas)
    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP

    ; The following approach will be followed in order to verify the mulmod operation
    ; A * B + 0 = D*2^256 + E 
    ; K * N + mulModResult = D*2^256 + E

    ; Since the k can be bigger than 2²⁵⁶ and therefore does not fit in a register we divedit in the
    ; most significan and less significant part:

    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E 
    ; And divide this operation in 2 which fits in 2²⁵⁶ digits
    
    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E 
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2 
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP--)

    ; Mul operation with Arith
    ${var _mulMod = A * B} ; TODO $$
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
    ; here we perform the: A * B + 0 = D*2^256 + E
    ; result is stored in: arithRes1(E) and arithOverflow(D)
                    :CALL(mulARITH)
                    
    $ => A          :MLOAD(SP) ; Modulus N
    ; Check if modulus is 0 or 1
    2 => B 
    $               :LT, JMPC(zeroOneMod)
    
    ; Now we will try to perform the following equation:
    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E 
    A => C ; modulus on C
    ${(_mulMod / C) >> 256} => B     ; k.h
    ; We can jump with Js, because later it's all verified by the ARITH
    ${cond(B == 0)}  :JMPN(mulModNoKH) 

    ; Since there's k.h we will split the equation in those 2
    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E 
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2 

    ; k.h  * N  = D2 
    ; B * A + 0 = 0 * 2²⁵⁶ + E
    ; D2 must be less than 2²⁵⁶
    C => A ; Modulus
    0 => C, D
    ${B * A} => E   :MSTORE(tmpVarD), ARITH ; D2

    ; k.l * N + mulModResult = D1 * 2²⁵⁶ + E 
    ; B * A + C = D*2^256 + E
    ; remember that:
    ; result of mul is stored in: arithRes1(E) and arithOverflow(D)

    ${(_mulMod / A) % (2 << 256)} => B   ; k.l
    ${_mulMod % A} => C        ; mulModResult
    ${(B * A + C) >> 256} => D ; D1
    $               :MLOAD(arithRes1), ARITH

    ; Finally we need to assert the following:
    ; N>resultModulus
    ; D1 + D2 = D
    
    ; N>resultModulus   ; LT; ASSERT
    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT

    ; Assert D1 + D2 = D ; ADD ;ASSERT
    D => A ; D1
    $ => B          :MLOAD(tmpVarD) ;D2
    $ => A          :ADD
    $               :MLOAD(arithOverflow), ASSERT

    C               :MSTORE(SP++)
                    :JMP(readCode)

mulModNoKH:
    ; if theres no K.h the equation is simplified as:
    ; K * N + mulModResult = D*2^256 + E 
    ; B * A + C = D*2^256 + E

    C => A ; Modulus on A
    ${(_mulMod / A)} => B   ; k
    ${_mulMod % A} => C     ; mulModResult
    $ => D         :MLOAD(arithOverflow)
    $              :MLOAD(arithRes1), ARITH ; Can this be on the same line of MLOAD?

    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT
    C               :MSTORE(SP++)
                    :JMP(readCode)
zeroOneMod:
    0               :MSTORE(SP++)
                    :JMP(readCode)

opEXP: ; //TODO: test exp == 0

    %MAX_CNT_ARITH - CNT_ARITH - 512 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 1025 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2              :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A              :MLOAD(SP--)
    $ => B              :MLOAD(SP)
    ${exp(A,B)} => A
    A                   :MSTORE(SP++)
    1024 - SP           :JMPN(stackOverflow)
                        :CALL(getLenBytes)
    GAS-10-50*A => GAS  :JMPN(outOfGas)
                        :JMP(readCode)

opSIGNEXTEND: ; following this impl https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/vm/src/evm/opcodes/functions.ts#L193

    %MAX_CNT_ARITH - CNT_ARITH - 6 :JMPN(outOfCountersArith)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--) ; sign byte --> sign bit = 8 * A + 7
    $ => D          :MLOAD(SP)   ; number to convert
    30 => A
    $               :LT, JMPC(opSIGNEXTENDEnd); if signByte is 31 or more, means basically let the number as it is
    ; TODO we could divide this opcode in a table with constants, only 31 cases 
    B * 8  + 7 => B ; B is less than 31, no need for binary
    ${exp(2, B)} => A  ; signBit TODO table for shifting + multipliyng

    ;Store mask
    1 => B
    $ => C          :SUB ; mask

    D => B               ; number to convert
    $ => B          :AND ; check sign bit
    0 => A
    $               :EQ, JMPC(opSIGNEXTENDPositive) ; If 0 means the sign bit was 0 --> positive
    C => A ; mask
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn => B
    $ => B          :XOR ; not mask
    D => A
    $ => D          :OR
                    :JMP(opSIGNEXTENDEnd)

opSIGNEXTENDPositive:
    C => B
    D => A
    $ => D          :AND

opSIGNEXTENDEnd:
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSLT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :SLT,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opLT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :LT,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opSGT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :SLT,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opGT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :LT,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opEQ:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :EQ,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opISZERO:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    0 => B
    $               :EQ,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opAND:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :AND,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opOR:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :OR,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opXOR:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    $               :XOR,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opNOT:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn => B
    $ => A          :XOR,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opBYTE:

    %MAX_CNT_ARITH - CNT_ARITH - 2 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
    GAS-3 => GAS    :JMPN(outOfGas)
    31 - B => D     :JMPN(opBYTE0)
                    :CALL(SHRarith)
    255 => B
    $               :AND,MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opBYTE0:
    0               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)
opSHR:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
                    :CALL(SHRarithBit)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSHL:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)
    $ => A          :MLOAD(SP)
                    :CALL(SHLarithBit)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; TODO: Adapt to multiplication
; https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/evm/src/opcodes/functions.ts#L336
opSAR:

    %MAX_CNT_ARITH - CNT_ARITH - 2 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 10 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)
    ${D/8} => B
    32 => A
    $ => A          :LT
    1 => B
    $ => B          :XOR
    ${A * 256 + B * D} => D
    $ => A          :MLOAD(SP)
                    :CALL(abs)
                    ; if more than 32 set to 32
                    :CALL(SHRarithBit)
    A => C
    B => A
    1 => B
    $ => B          :XOR
    B - 1           :JMPN(opSARNeg)  ; 0 negative, 1 positive
    C               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSARNeg:
    C => A
    1 => B
    $ => B          :LT
    ${A + B} => B                   ; TODO: This is UNSAFE
    0 => A
    $ => A          :SUB
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSHA3:

    %MAX_CNT_ARITH - CNT_ARITH - 192 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 193 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCountersMemalign)
    $ => A           :MLOAD(cntKeccakPreProcess)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - A - 2 :JMPN(outOfCountersKeccak)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 10 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ; offset
    $ => C          :MLOAD(SP) ; length
    E               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)
    ; gas
    GAS - 30 => GAS :JMPN(outOfGas); gas static = 30
                    :CALL(saveMem)
    ; Div operation with Arith
    ;${6*((C+31)/32)}
    C+31 => A
    ;(C+31)/32
    A               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes1)
    ; Mul operation with Arith
    ; 6*((C+31)/32)
    6               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => A          :MLOAD(arithRes1)
    GAS - A => GAS  :JMPN(outOfGas)  ; dynamic_gas = dynamic_gas = 6 * minimum_word_size + memory_expansion_cost
    ; new hash id
    $ => B           :MLOAD(lastHashKIdUsed)
    B + 1 => B       :MSTORE(lastHashKIdUsed)
    32 => D
    ; A new hash with position 0 is started
    0 => HASHPOS

opSHA3Loop:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)

    C - 1           :JMPN(opSHA3End)
    C - 32          :JMPN(opSHA3Final)
                    :CALL(MLOAD32)
    E => B
    $ => E          :MLOAD(lastHashKIdUsed)
    A               :HASHK(E)
    B => E
    C - 32 => C
                    :JMP(opSHA3Loop)
opSHA3Final:
                    :CALL(MLOADX)
    32 - C => D
                    :CALL(SHRarith)
    $ => E          :MLOAD(lastHashKIdUsed)
    C => D
    A               :HASHK(E)

opSHA3End:
    $ => E          :MLOAD(lastHashKIdUsed)
    HASHPOS         :HASHKLEN(E)
    
    ; Check keccak counters
    HASHPOS         :MSTORE(arithA)
    136             :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    $ => A          :MLOAD(cntKeccakPreProcess)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - A => A
    $               :LT, JMPC(outOfCountersKeccak)
    
    $ => A          :HASHKDIGEST(E)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opADDRESS:
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(opADDRESSdeploy)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opADDRESSend)

opADDRESSdeploy:
    $ => A          :MLOAD(createContractAddress)

opADDRESSend:
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opBALANCE:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 252 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    0 => B,C        ; balance smt key
    $ => D          :SLOAD
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    ${isWarmedAddress(A)} => D
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opORIGIN:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(txSrcOriginAddr)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCALLER:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(txSrcAddr)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCALLVALUE:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(txValue)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; // TODO: Check when a contract is deployed with CREATE
opCALLDATALOAD:

    %MAX_CNT_ARITH - CNT_ARITH - 64 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 66 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => E          :MLOAD(SP)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => B          :MLOAD(arithRes1)
    $ => A          :MLOAD(arithRes2)

    0 - A           :JMPN(opCALLDATALOAD2)
    SP => C
    1024 + B => SP
    $ => B          :MLOAD(SP)
    C => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCALLDATALOAD2:
    SP => C
    A => D
    1024 + B => SP
    $ => A          :MLOAD(SP++)
                    :CALL(SHLarith)
    A => B
    32 - D => D
    $ => A          :MLOAD(SP)
                    :CALL(SHRarith)
    C => SP
    B + A           :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)

opCALLDATASIZE:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(opCALLDATASIZEdep)
    $ => B          :MLOAD(txCalldataLen)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCALLDATASIZEdep: 
    0               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)


; // TODO: if ins deployment only write 0
opCALLDATACOPY:

    %MAX_CNT_ARITH - CNT_ARITH - 192 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 192 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;destOffset - offset memory
    $ => B          :MLOAD(SP--) ;offset calldata
    $ => C          :MLOAD(SP)   ;length calldata
    E               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)
    GAS - 3 => GAS  :JMPN(outOfGas)
    GAS - ${3*((C+31)/32)} => GAS    :JMPN(outOfGas) ; Arith
                    :CALL(saveMem)
    SP              :MSTORE(SPw)
    $ => A          :MLOAD(txCalldataLen)
    $               :LT,JMPC(opCALLDATACOPY0)
    A + C => A
    $               :LT,JMPC(opCALLDATACOPYX0)
                    :JMP(opCALLDATACOPYinit)

opCALLDATACOPYX0:
    $ => C          :MLOAD(txCalldataLen)

opCALLDATACOPYinit:

    %MAX_CNT_ARITH - CNT_ARITH - 192 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 192 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_STEPS - STEP - 400 :JMPN(outOfCountersStep)

    C - 1           :JMPN(opCALLDATACOPYcheckLen)
    C - 32          :JMPN(opCALLDATACOPYfinal)
    B               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => D          :MLOAD(arithRes2)
    $ => A          :MLOAD(arithRes1)
    A               :MSTORE(arithA)
    1024            :MSTORE(arithB)
                    :CALL(addARITH)
    $ => A          :MLOAD(arithRes1)
    A => SP
    $ => A          :MLOAD(SP)
                    :CALL(SHLarith)
    A => C
    $ => A          :MLOAD(arithRes1)
    A + 1 => SP
    32 - D => D
    $ => A          :MLOAD(SP)
                    :CALL(SHRarith)
    A + C           :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    $ => SP         :MLOAD(SPw)
    $ => C          :MLOAD(SP)   ;length
    C - 32 => C
    C               :MSTORE(SP) 
    B + 32 => B
                    :JMP(opCALLDATACOPYinit)

opCALLDATACOPYfinal:
    B               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => D          :MLOAD(arithRes2)
    $ => B          :MLOAD(arithRes1)
    1024            :MSTORE(arithA)
    B               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => B          :MLOAD(arithRes1)
    B => SP
    $ => A          :MLOAD(SP)
                    :CALL(SHLarith)
    $ => SP         :MLOAD(SPw)
    $ => C          :MLOAD(SP)   ;length
    B + 1 => SP
    C - 32 + D => D
    D               :JMPN(opCALLDATACOPYxor)
    A => B
    $ => A          :MLOAD(SP)
    32 - D => D
                    :CALL(SHRarith)
    32 - C => D
                    :CALL(SHLarith)
    B + A => A
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
                    :JMP(opCALLDATACOPYcheckLen)

opCALLDATACOPY0:
    32 - C          :JMPN(opCALLDATACOPY320)
    0               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
                    :JMP(opCALLDATACOPYend)

opCALLDATACOPY320:
    0               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    C - 32 => C
                    :JMP(opCALLDATACOPY0)

opCALLDATACOPYxor:
    32 - C => D
                    ;SHR/SHL could be optimized
                    :CALL(SHRarith)
                    :CALL(SHLarith)
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)

opCALLDATACOPYcheckLen:
    $ => C          :MLOAD(lastMemLength)
    $ => A          :MLOAD(txCalldataLen)
    C - A => C      :JMPN(opCALLDATACOPYend)
                    :JMP(opCALLDATACOPY0)


opCALLDATACOPYend:
    $ => SP         :MLOAD(SPw)
                    :JMP(readCode)

opCODESIZE:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 252 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(opCODESIZEdep)
    $ => A          :MLOAD(txDestAddr)
    %SMT_KEY_SC_LENGTH => B
    0 => C
    $ => A          :SLOAD
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCODESIZEdep: ;//TODO: create/create2, constructor parameters, initBytcode vs deployed Bytecode
    $ => B          :MLOAD(txCalldataLen)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

VAR GLOBAL memOffset
VAR GLOBAL remainingBytes
VAR GLOBAL previousValue
VAR GLOBAL codecopyHashId
VAR GLOBAL codecopyBytecodeLength
VAR GLOBAL memInteger
opCODECOPY:

    SP - 3          :JMPN(stackUnderflow)
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(opCALLDATACOPY) ; //TODO: delegateCall ? use of storageAddr? same in process_tx ?
    SP - 1 => SP
    $ => C          :MLOAD(SP--) ;destOffset, memory offset
    $ => D          :MLOAD(SP--) ;offset, bytecode offset
    $ => E          :MLOAD(SP)   ;bytes to copy
    C               :MSTORE(lastMemOffset)
    E               :MSTORE(lastMemLength)

    ;Check counters
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    GAS - 3 => GAS  :JMPN(outOfGas)
    GAS - ${3*((E+31)/32)} => GAS    :JMPN(outOfGas)
                    :CALL(saveMem)
    ; check memory limits
    0x200000 => A
    C + E => B
    $               :LT,JMPC(errorMLOADMSTORE)
    ; Check if offset is above data len
    D => A
    $ => B          :MLOAD(bytecodeLength)
    $               :LT, JMPC(opCODECOPY2)
    B => A
opCODECOPY2:
    ; init vars for copy the code
    A => HASHPOS
    $ => D          :MLOAD(contractHashId)
    D               :MSTORE(codecopyHashId) ; set hashId to get bytes from
    B               :MSTORE(codecopyBytecodeLength) ; set contract bytecode length
    C               :MSTORE(memOffset)
    E               :MSTORE(remainingBytes)

opCODECOPYinit:
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 200                :JMPN(outOfCountersStep)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 2    :JMPN(outOfCountersMemalign)

    $ => B          :MLOAD(remainingBytes)
    B - 1           :JMPN(readCode)
    $ => A          :MLOAD(memOffset)
                    :CALL(offsetUtil) ; E (integer) / C (remaining)
    E               :MSTORE(memInteger)
    $ => A          :MLOAD(MEM:E) ; read M0 previous value
    A               :MSTORE(previousValue)
                    :CALL(opCODECOPYLoadBytes)
    $ => A          :MLOAD(previousValue)
    ${memAlignWR8_W0(A,B,C)} => D  ; no trust calculate W0
    B               :MEM_ALIGN_WR8 ; only use LSB of B, rest of bytes could be non zero
    $ => E          :MLOAD(memInteger)
    D               :MSTORE(MEM:E) ; write W0
    ; update vars loop
    $ => B          :MLOAD(remainingBytes)
    B - 1 => B  ; decrease 1 byte from length
    B               :MSTORE(remainingBytes)
    $ => A          :MLOAD(memOffset)
    A + 1 => A  ; increment offset to write the next byte
    A               :MSTORE(memOffset)
                    :JMP(opCODECOPYinit)


; @info Load 0 if read bytecode position is above bytecode length
opCODECOPYLoadBytes:
    0 => A
    $ => B          :MLOAD(codecopyBytecodeLength)
    $               :EQ, JMPC(readZero)
    HASHPOS => A
    $               :LT, JMPC(readValueBytecode)
readZero:
    0 => B
                    :RETURN
readValueBytecode:
    1 => D
    $ => E          :MLOAD(codecopyHashId)
    $ => B          :HASHP(E)   ; read value to write in memory
                    :RETURN


opGASPRICE:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(txGasPrice)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opEXTCODESIZE:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    ${isWarmedAddress(A)} => D
    %SMT_KEY_SC_LENGTH => B
    0 => C
    $ => A          :SLOAD
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; read hash smt
; put 32 by 32 bytes in the hashP
; assert bytes with hash smt

; read byte from hashP and copy into memory
; over length => set 0's
VAR GLOBAL tmpContractHashId
VAR GLOBAL tmpContractLength
opEXTCODECOPY:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_PADDING_PG - CNT_PADDING_PG - 11 :JMPN(outOfCountersPadding)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 4          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--) ;addr
                    :CALL(maskAddress) ; Mask address to 20 bytes
    ${isWarmedAddress(A)} => D
    GAS-100-D*2500 => GAS            :JMPN(outOfGas)
                    :CALL(opEXTCODECOPYCheckHash)
    $ => C          :MLOAD(SP--) ;destOffset, memory offset
    $ => D          :MLOAD(SP--) ;offset to read from bytecode
    $ => E          :MLOAD(SP)   ;bytes to read from bytecode
    C               :MSTORE(lastMemOffset)
    E               :MSTORE(lastMemLength)

    ;Check counters should be before than do all the operations! TODO
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200                :JMPN(outOfCountersStep)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 2    :JMPN(outOfCountersMemalign)


    GAS - ${3*((E+31)/32)} => GAS    :JMPN(outOfGas)
                    :CALL(saveMem)
    ; check memory limits
    0x200000 => A
    C + E => B
    $               :LT,JMPC(errorMLOADMSTORE)

    ; Check if offset is above data len
    D => A
    $ => B          :MLOAD(tmpContractLength)
    $               :LT, JMPC(opEXTCODECOPY2)
    B => A

opEXTCODECOPY2:
    ; init vars for copy the code
    A => HASHPOS
    $ => D          :MLOAD(tmpContractHashId)
    D               :MSTORE(codecopyHashId) ; set hashId to get bytes from
    B               :MSTORE(codecopyBytecodeLength) ; set contract bytecode length
    C               :MSTORE(memOffset)
    E               :MSTORE(remainingBytes)
                    :JMP(opCODECOPYinit)

opEXTCODECOPYCheckHash:
    ; get contract length
    %SMT_KEY_SC_LENGTH => B
    0 => C
    $ => D                          :SLOAD
    D                               :MSTORE(tmpContractLength)
    ; If len is 0 nothing to check
    A => E
    0 => A
    D => B
    $                               :EQ, JMPC(opEXTCODECOPYCheckHashEnd)
    E => A
    ; get hash contract
    %SMT_KEY_SC_CODE => B
    0 => C
    $ => A          :SLOAD
    ; get a new hashPId
    $ => E                          :MLOAD(nextHashPId)
    E                               :MSTORE(tmpContractHashId)
    E + 1                           :MSTORE(nextHashPId)

    ; set vars prior to loop
    D => B
    0 => HASHPOS
                                    :JMP(opEXTCODECOPYCheckHashLoop)

; @info bytes are inserted byte by byte
; TODO: it could be improved by computing how many 32 bytes slots are needed
opEXTCODECOPYCheckHashLoop:

        %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)

        B - 1                                   :JMPN(opEXTCODECOPYCheckHashLoopEnd) ; finish reading bytecode
        1 => D
        ${getBytecode(A, HASHPOS, 1)}           :HASHP(E)                   ; add bytes to hash contract bytecode
        B - 1 => B
                                                :JMP(opEXTCODECOPYCheckHashLoop)

opEXTCODECOPYCheckHashLoopEnd:
        HASHPOS                         :HASHPLEN(E)
        $ => E                          :HASHPDIGEST(E)
        ; check hash computed matches hash in the smt leaf
        E                               :ASSERT
opEXTCODECOPYCheckHashEnd:
                                        :RETURN

opEXTCODECOPYinit:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    C - 1           :JMPN(readCode)
    C - 32          :JMPN(opEXTCODECOPYfinal)
    ${getBytecode(A,B,32)} => D
    D               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    C - 32 => C
    B + 32 => B
                    :JMP(opEXTCODECOPYinit)

opEXTCODECOPYfinal:
    ${getBytecode(A,B,C)} => A
    32 - C  => D
                    :CALL(SHLarith)
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
                    :JMP(readCode)

opRETURNDATASIZE:

    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    ; Load ret data length from last ctx
    ; If no retDataCTX(0), retDataLength = 0
    GAS - 2 => GAS  :JMPN(outOfGas)
    $ => B          :MLOAD(retDataCTX)
    0 => A
    $               :EQ, JMPC(endOpRETURNDATASIZE)
    B => CTX
    $ => A          :MLOAD(retDataLength)
    ; Restore current context
    $ => CTX        :MLOAD(currentCTX)

endOpRETURNDATASIZE:
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opRETURNDATACOPY:
    SP - 3          :JMPN(stackUnderflow)
    GAS - 3 => GAS  :JMPN(outOfGas)
    SP - 1 => SP
    $ => D          :MLOAD(SP--)            ;destOffset
    $ => E          :MLOAD(SP--)            ;offset - offset in return data
    $ => C          :MLOAD(SP)              ;length - length return data
    D               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 32            :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600                :JMPN(outOfCountersStep)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 2    :JMPN(outOfCountersMemalign)

                    :CALL(saveMem)
    ; if retDataCTX is 0, end opcode execution
    $ => B          :MLOAD(retDataCTX)
    0 => A
    $               :EQ, JMPC(opRETURNDATACOPYEmpty)
    ; Load ret data length from last ctx
    B => CTX
    E => B
    $ => A          :MLOAD(retDataLength)
    $ => E          :MLOAD(retDataOffset)
    $ => CTX        :MLOAD(currentCTX)

    E + B => E ; E ret data offset (memory pointer) of last context, B offset in return data  that want to retrive


    ; if retDataSize <= retdataOffset + dataLen -> OOG
    ;A retDataSize
    B + C => B ; total offset (retdataOffset + dataLen)
    $               :LT, JMPC(outOfGas)

    E => B ; memory pointer where start to copy memory

    ;${3*((C+31)/32)}
    C+31 => A
    ;(C+31)/32
    A               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => A          :MLOAD(arithRes1)
    ; Mul operation with Arith
    ; 3*((C+31)/32)
    3               :MSTORE(arithA)
    A               :MSTORE(arithB)
                    :CALL(mulARITH)
    $ => A          :MLOAD(arithRes1)
    GAS - A => GAS  :JMPN(outOfGas)

opRETURNDATACOPYinit:
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    C - 1           :JMPN(readCode)
    C - 32          :JMPN(opRETURNDATACOPYfinal)
    B => E
    ; Load memory from last context used
    $ => CTX        :MLOAD(retDataCTX)
                    :CALL(MLOAD32)
    ; Save memory to the current context
    $ => CTX        :MLOAD(currentCTX)
    E => B
    D => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => D
    C - 32 => C
                    :JMP(opRETURNDATACOPYinit)

opRETURNDATACOPYfinal:
    B => E
    ; Load memory from last context used
    $ => CTX        :MLOAD(retDataCTX)
                    :CALL(MLOADX)
    ; Save memory to the current context
    $ => CTX        :MLOAD(currentCTX)
    E => B ; offset retDataCTX
    D => E ; offset current CTX
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
                    :JMP(readCode)

opRETURNDATACOPYEmpty:
    E + C => B ; offset return data + len return data must be 0
    $               :EQ, JMPC(readCode)
                    :JMP(outOfGas)

opEXTCODEHASH:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    ${isWarmedAddress(A)} => D
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
    %SMT_KEY_SC_CODE => B
    0 => C
    $ => A          :SLOAD
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

; @info opEXTCODEHASHL2 returns the keccak of the bytecode
; opEXTCODEHASH returns the hash bytecode stored in the smt (poseidon linear hash)
;opEXTCODEHASHL2:
;    SP - 1 => SP    :JMPN(stackUnderflow)
;    $ => A          :MLOAD(SP)
;    ${isWarmedAddress(A)} => D
;    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
;    %SMT_KEY_SC_CODE => B
;    0 => C
;    $ => A          :SLOAD
;    $${p = 0}
;    ${getBytecodeLength(A)} => C
;    $ => E           :MLOAD(lastHashKIdUsed)
;    E+1 => E         :MSTORE(lastHashKIdUsed)
;    ; A new hash with position 0 is started
;    0 => HASHPOS
;
;opEXTCODEHASHinit:
;    32 => D
;    C - 1           :JMPN(opEXTCODEHASHend)
;    C - 32          :JMPN(opEXTCODEHASHfinal)
;    ${getBytecode(A,p,D)} => B
;    B               :HASHK(E)
;    C - D => C
;    $${p = p + D}
;                    :JMP(opEXTCODEHASHinit)
;
;opEXTCODEHASHfinal:
;    C => D
;    ${getBytecode(A,p,C)} => B
;    B               :HASHK(E)
;
;opEXTCODEHASHend:
;    HASHPOS         :HASHKLEN(E)
;    $ => A          :HASHKDIGEST(E)
;    A               :MSTORE(SP++)
;    1024 - SP       :JMPN(stackOverflow)
;                    :JMP(readCode)

opBLOCKHASH:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    $ => A                                     :MLOAD(cntKeccakPreProcess)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - A - 2   :JMPN(outOfCountersKeccak)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 1 => SP     :JMPN(stackUnderflow)
    GAS - 20 => GAS  :JMPN(outOfGas)

    ; Check batch number is lt current batch number, else return 0
    ; Get last tx count
    %LAST_TX_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => B          :SLOAD
    $ => A          :MLOAD(SP) ; batch number
    B - A - 1       :JMPN(opBLOCKHASHzero)

    ; Create key for the batch hash mapping key
    32 => D
    0 => HASHPOS ; A new hash with position 0 is started
    $ => E                              :MLOAD(lastHashKIdUsed)
    E+1 => E                            :MSTORE(lastHashKIdUsed)
    A                                   :HASHK(E)
    %STATE_ROOT_STORAGE_POS             :HASHK(E)
    HASHPOS                             :HASHKLEN(E)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - %MIN_CNT_KECCAK_BATCH - 2:JMPN(outOfCountersKeccak)
    $ => C                              :HASHKDIGEST(E)
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => E                              :SLOAD
    ; Store result value in the stack
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

; Handle when is asking for the hash of a not computed batch, return 0
opBLOCKHASHzero:
    0               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opCOINBASE:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(sequencerAddr)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)


opTIMESTAMP:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(timestamp)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opNUMBER:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    ; Get current tx count
    $ => D          :MLOAD(txCount)
    D + 1           :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS - 2 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)

opDIFFICULTY:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    %BATCH_DIFFICULTY => A
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opGASLIMIT:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    %BATCH_GAS_LIMIT => A
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opCHAINID:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(chainId)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSELFBALANCE:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    $ => A          :MLOAD(storageAddr)
    0 => B,C        ; balance key smt
    $ => D          :SLOAD
    D               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-5 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)
opBASEFEE:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    0               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opPOP:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    GAS-2 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opMLOAD:

    %MAX_CNT_ARITH - CNT_ARITH - 32 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => E          :MLOAD(SP)                  ;offset
    E               :MSTORE(lastMemOffset)
                    :CALL(MLOAD32)
    32              :MSTORE(lastMemLength)
                    :CALL(saveMem)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)

;MSTORE 32 bytes
opMSTORE:

    %MAX_CNT_ARITH - CNT_ARITH - 32 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--)                ;offset
    $ => B          :MLOAD(SP)                  ;value
    B               :MSTORE(bytesToStore)
    E               :MSTORE(lastMemOffset)
    E => A
                    :CALL(MSTORE32)
    32              :MSTORE(lastMemLength)
                    :CALL(saveMem)
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)


opMSTORE8:

    %MAX_CNT_BINARY - CNT_BINARY - 32 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN  - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => B          :MLOAD(SP--)                ;offset
    B               :MSTORE(lastMemOffset)
    1               :MSTORE(lastMemLength)
    0x200000 => A
    $               :LT,JMPC(errorMLOADMSTORE)
    B => A
                    :CALL(offsetUtil)
    $ => B          :MLOAD(SP)                  ;value
    $ => A          :MLOAD(MEM:E) ; read M0
    ${memAlignWR8_W0(A,B,C)} => D  ; no trust calculate W0
    B               :MEM_ALIGN_WR8 ; only use LSB of B, rest of bytes could be non zero.
    D               :MSTORE(MEM:E)     ; write W0
    GAS - 3 => GAS  :JMPN(outOfGas)
                    :CALL(saveMem)
                    :JMP(readCode)

opSLOAD:

    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => C          :MLOAD(SP) ;key
    $ => A          :MLOAD(storageAddr)
    %SMT_KEY_SC_STORAGE => B
    $ => E          :SLOAD ;current value
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    ${isWarmedStorage(A,C)} => A
    GAS - %SLOAD_GAS - A*2000 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSSTORE:
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 765 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_BINARY - CNT_BINARY - 10 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1 :JMPN(outOfCountersMemalign)
    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    ; If GAS <= 2300 --> OOG
    GAS - 2300 - 1  :JMPN(outOfGas)
    $ => A          :MLOAD(isStaticCall)
    0 - A           :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => C          :MLOAD(SP--) ;key
    C               :MSTORE(tmpVarC)
    $ => D          :MLOAD(SP) ; new value
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(deploymentSSTORE)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opSSTOREinit)

deploymentSSTORE:
    $ => A          :MLOAD(createContractAddress)

opSSTOREinit:
    %SMT_KEY_SC_STORAGE => B
    $ => E          :SLOAD ;current value
    SR              :MSTORE(auxSR)
    $ => SR         :MLOAD(originSR)
    $ => B          :SLOAD ;origin value
    $ => SR         :MLOAD(auxSR)
    ${isWarmedStorage(A,C)} => A
    B => C           ;origin value
    GAS - A*2100 => GAS    :JMPN(outOfGas)
    E => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdif)
    ;if new_val == current_val
    GAS - 100 => GAS:JMPN(outOfGas)
                    :JMP(opSSTOREend)

opSSTOREdif:
    ;if new_val != current_val
    C => A
    E => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA)
    ;if current_val == orig_val
    0 => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifB)
    ;if origin_val == 0
    GAS - %SSTORE_SET_GAS => GAS    :JMPN(outOfGas)
                    :JMP(opSSTOREend)

opSSTOREdifA:
    ;if current_val != orig_val
    GAS - 100 => GAS:JMPN(outOfGas)
    0 => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA1)
    ;if origin_value == 0

opSSTOREdifAB:
    ;if origin_value == 0
    D => A
    C => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREend)
    ;if new_val == orig_val
    0 => A
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA2)
    ;if orig_val == 0
    $ => A          :MLOAD(gasRefund)
    A + 19900 => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREdifA1:
    ;if orig_val != 0
    0 => A
    E => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifA12)
    ;if current_val == 0
    $ => A          :MLOAD(gasRefund)
    A - %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREdifAB)
opSSTOREdifA12:
    ;if current_val != 0
    0 => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREdifAB)
    ;if new_val == 0
    $ => A          :MLOAD(gasRefund)
    A + %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREdifAB)

opSSTOREdifA2:
    ;if orig_val != 0
    $ => A          :MLOAD(gasRefund)
    A + 2800 => A   :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREdifB:
    ;if orig_val != 0
    GAS - %SSTORE_RESET_GAS => GAS    :JMPN(outOfGas)
    0 => A
    D => B
    $ => A          :EQ
    A - 1           :JMPN(opSSTOREend)
    ;if new_val == 0
    $ => A          :MLOAD(gasRefund)
    A + %SSTORE_CLEARS_SCHEDULE => A  :MSTORE(gasRefund)
                    :JMP(opSSTOREend)

opSSTOREend:
    $ => A          :MLOAD(isCreateContract)
    0 - A           :JMPN(mloadContract)
    $ => A          :MLOAD(storageAddr)
                    :JMP(opSSTOREsr)

mloadContract:
    $ => A          :MLOAD(createContractAddress)

opSSTOREsr:
    %SMT_KEY_SC_STORAGE => B
    $ => C          :MLOAD(tmpVarC)
    $ => SR         :SSTORE
                    :JMP(readCode)

opJUMP:

    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 1 => SP                    :JMPN(stackUnderflow)
    $ => PC                         :MLOAD(SP)
    GAS - 8 => GAS                  :JMPN(outOfGas)
    ; Check PC is a JUMPDEST
    :JMP(checkJumpDest)

opJUMPI:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 2 => SP                    :JMPN(stackUnderflow)
    $ => B                          :MLOAD(SP)
    GAS - 10 => GAS                 :JMPN(outOfGas)
    0 => A
    $                               :EQ, JMPC(readCode)
    SP + 1 => SP
    $ => PC                         :MLOAD(SP--) ;
    PC => B
    ; Check PC is a JUMPDEST
                                    :JMP(checkJumpDest)

; TODO check do not overflow
checkJumpDest:
    ; If it is a deploy we have to check the data from the calldata (not the bytecode)
    $ => A                          :MLOAD(isCreateContract)
    -A                              :JMPN(checkJumpDestDeployment)
    PC => HASHPOS
    HASHPOS => D
    1 => D
    $ => E                          :MLOAD(contractHashId) ; hash index
    $ => A                          :HASHP(E)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)
checkJumpDestDeployment:
    1 => A
    $ => B                          :MLOAD(isCreate)
    $                               :EQ,JMPC(checkJumpDestDeploymentCreate)
    $ => HASHPOS                    :MLOAD(dataStarts)
    HASHPOS + PC => HASHPOS
    $ => E                          :MLOAD(batchHashDataId)
    1 => D
    $ => A                          :HASHK(E)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)

checkJumpDestDeploymentCreate:

    %MAX_CNT_ARITH - CNT_ARITH - 224 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 225 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCountersMemalign)

    $ => CTX                        :MLOAD(originCTX)
    $ => E                          :MLOAD(argsOffsetCall)
    E + PC => E
    1 => C
                                    :CALL(MLOADX)
    $ => CTX                        :MLOAD(currentCTX)
    31 => D
                                    :CALL(SHRarith)
    0x5B => B
    $                               :EQ, JMPC(readCode)
                                    :JMP(invalidJump)

opPC:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    GAS - 2 => GAS      :JMPN(outOfGas)
    PC - 1              :MSTORE(SP++) ; TODO: check PC
    1024 - SP           :JMPN(stackOverflow)
                        :JMP(readCode)

opMSIZE:

    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    GAS - 2 => GAS      :JMPN(outOfGas)
    $ => E              :MLOAD(memLength)
    ; MSIZE should be multiple of a word (32 bytes)
    ; Div operation with Arith
    E               :MSTORE(arithA)
    32              :MSTORE(arithB)
                    :CALL(divARITH)
    $ => C          :MLOAD(arithRes1)
    $ => B          :MLOAD(arithRes2)
    0 => A
    $               :EQ, JMPC(MSIZEend)
    ; Round size to 32bytes multiple
    C + 1 => C
    C * 32 => E

MSIZEend:
    E               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)


opGAS:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    GAS - 2 => GAS  :JMPN(outOfGas)
    GAS             :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
                    :JMP(readCode)

opJUMPDEST:
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
    GAS - 1 => GAS  :JMPN(outOfGas)
                    :JMP(readCode)

opAuxPUSHA:

    %MAX_CNT_BINARY - CNT_BINARY - 6 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    GAS-3 => GAS        :JMPN(outOfGas)
                        :CALL(readPush)
    E                   :MSTORE(SP++)
    1024 - SP           :JMPN(stackOverflow)
    PC + D => PC
                        :JMP(readCode)

opAuxPUSHB:

    %MAX_CNT_BINARY - CNT_BINARY - 6 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)

    1 => A
    $ => B                          :MLOAD(isCreate)
    $                               :EQ,JMPC(opAuxPUSHBcreate)
    D - 1 => C
    0 => A

opAuxPUSHBloop:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 4 :JMPN(outOfCountersArith)

    1 => D
    $ => HASHPOS                    :MLOAD(dataStarts)
    HASHPOS + PC => HASHPOS
    PC + 1 => PC
    $ => E                          :MLOAD(batchHashDataId)
    $ => B                          :HASHK(E)
    A + B => A
    C - 1 => C                      :JMPN(opAuxPUSHBend)
                                    :CALL(SHLarith)
                                    :JMP(opAuxPUSHBloop)

opAuxPUSHBend:
    GAS-3 => GAS                    :JMPN(outOfGas)
    A                               :MSTORE(SP++)
    1024 - SP                       :JMPN(stackOverflow)
                                    :JMP(readCode)

opAuxPUSHBcreate:

    %MAX_CNT_ARITH - CNT_ARITH - 224 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 225 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCountersMemalign)

    0 => B
    $ => CTX                        :MLOAD(originCTX)
    $ => E                          :MLOAD(argsOffsetCall)
    E + PC => E
    D => C
                                    :CALL(MLOADX)
    PC + C => PC
    32 - C => D
                                    :CALL(SHRarith)
    $ => CTX                        :MLOAD(currentCTX)
                                    :JMP(opAuxPUSHBend)


opPUSH1:
    1 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH2:
    2 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH3:
    3 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH4:
    4 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH5:
    5 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH6:
    6 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH7:
    7 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH8:
    8 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH9:
    9 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH10:
    10 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH11:
    11 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH12:
    12 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH13:
    13 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH14:
    14 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH15:
    15 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH16:
    16 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH17:
    17 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH18:
    18 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH19:
    19 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH20:
    20 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH21:
    21 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH22:
    22 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH23:
    23 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH24:
    24 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH25:
    25 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH26:
    26 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH27:
    27 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH28:
    28 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH29:
    29 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH30:
    30 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH31:
    31 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opPUSH32:
    32 => D
    $ => B                          :MLOAD(isCreateContract)
    0 - B                           :JMPN(opAuxPUSHB)
                                    :JMP(opAuxPUSHA)

opDUP1:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 1 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP++)
    1024 - SP       :JMPN(stackOverflow)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP2:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 2 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP3:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 3 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 3 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP4:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 4 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 4 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP5:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 5 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 5 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP6:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 6 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 6 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP7:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 7 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 7 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP8:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 8 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 8 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP9:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 9 => SP    :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 9 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP10:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 10 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 10 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP11:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 11 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 11 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP12:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 12 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 12 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP13:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 13 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 13 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP14:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 14 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 14 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP15:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 15 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 15 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opDUP16:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 16 => SP   :JMPN(stackUnderflow)
    $ => A          :MLOAD(SP)
    SP + 16 => SP
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP1:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP--)
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP2:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 3          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 2 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 2 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP3:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 4          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 3 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 3 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP4:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 5          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 4 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 4 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP5:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 6          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 5 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 5 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP6:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 7          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 6 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 6 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP7:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 8          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 7 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 7 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP8:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 9          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 8 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 8 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP9:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 10         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 9 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 9 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP10:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 11         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 10 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 10 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP11:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 12         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 11 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 11 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP12:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 13         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 12 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 12 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP13:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 14         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 13 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 13 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP14:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 15         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 14 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 14 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP15:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 16         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 15 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 15 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

opSWAP16:

    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)

    SP - 17         :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => A          :MLOAD(SP)
    SP - 16 => SP
    $ => B          :MLOAD(SP)
    A               :MSTORE(SP)
    SP + 16 => SP
    B               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    GAS-3 => GAS    :JMPN(outOfGas)
                    :JMP(readCode)

; gas_cost = 375 + 375 * num_topics + 8 * data_size + mem_expansion_cost
opLOG0:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 2              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    0                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG1:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 3              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    1                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG2:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 4              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    2                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG3:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 5              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    3                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOG4:

    %MAX_CNT_STEPS - STEP - 200 :JMPN(outOfCountersStep)

    SP - 6              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => E              :MLOAD(SP--) ; offset
    $ => C              :MLOAD(SP)   ; length
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    4                   :MSTORE(numTopics)
    GAS - 375 => GAS    :JMPN(outOfGas)                 ; static gas
    GAS => A
    8                   :MSTORE(arithA)
    C                   :MSTORE(arithB)
                        :CALL(mulARITH)
    $ => B              :MLOAD(arithRes1)
    $                   :LT,JMPC(outOfGas)
    GAS - B => GAS                                  ; add gas depending on data bytes
    $ => B              :MLOAD(nextFreeLogIndex) ; load logIndex
    B + 1               :MSTORE(nextFreeLogIndex) ; store next free log index
                        :JMP(opLOGLoop)

opLOGLoop:

    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)

    C - 1           :JMPN(opSaveTopicsInit)
    C - 32          :JMPN(opLOGFinal)
                    :CALL(MLOAD32)
    ${storeLog(B, 0, A)} ; storeLog(indexLog, isTopic, bytesToStore)
    C - 32 => C
                    :JMP(opLOGLoop)

opLOGFinal:
                    :CALL(MLOADX)
    ${storeLog(B, 0, A)}

opSaveTopicsInit:
    $ => A          :MLOAD(numTopics)

opSaveTopicsLoop:

    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)

    A - 1               :JMPN(readCode)
    SP - 1 => SP        :JMPN(stackUnderflow)
    GAS - 375 => GAS    :JMPN(outOfGas)
    $ => C              :MLOAD(SP)   ; topicX
    ${storeLog(B, 1, C)}     ; storeLog(indexLog, isTopic, bytesToStore)
    A - 1 =>  A
                        :JMP(opSaveTopicsLoop)


; // TODO Check with DElEGATE CALL txDestAddr/txSrcAddr ( same as other calls)
; // TODO check revert create
opCREATE:
    $ => A              :MLOAD(depth)
    A + 1               :MSTORE(depth)
    SP - 3              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => D              :MLOAD(SP--)            ;value
    D                   :MSTORE(valueCall)
    $ => E              :MLOAD(SP--)            ;offset
    E                   :MSTORE(argsOffsetCall)
    $ => C              :MLOAD(SP)      ;length
    C                   :MSTORE(argsLengthCall)

    ;Check counters
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2     :JMPN(outOfCountersMemalign)
    %MAX_CNT_ARITH - CNT_ARITH - 32            :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600                :JMPN(outOfCountersStep)
    ; Substract gas cost

    ; Mem expansion gas cost
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    CTX                 :MSTORE(originAuxCTX)
    GAS - 32000 => GAS  :JMPN(outOfGas)
    GAS                 :MSTORE(gasCall)

    ; Check correctness of Create: depth, can transfer, nonce overlfow, 
    ; depth overflow

    ; can transfer
    $ => A              :MLOAD(storageAddr)
    %SMT_KEY_BALANCE => B                                             ; balance key smt
    0 => C                                                            ; 3rd parameter does not apply to nonce or balance
    $ => A              :SLOAD
    D => B              
    $                   :LT,JMPC(opCreateFail)

    ; nonce overlow
    $ => A             :MLOAD(storageAddr)
    %SMT_KEY_NONCE => B                                                  ; Constant for nonce
    $ => B              :SLOAD
    A => C
    %MAX_NONCE => A
    $                   :EQ,JMPC(opCreateFail)


    ;change to a new CTX
    SP                  :MSTORE(lastSP)
    PC                  :MSTORE(lastPC)
    $ => A              :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX          :MSTORE(lastCtxUsed)
    CTX                 :MSTORE(currentCTX)
    1                   :MSTORE(isCreateContract)
    1                   :MSTORE(isCreate)
    $ => A              :MLOAD(originAuxCTX)
    A                   :MSTORE(originCTX)

    ; get nonce & update SR
    B                   :MSTORE(txNonce)
                        :CALL(getLenBytes)
    A                   :MSTORE(lengthNonce)
    B + 1 => D
    C => A
    %SMT_KEY_NONCE => B                                                  ; Constant for nonce
    0 => C
    $ => SR             :SSTORE
    SR                  :MSTORE(initSR)

                        :CALL(computeGasSendCall)
    $ => CTX            :MLOAD(originCTX)
    $ => B              :MLOAD(storageAddr)
    $ => C              :MLOAD(gasRefund)
    GAS - A             :MSTORE(gasCTX)
    $ => CTX            :MLOAD(currentCTX)
    A => GAS
    B                   :MSTORE(txSrcAddr)
    C                   :MSTORE(gasRefund)
                        :CALL(copySP)

    $ => A              :MLOAD(argsLengthCall)
    A                   :MSTORE(txCalldataLen)
    $ => A              :MLOAD(valueCall)
    A                   :MSTORE(txValue)

                        :JMP(txType)

opCreateFail:
    0                   :MSTORE(retDataCTX)
    0                   :MSTORE(SP++)
                        :JMP(readCode)
                                   
; // https://eips.ethereum.org/EIPS/eip-211
opCALL:

    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)
    $ => A          :MLOAD(depth)
    A + 1           :MSTORE(depth)
    SP - 7          :JMPN(stackUnderflow)
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    ; Store gas call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    ; Store address call
    $ => A          :MLOAD(SP--)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    A               :MSTORE(addrCall)
    ; Store value call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(valueCall)
    ; If is static and value is not 0 -> revert
    $ => B          :MLOAD(isStaticCall)
    B - 1           :JMPN(opCALL2)

    0 => B
    $               :EQ,JMPC(opCALL2)
                    :JMP(invalidStaticTx)

opCALL2:

    ; Store bytes offset int the memory, the calldata of the subcontext
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    A               :MSTORE(lastMemOffset)

    ; Byte size to copy, size of the calldata of the subcontext
    $ => C          :MLOAD(SP--)
    C               :MSTORE(argsLengthCall)
    C               :MSTORE(lastMemLength)
    ; Mem expansion gas cost call args
                    :CALL(saveMem)

    ; Store byte offset in the memory in bytes, where to store the return data of the sub context.
    $ => B          :MLOAD(SP--)
    B               :MSTORE(lastMemOffset)

    ; Store byte size to copy (size of the return data).
    $ => D          :MLOAD(SP)
    D               :MSTORE(lastMemLength)
                    :CALL(saveMem)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 32            :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600                :JMPN(outOfCountersStep)

    $ => B                   :MLOAD(lastMemOffset)

    ; Substract gas cost

    ; If addr in touched addres D = 0, else D = 1
    $ => A          :MLOAD(addrCall)
    ${isWarmedAddress(A)} => D ; TODO
    ;gas_cost = memory_expansion_cost + code_execution_cost + address_access_cost + positive_value_cost + value_to_empty_account_cost
    ; Calculate address_access_cost: 100 for warm account, 2600 for cold account
    GAS-100-D*2500 => GAS :JMPN(outOfGas)
    ; Calculate positive_value_cost, if value call > 0 -> 9000
    $ => B          :MLOAD(valueCall)
    0 => A
    $               :EQ,JMPC(opCALLend)

    GAS - 9000 => GAS :JMPN(outOfGas)
    ; If destAddress is an empty account, we should add 25k of gas to base cost
    $ => E               :MLOAD(addrCall)
                         :CALL(isEmptyAccount)
    GAS - 25000*E => GAS :JMPN(outOfGas)

opCALLend:
    $ => B          :MLOAD(lastMemOffset)
    $ => D          :MLOAD(lastMemLength)
    $ => C          :MLOAD(storageAddr)
    $ => E          :MLOAD(gasRefund)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    C               :MSTORE(txSrcAddr)
    E               :MSTORE(gasRefund)
    SR              :MSTORE(initSR)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    A               :MSTORE(storageAddr)
    B               :MSTORE(retCallOffset)
    D               :MSTORE(retCallLength)
    $ => B          :MLOAD(valueCall)
    B               :MSTORE(txValue)
    0 => A
    $ => C          :LT
                        :CALL(computeGasSendCall)
    ; Add estipend (2300) in case of tx with value
    $ => CTX            :MLOAD(originCTX)
    GAS - A             :MSTORE(gasCTX)
    A + 2300*C => A
    $ => D              :MLOAD(isStaticCall)
    $ => CTX            :MLOAD(currentCTX)
    D                   :MSTORE(isStaticCall)
    A => GAS

    $ => A              :MLOAD(argsLengthCall)
    A                   :MSTORE(txCalldataLen)
                        :CALL(copySP)
                        :JMP(txType)

; TODO if theres a delegate call inside a callCode, who is the msg.sender?
; should be the caller of the callCode? ( but we do not store this info yet)
opCALLCODE: ; TODO check staticCall

    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)
    $ => A          :MLOAD(depth)
    A + 1           :MSTORE(depth)
    SP - 7          :JMPN(stackUnderflow)
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    ; Store gas call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    ; Store address call
    $ => A          :MLOAD(SP--)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    A               :MSTORE(addrCall)
    ; Store value call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(valueCall)

    ; Store bytes offset int the memory, the calldata of the subcontext
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    A               :MSTORE(lastMemOffset)
    ; Byte size to copy, size of the calldata of the subcontext
    $ => C          :MLOAD(SP--)
    C               :MSTORE(argsLengthCall)
    C               :MSTORE(lastMemLength)
    ; Mem expansion gas cost call args
                    :CALL(saveMem)

    ; Store byte offset in the memory in bytes, where to store the return data of the sub context.
    $ => B          :MLOAD(SP--)
    B               :MSTORE(lastMemOffset)
    ; Store byte size to copy (size of the return data).
    $ => D          :MLOAD(SP)
    D               :MSTORE(lastMemLength)
                    :CALL(saveMem)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 32            :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600                :JMPN(outOfCountersStep)

    ; Substract gas cost

    ; If addr in touched addres D = 0, else D = 1
    $ => A                   :MLOAD(addrCall)
    ${isWarmedAddress(A)} => D

    ;gas_cost = memory_expansion_cost + code_execution_cost + address_access_cost + positive_value_cost
    ; Calculate address_access_cost: 100 for warm account, 2600 for cold account
    GAS-100-D*2500 => GAS    :JMPN(outOfGas)
    ; Calculate positive_value_cost, if value call > 0 -> 9000
    $ => B                   :MLOAD(valueCall)
    0 => A
    $                        :EQ,JMPC(opCALLCODEend)
    ; Substract gas if the call has value
    GAS - 9000 => GAS        :JMPN(outOfGas)

opCALLCODEend:
    $ => B          :MLOAD(lastMemOffset)
    $ => D          :MLOAD(lastMemLength)
    $ => E          :MLOAD(storageAddr)
    $ => C          :MLOAD(gasRefund)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    E               :MSTORE(txSrcAddr)
    E               :MSTORE(storageAddr)
    C               :MSTORE(gasRefund)
    SR              :MSTORE(initSR)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    B               :MSTORE(retCallOffset)
    D               :MSTORE(retCallLength)
    $ => B          :MLOAD(valueCall)
    B               :MSTORE(txValue)
    0 => A
    $ => C          :LT


                    :CALL(computeGasSendCall)
    ; Add estipend (2300) in case of tx with value
    $ => CTX        :MLOAD(originCTX)
    GAS - A         :MSTORE(gasCTX)
    A + 2300*C => A
    $ => D          :MLOAD(isStaticCall)
    $ => CTX        :MLOAD(currentCTX)
    A => GAS
    D               :MSTORE(isStaticCall)
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
                    :CALL(copySP)
                    :JMP(txType)

opRETURN:
    SP - 2          :JMPN(stackUnderflow)
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;offset
    $ => C          :MLOAD(SP)   ;length

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 32            :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600                :JMPN(outOfCountersStep)

    E               :MSTORE(retDataOffset)
    C               :MSTORE(retDataLength)
    E               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)
                    :CALL(saveMem)
    $ => D          :MLOAD(isCreateContract)
    0 - D           :JMPN(opRETURNdeploy)
    $ => B          :MLOAD(originCTX)
    B - 1           :JMPN(handleGas)
    $ => B          :MLOAD(gasRefund)
    $ => A          :MLOAD(currentCTX)
    $ => CTX        :MLOAD(originCTX)
    ; Add return data context value to origin context
    A               :MSTORE(retDataCTX)
    B               :MSTORE(gasRefund)
    $ => B          :MLOAD(gasCTX)
    B + GAS => GAS

    $ => CTX        :MLOAD(currentCTX)
    $ => D          :MLOAD(retCallLength)
    C => A
    D => B
    $               :LT,JMPC(preRETURN32) ; Take the smaller one
    D => C

preRETURN32:
    $ => B          :MLOAD(retCallOffset)

; Copy from memory current CTX to memory origin CTX
opRETURN32:

    %MAX_CNT_BINARY - CNT_BINARY - 10   :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)

    C - 1           :JMPN(opRETURNend)
    C - 32          :JMPN(opRETURNfinal)
                    :CALL(MLOAD32)
    E => D
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => B
    D => E
    C - 32 => C
    $ => CTX        :MLOAD(currentCTX)
                    :JMP(opRETURN32)

opRETURNfinal:
                    :CALL(MLOADX)
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
    $ => CTX        :MLOAD(currentCTX)

opRETURNend:
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    1               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    $ => A          :MLOAD(depth)
    A - 1           :MSTORE(depth)
    ${commit()}
                    :JMP(readCode)


opRETURNdeploy:
; TODO check what does return?  what assures returned_code_size is correct?
    ; code size limit = 0x6000
    0x6000 - C      :JMPN(invalidCodeSize)
    GAS - 200 * C => GAS    :JMPN(outOfGas) ;code_deposit_cost = 200 * returned_code_size
    $ => B          :MLOAD(originCTX)       ;last ctx
    0 - B           :JMPN(opRETURNcreate)
                    :JMP(endDeploy)

; TODO: not in RETURN, but in CREATE process
opRETURNcreate:

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 192 :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 192 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 2 :JMPN(outOfCountersMemalign)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 1020 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)

    ; save offset memory and length to compute contract hash
    E               :MSTORE(memOffsetLinearPoseidon)
    C               :MSTORE(memSizeLinearPoseidon)

    CTX             :MSTORE(currentCTX)
    $ => B          :MLOAD(gasRefund)
    $ => CTX        :MLOAD(originCTX)
    B               :MSTORE(gasRefund)
    $ => B          :MLOAD(gasCTX)
    ; TODO Should be substracted first the gas
    B + GAS => GAS
    $ => CTX        :MLOAD(currentCTX)
    $ => A          :MLOAD(txSrcAddr)
    $ => D          :MLOAD(txNonce)

    ; set bytecode length
    $ => A          :MLOAD(createContractAddress)
    %SMT_KEY_SC_LENGTH => B
    C => D
    0 => C
    $ => SR         :SSTORE

    ; get bytecode and hash it
                        :CALL(hashPoseidonLinearFromMemory)
    $ => A              :MLOAD(createContractAddress)
    0 => C
    %SMT_KEY_SC_CODE => B

    $ => SR                         :SSTORE

opRETURNcreateEnd:
    $ => A          :MLOAD(createContractAddress)
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
    0               :MSTORE(retDataCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    A               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    $ => A          :MLOAD(depth)
    A - 1           :MSTORE(depth)
    ${commit()}
                    :JMP(readCode)

; TODO if theres a delegate call, there should be not moveBalances
opDELEGATECALL:

    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)
    $ => A          :MLOAD(depth)
    A + 1           :MSTORE(depth)
    SP - 6          :JMPN(stackUnderflow)
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    ; Store gas call
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    ; Store address call
    $ => A          :MLOAD(SP--)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    A               :MSTORE(addrCall)
    ; Store bytes offset int the memory, the calldata of the subcontext
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    A               :MSTORE(lastMemOffset)

    ; Byte size to copy, size of the calldata of the subcontext
    $ => C          :MLOAD(SP--)
    C               :MSTORE(argsLengthCall)
    C               :MSTORE(lastMemLength)
    ; Mem expansion gas cost call args
                    :CALL(saveMem)

    ; Store byte offset in the memory in bytes, where to store the return data of the sub context.
    $ => B          :MLOAD(SP--)
    B               :MSTORE(lastMemOffset)
    ; Store byte size to copy (size of the return data).
    $ => D          :MLOAD(SP)
    D               :MSTORE(lastMemLength)
    ;  Mem expansion gas cost return args
                    :CALL(saveMem)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 32            :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600                :JMPN(outOfCountersStep)


    $ => B                   :MLOAD(lastMemOffset)
    $ => A                   :MLOAD(addrCall)
    ${isWarmedAddress(A)} => C
    ;gas_cost = base_gas + gas_sent_with_call
    GAS-100-C*2500 => GAS    :JMPN(outOfGas)

    $ => C          :MLOAD(txSrcAddr)
    $ => E          :MLOAD(storageAddr)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    C               :MSTORE(txSrcAddr)
    E               :MSTORE(storageAddr)
    1               :MSTORE(isDelegateCall)
    SR              :MSTORE(initSR)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)

    B               :MSTORE(retCallOffset)
    D               :MSTORE(retCallLength)

                    :CALL(computeGasSendCall)
    $ => CTX        :MLOAD(originCTX)
    GAS - A         :MSTORE(gasCTX)
    $ => B          :MLOAD(txValue)
    $ => C          :MLOAD(gasRefund)
    $ => D          :MLOAD(isStaticCall)
    $ => CTX        :MLOAD(currentCTX)
    D               :MSTORE(isStaticCall)
    B               :MSTORE(txValue)
    C               :MSTORE(gasRefund)
    A => GAS

opDELEGATECALLend:
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
                    :CALL(copySP)
                    :JMP(txType)

; // TODO Check with DElEGATE CALL txDestAddr/txSrcAddr ( same as other calls)
; // TODO check revert create
opCREATE2:
    $ => A              :MLOAD(depth)
    A + 1               :MSTORE(depth)
    SP - 4              :JMPN(stackUnderflow)
    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    SP - 1 => SP
    $ => A              :MLOAD(SP--)    ;value
    A                   :MSTORE(valueCall)
    $ => E              :MLOAD(SP--)    ;offset
    E                   :MSTORE(argsOffsetCall)
    $ => C              :MLOAD(SP--)      ;length
    C                   :MSTORE(argsLengthCall)
    $ => D              :MLOAD(SP)    ;salt

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 32            :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600                :JMPN(outOfCountersStep)

    ; Substract gas cost

    ; Mem expansion gas cost
    E                   :MSTORE(lastMemOffset)
    C                   :MSTORE(lastMemLength)
                        :CALL(saveMem)
    CTX                 :MSTORE(originAuxCTX)
    GAS - 32000 => GAS  :JMPN(outOfGas)

    ; Cost to hash the initialisation code
    ${C+31}             :MSTORE(arithA)
    32                  :MSTORE(arithB)
                        :CALL(divARITH)
    $ => C              :MLOAD(arithRes1)
    GAS => A
    6*C => B
    $                   :LT,JMPC(outOfGas)
    A - B => GAS
    GAS                 :MSTORE(gasCall)

    ; Check correctness of Create: depth, can transfer, nonce overlfow, 
    ; can transfer
    $ => A              :MLOAD(storageAddr)
    %SMT_KEY_BALANCE => B                                             ; balance key smt
    0 => C                                                            ; 3rd parameter does not apply to nonce or balance
    $ => A              :SLOAD
    $ => B              :MLOAD(valueCall)
    $                   :LT,JMPC(opCreateFail)

    ; nonce overlow
    $ => A              :MLOAD(storageAddr)
    %SMT_KEY_NONCE => B                                                  ; Constant for nonce
    $ => B              :SLOAD
    A => C
    %MAX_NONCE => A
    $                   :EQ,JMPC(opCreateFail)

    ;change new CTX
    ; B Nonce
    ; C dest Addr
    ; D salt
    SP                  :MSTORE(lastSP)
    PC                  :MSTORE(lastPC)
    $ => A              :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX          :MSTORE(lastCtxUsed)
    CTX                 :MSTORE(currentCTX)
    1                   :MSTORE(isCreateContract)
    1                   :MSTORE(isCreate)
    1                   :MSTORE(isCreate2)
    D                   :MSTORE(salt)
    $ => A              :MLOAD(originAuxCTX)
    A                   :MSTORE(originCTX)

    ; get nonce & update SR
    B                   :MSTORE(txNonce)
                        :CALL(getLenBytes)
    A                   :MSTORE(lengthNonce)
    B + 1 => D
    C => A
    %SMT_KEY_NONCE => B                                                  ; Constant for nonce
    0 => C
    $ => SR             :SSTORE
    SR                  :MSTORE(initSR)
    A                   :MSTORE(txSrcAddr)

                        :CALL(computeGasSendCall)
    $ => CTX            :MLOAD(originCTX)
    $ => C              :MLOAD(gasRefund)
    GAS - A             :MSTORE(gasCTX)
    $ => CTX            :MLOAD(currentCTX)
    C                   :MSTORE(gasRefund)
    A => GAS
                        :CALL(copySP)
   
    $ => A              :MLOAD(argsLengthCall)
    A                   :MSTORE(txCalldataLen)
    $ => A              :MLOAD(valueCall)
    A                   :MSTORE(txValue)

                        :JMP(txType)

;TODO same as other calls
opSTATICCALL:
    $ => A          :MLOAD(depth)
    A + 1           :MSTORE(depth)
    SP - 6          :JMPN(stackUnderflow)
    SP - 1 => SP
    CTX             :MSTORE(originAuxCTX)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(gasCall)
    $ => A          :MLOAD(SP--)
                    :CALL(maskAddress) ; Mask address to 20 bytes
    A               :MSTORE(addrCall)
    $ => A          :MLOAD(SP--)
    A               :MSTORE(argsOffsetCall)
    A               :MSTORE(lastMemOffset)

    $ => B          :MLOAD(SP--)
    B               :MSTORE(argsLengthCall)
    B               :MSTORE(lastMemLength)
                    :CALL(saveMem)

    $ => C          :MLOAD(SP--)
    C               :MSTORE(lastMemOffset)

    $ => D          :MLOAD(SP)
    D               :MSTORE(lastMemLength)
                    :CALL(saveMem)

    ;Check counters
    %MAX_CNT_ARITH - CNT_ARITH - 32            :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 32          :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 510 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600                :JMPN(outOfCountersStep)

    ; Substract gas cost
    $ => A          :MLOAD(addrCall)
    ${isWarmedAddress(A)} => E
    ;gas_cost = base_gas + gas_sent_with_call
    GAS-100-E*2500 => GAS    :JMPN(outOfGas)

    $ => E          :MLOAD(storageAddr)
    $ => B          :MLOAD(gasRefund)
    SP              :MSTORE(lastSP)
    PC              :MSTORE(lastPC)
    ;change new CTX
    $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
    A+1 => CTX      :MSTORE(lastCtxUsed)
    CTX             :MSTORE(currentCTX)
    $ => A          :MLOAD(originAuxCTX)
    A               :MSTORE(originCTX)
    B               :MSTORE(gasRefund)
    0               :MSTORE(txValue)
    1               :MSTORE(isStaticCall)
    E               :MSTORE(txSrcAddr)
    SR              :MSTORE(initSR)
    $ => A          :MLOAD(addrCall)
    A               :MSTORE(txDestAddr)
    A               :MSTORE(storageAddr)
    C               :MSTORE(retCallOffset)
    D               :MSTORE(retCallLength)

                    :CALL(computeGasSendCall)
    $ => CTX        :MLOAD(originCTX)
    GAS - A         :MSTORE(gasCTX)
    $ => CTX        :MLOAD(currentCTX)
    A => GAS
    $ => A          :MLOAD(argsLengthCall)
    A               :MSTORE(txCalldataLen)
                    :CALL(copySP)
                    :JMP(txType)

opREVERT:

    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)

    SP - 2          :JMPN(stackUnderflow)
    $ => SR         :MLOAD(initSR)
    SP - 1 => SP
    $ => E          :MLOAD(SP--) ;offset
    $ => C          :MLOAD(SP) ;length
    E               :MSTORE(retDataOffset)
    C               :MSTORE(retDataLength)
    E               :MSTORE(lastMemOffset)
    C               :MSTORE(lastMemLength)
                    :CALL(saveMem)

    $ => B          :MLOAD(originCTX)
    ${eventLog(onError, revert)}
    0               :MSTORE(gasRefund)
    B - 1           :JMPN(handleGas)
    $ => A          :MLOAD(currentCTX)
    B => CTX
    ; Add return data context value to origin context
    A               :MSTORE(retDataCTX)

    $ => B          :MLOAD(gasCTX)
    GAS + B => GAS

    A => CTX; current context
    $ => D          :MLOAD(retCallLength)
    C => A
    D => B
    $               :LT,JMPC(opREVERT32)
    D => C

; Copy from memory current CTX to memory origin CTX
opREVERT32:
    %MAX_CNT_STEPS - STEP - 400 :JMPN(outOfCountersStep)

    $ => B          :MLOAD(retCallOffset)
    C - 1           :JMPN(opREVERTend)
    C - 32          :JMPN(opREVERTfinal)
                    :CALL(MLOAD32)
    E => D
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTORE32)
    E => B
    D => E
    C - 32 => C
    $ => CTX        :MLOAD(currentCTX)
                    :JMP(opREVERT32)

opREVERTfinal:
                    :CALL(MLOADX)
    $ => CTX        :MLOAD(originCTX)
    B => E
    A               :MSTORE(bytesToStore)
                    :CALL(MSTOREX)
    $ => CTX        :MLOAD(currentCTX)

opREVERTend:
    $ => CTX        :MLOAD(originCTX)
    CTX             :MSTORE(currentCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++)
    1024 - SP       :JMPN(stackOverflow)
    $ => A          :MLOAD(depth)
    A - 1           :MSTORE(depth)
    ${revert()}
                    :JMP(readCode)

; // TODO: handle if depth is over 0
; SELFDESTRUCT is deprecated and EIP-4758 is implemented: https://eips.ethereum.org/EIPS/eip-4758
; SELFDESTRUCT is now SENDALL
opSELFDESTRUCT:

    ;Check counters
    %MAX_CNT_BINARY - CNT_BINARY - 10 :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 2040 :JMPN(outOfCountersPoseidon)
    %MAX_CNT_STEPS - STEP - 600 :JMPN(outOfCountersStep)

    $ => A              :MLOAD(isStaticCall)
    0 - A               :JMPN(invalidStaticTx)
    GAS - 5000 => GAS   :JMPN(outOfGas)

    $ => A              :MLOAD(storageAddr)
    0 => B,C            ; balance key smt
    $ => E              :SLOAD
    E => D

    ; read receiver
    SP - 1 => SP        :JMPN(stackUnderflow)
    $ => A              :MLOAD(SP)
                        :CALL(maskAddress) ; Mask address to 20 bytes
    ; gas: check receiver is empty and balance gt 0
    A => C
    A => E
    0 => A
    D => B
    $                   :EQ,JMPC(opSELFDESTRUCT2)
                        :CALL(isEmptyAccount)
    GAS - 25000 * E => GAS    :JMPN(outOfGas)
    
opSELFDESTRUCT2:
    ; gas: check touched address
    C => A
                              :CALL(maskAddress) ; Mask address to 20 bytes
    ${isWarmedAddress(A)} => E
    GAS - 2600 * E => GAS     :JMPN(outOfGas)

    ; read previous balance receiver
    0 => B,C            ; balance key smt
    $ => E              :SLOAD

    ; compute new receiver balance
    ; Add operation with Arith
    D               :MSTORE(arithA)
    E               :MSTORE(arithB)
                    :CALL(addARITH)
    $ => D          :MLOAD(arithRes1)

    ; transfer balance to receiver
    $ => A                  :MLOAD(SP)
    0 => B,C                ; balance key smt
    $ => SR                 :SSTORE

    ; set contract balance to 0
    $ => A                  :MLOAD(storageAddr)
    0 => D
    $ => SR                 :SSTORE

    $ => A                  :MLOAD(originCTX)
    $                       :EQ,JMPC(handleGas)    
    $ => B                  :MLOAD(gasRefund)
    $ => C                  :MLOAD(isCreate)
    1 => D
    C - 1                   :JMPN(opSELFDESTRUCTCend)
    $ => D                  :MLOAD(createContractAddress)

opSELFDESTRUCTCend:
    A => CTX
    0                       :MSTORE(retDataCTX)
    CTX                     :MSTORE(currentCTX)
    B                       :MSTORE(gasRefund)
    $ => C                  :MLOAD(gasCTX)
    GAS + C => GAS
    $ => SP                 :MLOAD(lastSP)
    $ => PC                 :MLOAD(lastPC)
    D                       :MSTORE(SP++)
    1024 - SP               :JMPN(stackOverflow)
    $ => A                  :MLOAD(depth)
    A - 1                   :MSTORE(depth)
    ${commit()}
                            :JMP(readCode)

opINVALID:
    %MAX_CNT_STEPS - STEP - 120 :JMPN(outOfCountersStep)
                                :JMP(invalidProcess)
