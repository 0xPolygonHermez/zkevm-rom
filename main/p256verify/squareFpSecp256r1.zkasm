;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; squareFpSecp256r1:
;;             in: A
;;             out: A = A² (mod SECP256R1_P)
;;
;;  PRE: Inputs can be any 256-bit number
;; POST: The result is in Fp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; RESOURCES:
; -----------------------------
; [steps: 11, bin: 1, arith: 2]
; -----------------------------

squareFpSecp256r1:
        ; 1] Compute and check the inverse over Z
        ; A·A + [0] = [D]·2²⁵⁶ + [E]
        A => B
        0 => C
        $${var _squareFpSecp256r1_AA = A * A}
        ${_squareFpSecp256r1_AA >> 256} => D
        ${_squareFpSecp256r1_AA} => E :ARITH

        ; 2] Check it over Fp, that is, it must be satisfied that:
        ; [SECP256R1_P]·[A² / SECP256R1_P] + [A² % SECP256R1_P] = D·2²⁵⁶ + E
        ; where C < SECP256R1_P
        %SECP256R1_P => A
        ${_squareFpSecp256r1_AA / const.SECP256R1_P} => B        ; quotient  (256 bits)
        ${_squareFpSecp256r1_AA % const.SECP256R1_P} => C        ; remainder (256 bits)
        E :ARITH

        ; 3] Check that the result is lower than SECP256R1_P
        A => B
        C => A
        1       :LT, RETURN