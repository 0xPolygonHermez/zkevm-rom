
loadTx_rlp:
        ; A new hash with position 0 is started
        0 => HASHPOS

        ; We get a new hashId
        $ => E                          :MLOAD(lastHashIdUsed)
        E+1 => E                        :MSTORE(lastHashIdUsed)
        ; Pointer to next RLP bytes to read
        0 => C


;;;;;;;;;
;; List Length
;;;;;;;;;

        1 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A - 0xc0                        :JMPN(invalidTxRLP)
        A - 0xf8                        :JMPN(shortList)

longList:
        A - 0xf7 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
                                        :JMP(endList)
shortList:
        A - 0xc0 => A

endList:
        A + C                           :MSTORE(txRLPLength)


;;;;;;;;;
;; Nonce READ
;;;;;;;;;


nonceREAD:
        1 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A - 0x80                        :JMPN(endNonce)
        A - 0x81                        :JMPN(nonce0)
        A - 0x89                        :JMPN(shortNonce)
                                        :JMP(invalidTxRLP)

nonce0:
        0                               :MSTORE(lengthNonce)
        0 => A
                                        :JMP(endNonce)

shortNonce:
        A - 0x80 => D
        D                               :MSTORE(lengthNonce)
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)

endNonce:
        A                               :MSTORE(txNonce)


;;;;;;;;;
;; GasPrice READ
;;;;;;;;;


gasPriceREAD:
        1 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A - 0x80                        :JMPN(endGasPrice)
        A - 0x81                        :JMPN(gasPrice0)
        A - 0xa1                        :JMPN(shortGasPrice)
                                        :JMP(invalidTxRLP)

gasPrice0:
        0 => A
                                        :JMP(endGasPrice)

shortGasPrice:
        A - 0x80 => D
        D - 1                           :JMPN(endGasPrice)
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)

endGasPrice:
        A                               :MSTORE(txGasPrice)


;;;;;;;;;
;; Gas READ
;;;;;;;;;


gasREAD:
        1 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A - 0x80                        :JMPN(endGas)
        A - 0x81                        :JMPN(gas0)
        A - 0xa1                        :JMPN(shortGas)
                                        :JMP(invalidTxRLP)

gas0:
        0 => A                          :JMPN(endGas)

shortGas:
        A - 0x80 => D
        D - 1                           :JMPN(endGas)
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)

endGas:
        A                               :MSTORE(txGas)

;;;;;;;;;
;; To READ
;;;;;;;;;


toREAD:
        1 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A - 0x80                        :JMPN(invalidTxRLP)
        A - 0x81                        :JMPN(noTo)
        A - 0x94                        :JMPN(invalidTxRLP)
        A - 0x95                        :JMPN(shortTo)
                                        :JMP(invalidTxRLP)


noTo:
        1                               :MSTORE(isCreateContract)
                                        :JMP(endTo)

shortTo:
        A - 0x80 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A                               :MSTORE(txDestAddr)
        A                               :MSTORE(storageAddr)

endTo:


;;;;;;;;;
;; Value READ
;;;;;;;;;


valueREAD:
        1 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A - 0x80                        :JMPN(endValue)
        A - 0x81                        :JMPN(value0)
        A - 0xa1                        :JMPN(shortValue)
                                        :JMP(invalidTxRLP)

value0:
        0 => A
                                        :JMPN(endValue)

shortValue:
        A - 0x80 => D
        D - 1                           :JMPN(endValue)
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)


endValue:
        A                               :MSTORE(txValue)

;;;;;;;;;
;; Data READ
;;;;;;;;;


dataREAD:
        1 => D
        1024 => SP
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A - 0x80                        :JMPN(veryShortData)
        A - 0x81                        :JMPN(endData)
        A - 0xb8                        :JMPN(shortData)
        A - 0xc0                        :JMPN(longData)
                                        :JMP(invalidTxRLP)

veryShortData:
        1                               :MSTORE(txCalldataLen)
        31 => D
                                        :CALL(SHLarith)
        A                               :MSTORE(SP++)
                                        :JMP(endData)

shortData:
        A - 0x80 => B                   :MSTORE(txCalldataLen)
                                        :JMP(readData)

longData:
        A - 0xb7 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A => B                          :MSTORE(txCalldataLen)

readData:
        32 => D
        B - D                           :JMPN(readDataFinal)
        B - D                           :MSTORE(txDataRead)
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A                               :MSTORE(SP++)
        $ => B                          :MLOAD(txDataRead)
                                        :JMP(readData)


readDataFinal:
        B - 1                           :JMPN(endData)
        B => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        32-D => D
                                        :CALL(SHLarith)
        A                               :MSTORE(SP)

endData:


;;;;;;;;;
;; chainId READ
;;;;;;;;;


chainREAD:
        1 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        A - 0x80                        :JMPN(endChainId)
        A - 0x81                        :JMPN(chanId0)
        A - 0x89                        :JMPN(shortChainId)
                                        :JMP(invalidTxRLP)

chanId0:
        0 => A
                                        :JMPN(endChainId)

shortChainId:
        A - 0x80 => D
        D - 1                           :JMPN(endChainId)
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)

endChainId:
        A                               :MSTORE(txChainId)

;;;;;;;;;
;; Data Last 2 values
;;;;;;;;;

        2 => D
                                        :CALL(addHashTx)
                                        :CALL(addBatchHashData)
        0x8080 => B
        $                               :EQ,JMPC(sizeVerification)
                                        :JMP(invalidTxRLP)

;;;;;;;;;
;; Size Verification
;;;;;;;;;
sizeVerification:
        C  => A
        $  => B                         :MLOAD(txRLPLength)
        A - B                           :JMPN(invalidTxRLP)
        B - A                           :JMPN(invalidTxRLP) ; // TODO: ${comp_eq(A, 0x8080)}
        ; check ctx.hashK[addr].data.length == HASHPOS and ctx.hashK[addr].digest = keccak256(data)
        HASHPOS                         :HASHKLEN(E)

;;;;;;;;;
;; r READ
;;;;;;;;;

rREADTx:
        32 => D
                                        :CALL(getTxBytes)
        A                               :MSTORE(txR)
        C+D => C
                                        :CALL(addBatchHashData)

;;;;;;;;;
;; s READ
;;;;;;;;;

sREADTx:
        32 => D
                                        :CALL(getTxBytes)
        A                               :MSTORE(txS)
        C+D => C
                                        :CALL(addBatchHashData)

;;;;;;;;;
;; v READ
;;;;;;;;;

vREADTx:
        1 => D
                                        :CALL(getTxBytes)
        A                               :MSTORE(txV)
        C+D => C
                                        :CALL(addBatchHashData)

;;;;;;;;;
;; Update bytes read and txs to be processed
;;;;;;;;;
        $ => A                          :MLOAD(batchL2DataParsed)
        A + C => A                      :MSTORE(batchL2DataParsed)
        $ => A                          :MLOAD(pendingTxs)
        A + 1 => A                      :MSTORE(pendingTxs)
        ; Save sigDataSize (sigDataSize --> VAR CTX)
        HASHPOS                         :MSTORE(sigDataSize)
                                        :JMP(txLoopRLP)

addBatchHashData:
        $ => HASHPOS                    :MLOAD(batchHashPos)
        $ => E                          :MLOAD(batchHashDataId)
        A                               :HASHK(E)
        HASHPOS                         :MSTORE(batchHashPos)
        C => HASHPOS
        $ => E                          :MLOAD(lastHashIdUsed)
                                        :RETURN

getTxBytes:
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPN(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
                                        :RETURN

addHashTx:
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPN(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)
        C + D => C
                                        :RETURN

invalidTxRLP:
;;;;;;;;;
;; Append TXs
;;;;;;;;;
        $ => B                          :MLOAD(batchL2DataLength)
        $ => C                          :MLOAD(batchHashPos)
        $ => HASHPOS                    :MLOAD(batchHashPos)
        $ => E                          :MLOAD(batchHashDataId)

appendTxs:
        B - C - 32                      :JMPN(finalAppendTxs)
        32 => D
        ${getTxs(p,D)} => A
        $${p = p + D}
        A                               :HASHK(E)
        C + D => C
                                        :JMP(appendTxs)

finalAppendTxs:
        B - C => D
        D - 1                           :JMPN(endAppendTxs)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)
        C + D => C

endAppendTxs:
        HASHPOS                         :MSTORE(batchHashPos)
                                        :JMP(processTxsEnd)