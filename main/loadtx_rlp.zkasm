
loadTx_rlp:

        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)
        HASHPOS                         :MSTORE(oldHashPos)
        ; A new hash with position 0 is started
        0 => HASHPOS

        ; We get a new hashId
        $ => E                          :MLOAD(lastHashIdUsed)
        E+1 => E                        :MSTORE(lastHashIdUsed)
        ; Pointer to next RLP bytes to read
        0 => C


;;;;;;;;;
;; List Length
;;;;;;;;;

        1 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C
        A - 0xc0                        :JMPC(invalidTxRLP)
        A - 0xf8                        :JMPC(shortList)

longList:
        A - 0xf7 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C
                                        :JMP(endList)
shortList:
        A - 0xc0 => A

endList:
        A + C                           :MSTORE(txRLPLength)


;;;;;;;;;
;; Nonce READ
;;;;;;;;;


nonceREAD:
        1 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C
        A - 0x80                        :JMPC(endNonce)
        A - 0x81                        :JMPC(nonce0)
        A - 0x89                        :JMPC(shortNonce)
                                        :JMP(invalidTxRLP)

nonce0:
        0                               :MSTORE(lengthNonce)
        0 => A
                                        :JMP(endNonce)

shortNonce:
        A - 0x80 => D
        D                               :MSTORE(lengthNonce)
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C

endNonce:
        A                               :MSTORE(txNonce)


;;;;;;;;;
;; GasPrice READ
;;;;;;;;;


gasPriceREAD:
        1 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C

        A - 0x80                        :JMPC(endGasPrice)
        A - 0x81                        :JMPC(gasPrice0)
        A - 0xa1                        :JMPC(shortGasPrice)
                                        :JMP(invalidTxRLP)

gasPrice0:
        0 => A
                                        :JMP(endGasPrice)

shortGasPrice:
        A - 0x80 => D
        D - 1                           :JMPC(endGasPrice)
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C+D => C


endGasPrice:
        A                               :MSTORE(txGasPrice)


;;;;;;;;;
;; Gas READ
;;;;;;;;;


gasREAD:
        1 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C
        A - 0x80                        :JMPC(endGas)
        A - 0x81                        :JMPC(gas0)
        A - 0xa1                        :JMPC(shortGas)
                                        :JMP(invalidTxRLP)

gas0:
        0 => A                          :JMPC(endGas)

shortGas:
        A - 0x80 => D
        D - 1                           :JMPC(endGas)
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C+D => C

endGas:
        A                               :MSTORE(txGas)

;;;;;;;;;
;; To READ
;;;;;;;;;


toREAD:
        1 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C
        A - 0x80                        :JMPC(invalidTxRLP)
        A - 0x81                        :JMPC(noTo)
        A - 0x94                        :JMPC(invalidTxRLP)
        A - 0x95                        :JMPC(shortTo)
                                        :JMP(invalidTxRLP)


noTo:
        1                               :MSTORE(isCreateContract)
                                        :JMP(endTo)

shortTo:
        A - 0x80 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C
        A                               :MSTORE(txDestAddr)
        A                               :MSTORE(storageAddr)

endTo:


;;;;;;;;;
;; Value READ
;;;;;;;;;


valueREAD:
        1 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C

        A - 0x80                        :JMPC(endValue)
        A - 0x81                        :JMPC(value0)
        A - 0xa1                        :JMPC(shortValue)
                                        :JMP(invalidTxRLP)

value0:
        0 => A
                                        :JMPC(endValue)

shortValue:
        A - 0x80 => D
        D - 1                           :JMPC(endValue)
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C


endValue:
        A                               :MSTORE(txValue)

;;;;;;;;;
;; Data READ
;;;;;;;;;


dataREAD:
        1 => D
        1024 => SP
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C
        A - 0x80                        :JMPC(veryShortData)
        A - 0x81                        :JMPC(endData)
        A - 0xb8                        :JMPC(shortData)
        A - 0xc0                        :JMPC(longData)
                                        :JMP(invalidTxRLP)

veryShortData:
        1                               :MSTORE(txCalldataLen)
        31 => D
        ${A << (D*8)} => A
        A                               :MSTORE(SP++)
                                        :JMP(endData)

shortData:
        A - 0x80 => B                   :MSTORE(txCalldataLen)
                                        :JMP(readData)

longData:
        A - 0xb7 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C+D => C
        A => B                          :MSTORE(txCalldataLen)

readData:
        32 => D
        B - D                           :JMPC(readDataFinal)
        B - D                           :MSTORE(txDataRead)
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C
        A                               :MSTORE(SP++)
        $ => B                          :MLOAD(txDataRead)
                                        :JMP(readData)


readDataFinal:
        B - 1                           :JMPC(endData)
        B => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C + D => C

        32-D => D
        ${A << (D*8)} => A
        A                               :MSTORE(SP)

endData:


;;;;;;;;;
;; chainId READ
;;;;;;;;;


chainREAD:
        1 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C+D => C
        A - 0x80                        :JMPC(endChainId)
        A - 0x81                        :JMPC(chanId0)
        A - 0x89                        :JMPC(shortChainId)
                                        :JMP(invalidTxRLP)

chanId0:
        0 => A
                                        :JMPC(endChainId)

shortChainId:
        A - 0x80 => D
        D - 1                           :JMPC(endChainId)
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)    ; Main Hash
        C+D => C

endChainId:
        A                               :MSTORE(txChainId)

;;;;;;;;;
;; Data Last 2 values
;;;;;;;;;

        2 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A - 0x8080                      :JMPC(invalidTxRLP) ; // TODO: ${comp_eq(A, 0x8080)}
        0x8080 - A                      :JMPC(invalidTxRLP)
        A                               :HASHK(E)
        C+D => C

;;;;;;;;;
;; Size Verification
;;;;;;;;;
        C  => A
        $  => B                         :MLOAD(txRLPLength)
        A - B                           :JMPC(invalidTxRLP)
        B - A                           :JMPC(invalidTxRLP) ; // TODO: ${comp_eq(A, 0x8080)}
        ; check ctx.hashK[addr].data.length == HASHPOS and ctx.hashK[addr].digest = keccak256(data)
        HASHPOS                         :HASHKLEN(E)

;;;;;;;;;
;; r READ
;;;;;;;;;

rREADTx:
        32 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :MSTORE(txR)
        C+D => C

;;;;;;;;;
;; s READ
;;;;;;;;;

sREADTx:
        32 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :MSTORE(txS)
        C+D => C

;;;;;;;;;
;; v READ
;;;;;;;;;

vREADTx:
        1 => D
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPC(invalidTxRLP)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :MSTORE(txV)
        C+D => C

;;;;;;;;;
;; Update bytes read and txs to be processed
;;;;;;;;;
        $ => A                          :MLOAD(batchL2DataParsed)
        A + C => A                      :MSTORE(batchL2DataParsed)
        $ => A                          :MLOAD(pendingTxs)
        A + 1 => A                      :MSTORE(pendingTxs)
        ; Save sigDataSize (sigDataSize --> VAR CTX)
        HASHPOS                         :MSTORE(sigDataSize)
        ; Get oldHashPos (saved at the beginning of this file)
        $ => HASHPOS                    :MLOAD(oldHashPos)
                                        :JMP(txLoopRLP)

invalidTxRLP:
                                        :JMP(processTxsEnd)
