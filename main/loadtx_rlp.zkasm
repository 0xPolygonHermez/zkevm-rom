
loadTx_rlp:

        ; We get a new hashId and store it in txHashId
        $ => E                          :MLOAD(lastHashIdUsed)
        E+1 => E                        :MSTORE(lastHashIdUsed)
        E                               :MSTORE(txHashId)
        0 => C

        $${p = 0}


;;;;;;;;;
;; List Length
;;;;;;;;;

        1 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A - 0xc0                        :JMPC(invalidTxRLP)
        A - 0xf8                        :JMPC(endList)

longList:
        A - 0xf7 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
                                        : JMP(endList)

endList:


;;;;;;;;;
;; Nonce READ
;;;;;;;;;

nonceREAD:
        1 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C +1 => C
        A - 0x80                        : JMPC(endNonce)
        A - 0xb8                        : JMPC(shortNonce)
                                        : JMP(invalidTxRLP)
shortNonce:
        A - 0x80 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+D => C

endNonce:
        A                               : MSTORE(txNonce)


;;;;;;;;;
;; GasPrice READ
;;;;;;;;;


gasPriceREAD:
        1 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+1 => C

        A - 0x80                        :JMPC(endGasPrice)
        A - 0xb8                        :JMPC(shortGasPrice)
                                        :JMP(invalidTxRLP)
shortGasPrice:
        A - 0x80 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+D => C


endGasPrice:
        A                               :MSTORE(txGasPrice)


;;;;;;;;;
;; Gas READ
;;;;;;;;;


gasREAD:
        1 => D
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}     
        A                               : HASHW(E)    ; Main Hash
        C+1 => C                        
        A - 0x80                        :JMPC(endGas)
        A - 0xb8                        :JMPC(shortGas)
                                        :JMP(invalidTxRLP)
shortGas:
        A - 0x80 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+D => C

endGas:
        A                               :MSTORE(txGas)

;;;;;;;;;
;; To READ
;;;;;;;;;


toREAD:
        1 => D
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}     
        A                               : HASHW(E)    ; Main Hash
        C+1 => C
        A - 0x80                        :JMPC(invalidTxRLP)
        A - 0x81                        :JMPC(noTo)
        A - 0x94                        :JMPC(invalidTxRLP)
        A - 0x95                        :JMPC(shortTo)
                                        :JMP(invalidTxRLP)


noTo:
        1                               :MSTORE(txIsCreateContract)
                                        :JMP(endTo)
                                        
shortTo:
        A - 0x80 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+D => C
        A                               : MSTORE(txDestAddr)
;        0                              : MSTORE(txIsCreateContract)

endTo:


;;;;;;;;;
;; Value READ
;;;;;;;;;


valueREAD:
        1 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+1 => C

        A - 0x80                        :JMPC(endValue)
        A - 0xb8                        :JMPC(shortValue)
                                        :JMP(invalidTxRLP)
shortValue:
        A - 0x80 => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+D => C


endValue:
        A                               :MSTORE(txValue)

;;;;;;;;;
;; Data READ
;;;;;;;;;


dataREAD:
        1 => D
        1024 => SP
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}     
        A                                : HASHW(E)    ; Main Hash
        C+1 => C
        A - 0x80                         : JMPC(veryShortData)
        A - 0x81                         : JMPC(endData)
        A - 0xb8                         : JMPC(shortData)
        A - 0xc0                         : JMPC(longData)
                                         : JMP(invalidTxRLP)

veryShortData:
        1                               : MSTORE(txNData)
        31 => D
        $ => A                          : SHL
        A                               : MSTORE(SP++)
                                        : JMP(endData)

shortData:
        A - 0x80 => B                   : MSTORE(txNData)
                                        : JMP(readData)

longData:
        A - 0xb8 => D
        ${getRawTx(curTx,p,D)} => A  
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+D => C
        A => B                          : MSTORE(txNData)            

readData:
        32 => D
        B - 32                          :JMPC(readDataFinal)
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+32 => C
        A                               : MSTORE(SP++)
        B - 32 => B                     : JMP(readData)


readDataFinal:
        B - 1                           :JMPC(endData)
        B => D
        ${getRawTx(curTx,p,D)} => A     
        $${ p = p + D}
        A                               : HASHW(E)    ; Main Hash
        C+D => C

        32-D => D
        $ => A                          :SHL
        A                               :MSTORE(SP)

endData:


;;;;;;;;;
;; v READ & Calculate chainId
;;;;;;;;;


readV:
        1 => D
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}
        A                                     : HASHW(E)
        C+D => C
        A - 0x80                              : JMPC(endV)

shortV:
        A - 0x80 => D
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}
        C+D => C

endV:
        A                                     : MSTORE(txV)
        ${calculateChainId(A)} => A           : MSTORE(txChainId)
        A                                     : HASHW(E)

;;;;;;;;;
;; r READ
;;;;;;;;;

rREADTx:
        1 => D
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}

        A - 0x80                        :JMPC(invalidTxRLP)
        A - 0x80 => D
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}
        A                               :MSTORE(txR)

;;;;;;;;;
;; s READ
;;;;;;;;;


sREADTx:
        1 => D
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}
        A - 0x80                        :JMPC(invalidTxRLP)
        A - 0x80 => D
        ${getRawTx(curTx,p,D)} => A
        $${ p = p + D}
        A                               : MSTORE(txS)

;;;;;;;;;
;; Data Last 2 values
;;;;;;;;;

        2 => D
        0x8080 => A
        A                               : HASHW(E)
        C + D => C

;;;;;;;;;
;; Signaure Verification
;;;;;;;;;
        1024 => SP
        ; Check the signature
        ${buildHashRLP(C)}
                                        :HASHE(E)
        $ => A                          :HASHR(E)
        $ => B                          :MLOAD(txR)
        $ => C                          :MLOAD(txS)
        $ => D                          :MLOAD(txV)
        $ => A                          :ECRECOVER
        A                               :MSTORE(txSrcAddr)
        A                               :MSTORE(txSrcOriginAddr)

                                        :JMP(txLoopRLPEnd)

invalidTxRLP:
                                        :JMP(processTxsEnd)
