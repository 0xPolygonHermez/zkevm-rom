
VAR GLOBAL pushBytes
; @info Read bytes opcode PUSHX
; @internalParam {numBlocks} 4 bytes blocks to read
; @internalParam {leftBytes} remaining bytes
; @in D,E => bytes to read (1..32)
; @out E => value read

readPush:
                            :JMP(@readPush+E)    ;0
readPush1:
    PC => HASHPOS           :JMP(_readPush1)     ;1
readPush2:
    PC => HASHPOS           :JMP(_readPush2)     ;2
readPush3:
    PC => HASHPOS           :JMP(_readPush3)     ;3
readPush4:
    PC => HASHPOS           :JMP(_readPush4)     ;4
readPush5:
    PC => HASHPOS           :JMP(_readPushX)     ;5
readPush6:
    PC => HASHPOS           :JMP(_readPushX)     ;6
readPush7:
    PC => HASHPOS           :JMP(_readPushX)     ;7
readPush8:
    PC => HASHPOS           :JMP(_readPushX)     ;8
readPush9:
    PC => HASHPOS           :JMP(_readPushX)     ;9
readPush10:
    PC => HASHPOS           :JMP(_readPushX)     ;10
readPush11:
    PC => HASHPOS           :JMP(_readPushX)     ;11
readPush12:
    PC => HASHPOS           :JMP(_readPushX)     ;12
readPush13:
    PC => HASHPOS           :JMP(_readPushX)     ;13
readPush14:
    PC => HASHPOS           :JMP(_readPushX)     ;14
readPush15:
    PC => HASHPOS           :JMP(_readPushX)     ;15
readPush16:
    PC => HASHPOS           :JMP(_readPushX)     ;16
readPush17:
    PC => HASHPOS           :JMP(_readPushX)     ;17
readPush18:
    PC => HASHPOS           :JMP(_readPushX)     ;18
readPush19:
    PC => HASHPOS           :JMP(_readPushX)     ;19
readPush20:
    PC => HASHPOS           :JMP(_readPushX)     ;20
readPush21:
    PC => HASHPOS           :JMP(_readPushX)     ;21
readPush22:
    PC => HASHPOS           :JMP(_readPushX)     ;22
readPush23:
    PC => HASHPOS           :JMP(_readPushX)     ;23
readPush24:
    PC => HASHPOS           :JMP(_readPushX)     ;24
readPush25:
    PC => HASHPOS           :JMP(_readPushX)     ;25
readPush26:
    PC => HASHPOS           :JMP(_readPushX)     ;26
readPush27:
    PC => HASHPOS           :JMP(_readPushX)     ;27
readPush28:
    PC => HASHPOS           :JMP(_readPushX)     ;28
readPush29:
    PC => HASHPOS           :JMP(_readPushX)     ;29
readPush30:
    PC => HASHPOS           :JMP(_readPushX)     ;30
readPush31:
    PC => HASHPOS           :JMP(_readPushX)     ;31
readPush32:
    PC => HASHPOS           :JMP(_readPush32)    ;32

_readPush1:
    $ => E                      :MLOAD(contractHashId)
    $ => E                      :HASHP1(E),RETURN

_readPush2:
    $ => E                      :MLOAD(contractHashId)
    $ => C                      :HASHP1(E)
    C * 256 + $ => E            :F_HASHP1(E), RETURN

_readPush3:
    $ => E                      :MLOAD(contractHashId)
    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => E            :F_HASHP1(E), RETURN

_readPush4:
    $ => E                      :MLOAD(contractHashId)
    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => E            :F_HASHP1(E), RETURN

_readPush32:
    $ => E                      :MLOAD(contractHashId)

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => C            :F_HASHP1(E)

    ; 28 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 24 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 20 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 16 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 12 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 8 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 4 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => E   :F_HASHP1(E),RETURN

_readPushBaseTable:

_readPushX:
    $ => B                      :MLOAD(contractHashId)

readPushBytes:
    0 => A, C
    B => E                     :JMP(@_readPushBaseTable - E)
