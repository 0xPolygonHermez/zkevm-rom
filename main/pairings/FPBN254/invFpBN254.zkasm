;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: A is assumed to be in the range [0,BN254_P)
;; POST: The result is in the range [0,BN254_P)
;;
;; invFpBN254:
;;             in: A ∈ Fp
;;             out: B = A⁻¹ (mod BN254_P) ∈ Fp
;;
;; NOTE: On input 0, it returns 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; RESOURCES:
; -------------------------------------------
; PATH 1 input_is_0:     [steps: 2,  bin: 0]
; PATH 2 input_is_not_0: [steps: 11, bin: 2, arith: 1] <-- w.c.
; -------------------------------------------

invFpBN254:
        ; Check if A = 0, and if so, return 0
        ${A == 0}       :JMPNZ(invFpBN254_A_is_zero)

        0 => B
        0       :EQ

invFpBN254_normalized:
        ; A·A⁻¹ + 0 = 1 (mod BN254_P)
        ${var _invFpBN254_A = fpBN254inv(A)} => B
        0 => C
        %BN254_P => D
        1n                      :ARITH_MOD

        ; Check that the resulting inverse is alias-free
        B => A
        %BN254_P => B
        1                       :LT

        A => B                  :RETURN

invFpBN254_A_is_zero:
        0 => B                  :ASSERT, RETURN