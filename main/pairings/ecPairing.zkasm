;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; ecPairing:
;;          input: P1,...,Pn ∈ G1 and Q1,...,Qn ∈ G2, where G1 = E(Fp)[r] = E(Fp), G2 = E'(Fp2)[r] and
;;                 the curves are E/Fp: y² = x³ + 3 and E'/Fp2: y² = x³ + 3/(9+u)
;;          output: 1 if e(P1,Q1)·...·e(Pn,Qn) = 1, 0 otherwise; where e: G1 x G2 -> GT is 
;;                      the optimal Ate pairing over the BN254 curve and GT = mu_r (the r-th roots of unity over (Fp12)^*)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The point at infinity is represented by (0,0).

; TODO: The input should be a multiple of 6
; TODO: edge-case, if there are no inputs, then it simply returns 1

VAR GLOBAL ecPairing_P1_x
VAR GLOBAL ecPairing_P1_y
VAR GLOBAL ecPairing_Q1_x1
VAR GLOBAL ecPairing_Q1_x2
VAR GLOBAL ecPairing_Q1_y1
VAR GLOBAL ecPairing_Q1_y2

VAR GLOBAL ecPairing_RR

; ERROR CODES (B)
; 0 - no error
; 1 - P1 is not in E(Fp)
; 2 - P2 is not in E(Fp)

ecPairing:
        RR              :MSTORE(ecPairing_RR)

        ; 1] Compute and check the sum over Z
        ; A·[1] + C = [D]·2²⁵⁶ + [E]
        1 => B
        $${var _addFpBN254_AC = A + C}
        ${_addFpBN254_AC >> 256} => D
        ${_addFpBN254_AC} => E :ARITH

        ; 2] Check it over Fp, that is, it must be satisfied that:
        ; [BN254_P]·[A+C] + [C] = D·2²⁵⁶ + E
        %BN254_P => A
        ${_addFpBN254_AC / const.BN254_P} => B        ; residue  (256 bits)
        ${_addFpBN254_AC % const.BN254_P} => C        ; quotient (256 bits)

        E :ARITH,RETURN

; ERRORS
ecPairing_P_is_not_in_G1:
    1 => B      :JMP(ecPairing_error)

ecPairing_Q_is_not_in_G2:
    2 => B      :JMP(ecPairing_error)

ecPairing_error:
        0 => A

ecPairing_end:
        $ => RR     :MLOAD(ecPairing_RR)
        :RETURN