;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PRE: P ∈ E'(Fp2)
;; POST: The resulting coordinates are in the range [0,BN254_P) because if falls back to addPointBN254
;;
;;
;; escalarMulBN254:
;;             in: k, P = (P.x1 + P.x2·u, P.y1 + P.y2·u) ∈ E'(Fp2), where k ∈ [0,r-1]
;;             out: k·P = (Q.x1 + Q.x2·u, Q.y1 + Q.y2·u) ∈ E'(Fp2)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; escalarMulBN254 assumes P belong to E'(Fp2), since it is checked in the pairing.
; However, it must be implemented if escalarMulBN254 wants to be used independently.

; Since the curve is E'/Fp2: y² = x³ + 3/(9+u), there is no issue in representing the point at infinity as (0, 0).

VAR GLOBAL escalarMulBN254_k
VAR GLOBAL escalarMulBN254_P_x1
VAR GLOBAL escalarMulBN254_P_x2
VAR GLOBAL escalarMulBN254_P_y1
VAR GLOBAL escalarMulBN254_P_y2
VAR GLOBAL escalarMulBN254_Q_x1
VAR GLOBAL escalarMulBN254_Q_x2
VAR GLOBAL escalarMulBN254_Q_y1
VAR GLOBAL escalarMulBN254_Q_y2

VAR GLOBAL escalarMulBN254_RR

; RESOURCES:
; -------------------------------------------
; PATH 1 P == 𝒪:            [steps: 17, bin: 4]
; PATH 2 k == 0 and P != 𝒪: [steps: 24, bin: 3, arith: 1]-[steps: 30, bin: 6, arith: 1]
; PATH 3 k != 0 and P != 𝒪:  <--- w.c.
;                [steps: 33, bin: 6, arith: 1]                                 // setup
;                 + (257 - pos_1st_nz_bit(k)) * [steps: 3, bin: 1]             // find MSB of k
;                 + max_bin_len(k) * [steps: 162, bin: 19, arith: 11]          // doubles
;                 + number_of_bits_1(k) * [steps: 152, bin: 16, arith: 10]     // additions
;                 + [steps: 3]                                                 // last iteration + end
;               total (w.c.): [steps: 79176 bin: 8830, arith: 5293]            // [33 + 4*3 + 252*162 + 252*152 + 3,
;                                                                                   6 + 4*1 + 252*19  + 252*16,
;                                                                                   1       + 252*11  + 252*10]
; -------------------------------------------

escalarMulBN254:
        RR      :MSTORE(escalarMulBN254_RR)

        ; Is P = O?
        0n => B
        $ => A  :MLOAD(escalarMulBN254_P_x1)
        $       :EQ, JMPNC(__escalarMulBN254_P_continue)
        $ => A  :MLOAD(escalarMulBN254_P_x2)
        $       :EQ, JMPNC(__escalarMulBN254_P_continue)
        $ => A  :MLOAD(escalarMulBN254_P_y1)
        $       :EQ, JMPNC(__escalarMulBN254_P_continue)
        $ => A  :MLOAD(escalarMulBN254_P_y2)
        $       :EQ, JMPC(escalarMulBN254_P_is_zero)
                __escalarMulBN254_P_continue:
        ; [steps: 10, bin: 4]

        ; Is k = 0?
        $ => B      :MLOAD(escalarMulBN254_k), CALL(reduceFrBN254)
        A           :MSTORE(escalarMulBN254_k)
        0n => B
        $           :EQ, JMPC(escalarMulBN254_k_is_zero)
        ; [steps: 23, bin: 6, arith: 1]

        257 => RCX

        $ => A  :MLOAD(escalarMulBN254_P_x1)
        $ => B  :MLOAD(escalarMulBN254_P_x2)
        $ => C  :MLOAD(escalarMulBN254_P_y1)
        $ => D  :MLOAD(escalarMulBN254_P_y2)
        A       :MSTORE(escalarMulBN254_Q_x1)
        B       :MSTORE(escalarMulBN254_Q_x2)
        C       :MSTORE(escalarMulBN254_Q_y1)
        D       :MSTORE(escalarMulBN254_Q_y2)

                :JMP(escalarMulBN254_find_MSB_k)
        ; [steps: 33, bin: 6, arith: 1]

; Begin of branching
escalarMulBN254_P_is_zero:
        ; before (w.c.) -> [steps: 10, bin: 4]

        ; Q = O
        0n      :MSTORE(escalarMulBN254_Q_x1)
        0n      :MSTORE(escalarMulBN254_Q_x2)
        0n      :MSTORE(escalarMulBN254_Q_y1)
        0n      :MSTORE(escalarMulBN254_Q_y2)

                :JMP(escalarMulBN254_end)

        ; till the end -> [steps: 17, bin: 4]

escalarMulBN254_k_is_zero:
        ; before (w.c.) -> [steps: 23, bin: 6, arith: 1]

        ; Q = O
        0n      :MSTORE(escalarMulBN254_Q_x1)
        0n      :MSTORE(escalarMulBN254_Q_x2)
        0n      :MSTORE(escalarMulBN254_Q_y1)
        0n      :MSTORE(escalarMulBN254_Q_y2)

                :JMP(escalarMulBN254_end)

        ; till the end -> [steps: 30, bin: 6, arith: 1]
; End of branching

escalarMulBN254_find_MSB_k:
        ; block costs: [steps: 3, bin: 1]
        RCX - 1 => RCX
        $ => A,B        :MLOAD(escalarMulBN254_k)
        ; E = 2A
        $ => E          :ADD, MSTORE(escalarMulBN254_k), JMPNC(escalarMulBN254_find_MSB_k)


escalarMulBN254_loop:
        ; block costs:
        ;       no_last: [steps: 162, bin: 19, arith: 11]
        ;       last:    [steps: 1]

        RCX - 1 => RCX    :JMPZ(escalarMulBN254_end)

        ; We always double
        $ => A  :MLOAD(escalarMulBN254_Q_x1)
        $ => B  :MLOAD(escalarMulBN254_Q_x2)
        $ => C  :MLOAD(escalarMulBN254_Q_y1)
        $ => D  :MLOAD(escalarMulBN254_Q_y2)
        A       :MSTORE(addPointBN254_P1_x1)
        B       :MSTORE(addPointBN254_P1_x2)
        C       :MSTORE(addPointBN254_P1_y1)
        D       :MSTORE(addPointBN254_P1_y2)
        A       :MSTORE(addPointBN254_P2_x1)
        B       :MSTORE(addPointBN254_P2_x2)
        C       :MSTORE(addPointBN254_P2_y1)
        D       :MSTORE(addPointBN254_P2_y2), CALL(addPointBN254)
        ; Q = Q + Q

        $ => A  :MLOAD(addPointBN254_P3_x1)
        $ => B  :MLOAD(addPointBN254_P3_x2)
        $ => C  :MLOAD(addPointBN254_P3_y1)
        $ => D  :MLOAD(addPointBN254_P3_y2)
        A       :MSTORE(escalarMulBN254_Q_x1)
        B       :MSTORE(escalarMulBN254_Q_x2)
        C       :MSTORE(escalarMulBN254_Q_y1)
        D       :MSTORE(escalarMulBN254_Q_y2)

        ; We check if the MSB b of k is either 1 or 0. If b==1, we should add P to Q.
        ; Then, update the value of k.
        $ => A,B        :MLOAD(escalarMulBN254_k)
        ; E = 2A
        $ => E          :ADD, MSTORE(escalarMulBN254_k), JMPNC(escalarMulBN254_loop)

escalarMulBN254_add:
        ; block costs: [steps: 152, bin: 16, arith: 10]

        ; We add
        $ => A  :MLOAD(escalarMulBN254_Q_x1)
        $ => B  :MLOAD(escalarMulBN254_Q_x2)
        $ => C  :MLOAD(escalarMulBN254_Q_y1)
        $ => D  :MLOAD(escalarMulBN254_Q_y2)
        A       :MSTORE(addPointBN254_P1_x1)
        B       :MSTORE(addPointBN254_P1_x2)
        C       :MSTORE(addPointBN254_P1_y1)
        D       :MSTORE(addPointBN254_P1_y2)

        $ => A  :MLOAD(escalarMulBN254_P_x1)
        $ => B  :MLOAD(escalarMulBN254_P_x2)
        $ => C  :MLOAD(escalarMulBN254_P_y1)
        $ => D  :MLOAD(escalarMulBN254_P_y2)
        A       :MSTORE(addPointBN254_P2_x1)
        B       :MSTORE(addPointBN254_P2_x2)
        C       :MSTORE(addPointBN254_P2_y1)
        D       :MSTORE(addPointBN254_P2_y2), CALL(addPointBN254)
        ; Q = Q + P

        $ => A  :MLOAD(addPointBN254_P3_x1)
        $ => B  :MLOAD(addPointBN254_P3_x2)
        $ => C  :MLOAD(addPointBN254_P3_y1)
        $ => D  :MLOAD(addPointBN254_P3_y2)
        A       :MSTORE(escalarMulBN254_Q_x1)
        B       :MSTORE(escalarMulBN254_Q_x2)
        C       :MSTORE(escalarMulBN254_Q_y1)
        D       :MSTORE(escalarMulBN254_Q_y2), JMP(escalarMulBN254_loop)


escalarMulBN254_end:
        $ => RR :MLOAD(escalarMulBN254_RR)
                :RETURN