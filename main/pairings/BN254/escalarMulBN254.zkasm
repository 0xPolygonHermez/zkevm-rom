;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Recall that the elliptic curve is E'/Fp2: y² = x³ + 3/(9+u)
;;
;; escalarMulBN254:
;;             in: k, P = (P.x1 + P.x2·u, P.y1 + P.y2·u) ∈ E'(Fp2), where k ∈ [0,r-1]
;;             out: Q = (Q.x1 + Q.x2·u, Q.y1 + Q.y2·u) = k·P ∈ E'(Fp2)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

VAR GLOBAL escalarMulBN254_k
VAR GLOBAL escalarMulBN254_P_x1
VAR GLOBAL escalarMulBN254_P_x2
VAR GLOBAL escalarMulBN254_P_y1
VAR GLOBAL escalarMulBN254_P_y2
VAR GLOBAL escalarMulBN254_Q_x1
VAR GLOBAL escalarMulBN254_Q_x2
VAR GLOBAL escalarMulBN254_Q_y1
VAR GLOBAL escalarMulBN254_Q_y2

VAR GLOBAL escalarMulBN254_RR


escalarMulBN254:
        RR      :MSTORE(escalarMulBN254_RR)

        ; Check if P = 0
        ${FpBN254neq0(mem.escalarMulBN254_P_x1) || FpBN254neq0(mem.escalarMulBN254_P_x2) || FpBN254neq0(mem.escalarMulBN254_P_y1) || FpBN254neq0(mem.escalarMulBN254_P_y2)}   :JMPZ(escalarMulBN254_P_is_zero)

        ; The following is a redundant check in the pairing context
        ; ; 1] Check if P is in E'(Fp2)
        ; ; P in E' iff (P.y1 + P.y2·u)² == (P.x1 + P.x2·u)³ + 3/(9+u)
        ; ; 1.1] Compute LHS and RHS
        ; $ => A  :MLOAD(escalarMulBN254_P_x1)
        ; $ => B  :MLOAD(escalarMulBN254_P_x2)
        ;         :CALL(squareFp2BN254)
        ; ; E + C·u = (P.x1 + P.x2·u)²

        ; E => A
        ; C => B
        ; $ => C  :MLOAD(escalarMulBN254_P_x1)
        ; $ => D  :MLOAD(escalarMulBN254_P_x2)
        ;         :CALL(mulFp2BN254)
        ; ; E + C·u = (P.x1 + P.x2·u)³

        ; E => A
        ; C => B
        ; %BN254_ETWISTED_B_X => C
        ; %BN254_ETWISTED_B_Y => D
        ;         :CALL(addFp2BN254)
        ; ; E + C·u = (P.x1 + P.x2·u)³ + 3/(9+u)
        ; E           :MSTORE(escalarMulBN254_Q_x1)
        ; C           :MSTORE(escalarMulBN254_Q_x2)

        ; $ => A  :MLOAD(escalarMulBN254_P_y1)
        ; $ => B  :MLOAD(escalarMulBN254_P_y2)
        ;         :CALL(squareFp2BN254)
        ; ; E + C·u = (P.y1 + P.y2·u)²

        ; ; 1.2] Check if LHS == RHS
        ; E => A
        ; $ => B  :MLOAD(escalarMulBN254_Q_x1)
        ; B       :ASSERT

        ; C => A
        ; $ => B  :MLOAD(escalarMulBN254_Q_x2)
        ; B       :ASSERT

        ; Check if k ∈ [1,r-1]
        $ => B      :MLOAD(escalarMulBN254_k)
        0n => A
        $           :EQ,JMPC(escalarMulBN254_k_is_zero)
        %BN254_R_MINUS_ONE => A
        $           :LT,JMPC(escalarMulBN254_k_reduce)


        ; ${log2(mem.escalarMulBN254_k)} => RCX
        257 => RCX

        $ => A  :MLOAD(escalarMulBN254_P_x1)
        $ => B  :MLOAD(escalarMulBN254_P_x2)
        $ => C  :MLOAD(escalarMulBN254_P_y1)
        $ => D  :MLOAD(escalarMulBN254_P_y2)
        A       :MSTORE(escalarMulBN254_Q_x1)
        B       :MSTORE(escalarMulBN254_Q_x2)
        C       :MSTORE(escalarMulBN254_Q_y1)
        D       :MSTORE(escalarMulBN254_Q_y2)

                :JMP(escalarMulBN254_find_MSB_k)

escalarMulBN254_P_is_zero:
        ; Check that P is zero
        0n => B
        $ => A  :MLOAD(escalarMulBN254_P_x1)
        1       :EQ
        $ => A  :MLOAD(escalarMulBN254_P_x2)
        1       :EQ
        $ => A  :MLOAD(escalarMulBN254_P_y1)
        1       :EQ
        $ => A  :MLOAD(escalarMulBN254_P_y2)
        1       :EQ

        0n      :MSTORE(escalarMulBN254_Q_x1)
        0n      :MSTORE(escalarMulBN254_Q_x2)
        0n      :MSTORE(escalarMulBN254_Q_y1)
        0n      :MSTORE(escalarMulBN254_Q_y2)

                :JMP(escalarMulBN254_end)

escalarMulBN254_k_is_zero:
        ; Check that k is zero
        0n => B
        $ => A  :MLOAD(escalarMulBN254_k)
        1       :EQ

        0n      :MSTORE(escalarMulBN254_Q_x1)
        0n      :MSTORE(escalarMulBN254_Q_x2)
        0n      :MSTORE(escalarMulBN254_Q_y1)
        0n      :MSTORE(escalarMulBN254_Q_y2)

                :JMP(escalarMulBN254_end)

escalarMulBN254_k_reduce:
        ${dump(B)}
        ; We reduce k mod R and continue as normal
                :CALL(reduceFrBN254)

        ; We check that is not 0
        C => B  :MSTORE(escalarMulBN254_k)
        0n => A
        $           :EQ,JMPC(escalarMulBN254_k_is_zero)

        257 => RCX

        $ => A  :MLOAD(escalarMulBN254_P_x1)
        $ => B  :MLOAD(escalarMulBN254_P_x2)
        $ => C  :MLOAD(escalarMulBN254_P_y1)
        $ => D  :MLOAD(escalarMulBN254_P_y2)
        A       :MSTORE(escalarMulBN254_Q_x1)
        B       :MSTORE(escalarMulBN254_Q_x2)
        C       :MSTORE(escalarMulBN254_Q_y1)
        D       :MSTORE(escalarMulBN254_Q_y2)

; Assumes k is well-formed
escalarMulBN254_find_MSB_k:
        RCX - 1 => RCX
        $ => A,B        :MLOAD(escalarMulBN254_k)
        ; E = 2A
        $ => E          :ADD,MSTORE(escalarMulBN254_k),JMPNC(escalarMulBN254_find_MSB_k)


escalarMulBN254_loop:
        RCX - 1 => RCX    :JMPZ(escalarMulBN254_end)

        ; We always double
        $ => A  :MLOAD(escalarMulBN254_Q_x1)
        $ => B  :MLOAD(escalarMulBN254_Q_x2)
        $ => C  :MLOAD(escalarMulBN254_Q_y1)
        $ => D  :MLOAD(escalarMulBN254_Q_y2)
        A       :MSTORE(addPointBN254_P1_x1)
        B       :MSTORE(addPointBN254_P1_x2)
        C       :MSTORE(addPointBN254_P1_y1)
        D       :MSTORE(addPointBN254_P1_y2)
        A       :MSTORE(addPointBN254_P2_x1)
        B       :MSTORE(addPointBN254_P2_x2)
        C       :MSTORE(addPointBN254_P2_y1)
        D       :MSTORE(addPointBN254_P2_y2), CALL(addPointBN254)
        ; Q = Q + Q

        $ => A  :MLOAD(addPointBN254_P3_x1)
        $ => B  :MLOAD(addPointBN254_P3_x2)
        $ => C  :MLOAD(addPointBN254_P3_y1)
        $ => D  :MLOAD(addPointBN254_P3_y2)
        A       :MSTORE(escalarMulBN254_Q_x1)
        B       :MSTORE(escalarMulBN254_Q_x2)
        C       :MSTORE(escalarMulBN254_Q_y1)
        D       :MSTORE(escalarMulBN254_Q_y2)

        ; We check if the MSB b of k is either 1 or 0. If b==1, we should add P to Q.
        ; Then, update the value of k.
        $ => A,B        :MLOAD(escalarMulBN254_k)
        ; E = 2A
        $ => E          :ADD,MSTORE(escalarMulBN254_k),JMPNC(escalarMulBN254_loop)

escalarMulBN254_add:
        ; We add
        $ => A  :MLOAD(escalarMulBN254_Q_x1)
        $ => B  :MLOAD(escalarMulBN254_Q_x2)
        $ => C  :MLOAD(escalarMulBN254_Q_y1)
        $ => D  :MLOAD(escalarMulBN254_Q_y2)
        A       :MSTORE(addPointBN254_P1_x1)
        B       :MSTORE(addPointBN254_P1_x2)
        C       :MSTORE(addPointBN254_P1_y1)
        D       :MSTORE(addPointBN254_P1_y2)

        $ => A  :MLOAD(escalarMulBN254_P_x1)
        $ => B  :MLOAD(escalarMulBN254_P_x2)
        $ => C  :MLOAD(escalarMulBN254_P_y1)
        $ => D  :MLOAD(escalarMulBN254_P_y2)
        A       :MSTORE(addPointBN254_P2_x1)
        B       :MSTORE(addPointBN254_P2_x2)
        C       :MSTORE(addPointBN254_P2_y1)
        D       :MSTORE(addPointBN254_P2_y2), CALL(addPointBN254)
        ; Q = Q + P

        $ => A  :MLOAD(addPointBN254_P3_x1)
        $ => B  :MLOAD(addPointBN254_P3_x2)
        $ => C  :MLOAD(addPointBN254_P3_y1)
        $ => D  :MLOAD(addPointBN254_P3_y2)
        A       :MSTORE(escalarMulBN254_Q_x1)
        B       :MSTORE(escalarMulBN254_Q_x2)
        C       :MSTORE(escalarMulBN254_Q_y1)
        D       :MSTORE(escalarMulBN254_Q_y2), JMP(escalarMulBN254_loop)


escalarMulBN254_end:

        $ => RR :MLOAD(escalarMulBN254_RR)
                :RETURN