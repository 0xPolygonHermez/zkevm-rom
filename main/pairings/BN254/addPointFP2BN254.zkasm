;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PRE: P1,P2 ∈ E'(Fp2)
;; POST: The resulting coordinates are in the range [0,BN254_P) because if falls back to FP2 arithmetic
;;
;; addPointFP2BN254:
;;             in: P1 = (P1.x1 + P1.x2·u, P1.y1 + P1.y2·u), P2 = (P2.x1 + P2.x2·u, P2.y1 + P2.y2·u) ∈ E'(Fp2)
;;             out: P1 + P2 = (P3.x1 + P3.x2·u, P3.y1 + P3.y2·u) ∈ E'(Fp2)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; addPointFP2BN254 assumes both P1 and P2 belong to E'(Fp2), since it is checked in the pairing.
; However, it must be implemented if addPointFP2BN254 wants to be used independently.

; Since the curve is E'/Fp2: y² = x³ + 3/(9+u), there is no issue in representing the point at infinity as (0, 0).

VAR GLOBAL addPointFP2BN254_P1_x1
VAR GLOBAL addPointFP2BN254_P1_x2
VAR GLOBAL addPointFP2BN254_P1_y1
VAR GLOBAL addPointFP2BN254_P1_y2
VAR GLOBAL addPointFP2BN254_P2_x1
VAR GLOBAL addPointFP2BN254_P2_x2
VAR GLOBAL addPointFP2BN254_P2_y1
VAR GLOBAL addPointFP2BN254_P2_y2
VAR GLOBAL addPointFP2BN254_P3_x1
VAR GLOBAL addPointFP2BN254_P3_x2
VAR GLOBAL addPointFP2BN254_P3_y1
VAR GLOBAL addPointFP2BN254_P3_y2
VAR GLOBAL addPointFP2BN254_lambda_x
VAR GLOBAL addPointFP2BN254_lambda_y

VAR GLOBAL addPointFP2BN254_diff ; 1 if one can assume that P1 != P2 and P1,P2 != 𝒪, 0 otherwise

VAR GLOBAL addPointFP2BN254_RR

; RESOURCES:
; -------------------------------------------
; PATH 1 addPointFP2BN254_diff = 0:
;       · PATH 1.1 P1 == 𝒪:                     [steps: 21, bin: 4]
;       · PATH 1.2 P1 != 𝒪 and P2 == 𝒪:         [steps: 30, bin: 8]
;       · PATH 1.3 P1,P2 != 𝒪 and P1 == -P2:    [steps: 47, bin: 14]
;       · PATH 1.4 P1,P2 != 𝒪 and P1 == P2:     [steps: 121, bin: 10, arith: 11]-[steps: 133, bin: 16, arith: 11] <--- w.c.
;       · PATH 1.5 P1,P2 != 𝒪 and P1 != P2,-P2: [steps: 110, bin: 7, arith: 10]-[steps: 125, bin: 14, arith: 10]
; PATH 2 addPointFP2BN254_diff = 1: [steps: 101, bin: 4, arith: 10]
; -------------------------------------------

addPointFP2BN254:
        RR      :MSTORE(addPointFP2BN254_RR)

        $       :MLOAD(addPointFP2BN254_diff), JMPNZ(addPointFP2BN254_different)

        ; Is P1 = 𝒪?
        0n => B
        $ => A  :MLOAD(addPointFP2BN254_P1_x1)
        $       :EQ, JMPNC(__addPointFP2BN254_P1_continue)
        $ => A  :MLOAD(addPointFP2BN254_P1_x2)
        $       :EQ, JMPNC(__addPointFP2BN254_P1_continue)
        $ => A  :MLOAD(addPointFP2BN254_P1_y1)
        $       :EQ, JMPNC(__addPointFP2BN254_P1_continue)
        $ => A  :MLOAD(addPointFP2BN254_P1_y2)
        $       :EQ, JMPC(addPointFP2BN254_P1_is_zero)
                __addPointFP2BN254_P1_continue:
        ; [steps: 11, bin: 4]

        ; Is P2 = 𝒪?
        0n => B
        $ => A  :MLOAD(addPointFP2BN254_P2_x1)
        $       :EQ, JMPNC(__addPointFP2BN254_P2_continue)
        $ => A  :MLOAD(addPointFP2BN254_P2_x2)
        $       :EQ, JMPNC(__addPointFP2BN254_P2_continue)
        $ => A  :MLOAD(addPointFP2BN254_P2_y1)
        $       :EQ, JMPNC(__addPointFP2BN254_P2_continue)
        $ => A  :MLOAD(addPointFP2BN254_P2_y2)
        $       :EQ, JMPC(addPointFP2BN254_P2_is_zero)
                __addPointFP2BN254_P2_continue:
        ; [steps: 20, bin: 8]

        ; P1 and P2 are not 𝒪, let's check whether they are different points, the same point or inverses of each other
        ; Is P1.x == P2.x?
        $ => A  :MLOAD(addPointFP2BN254_P1_x1)
        $ => B  :MLOAD(addPointFP2BN254_P2_x1)
        $       :EQ, JMPNC(addPointFP2BN254_different)
        $ => A  :MLOAD(addPointFP2BN254_P1_x2)
        $ => B  :MLOAD(addPointFP2BN254_P2_x2)
        $       :EQ, JMPNC(addPointFP2BN254_different)
        ; [steps: 26, bin: 10]

        ; Is P1.y == P2.y?
        $ => A  :MLOAD(addPointFP2BN254_P1_y1)
        $ => B  :MLOAD(addPointFP2BN254_P2_y1)
        $       :EQ, JMPNC(addPointFP2BN254_P1_and_P2_are_inverted)
        $ => A  :MLOAD(addPointFP2BN254_P1_y2)
        $ => B  :MLOAD(addPointFP2BN254_P2_y2)
        $       :EQ, JMPC(addPointFP2BN254_same, addPointFP2BN254_P1_and_P2_are_inverted)
        ; [steps: 32, bin: 12]

; Begin of branching
addPointFP2BN254_P1_is_zero:
        ; before (w.c.) -> [steps: 11, bin: 4]

        ; P3 = P2
        $ => A  :MLOAD(addPointFP2BN254_P2_x1)
        $ => B  :MLOAD(addPointFP2BN254_P2_x2)
        $ => C  :MLOAD(addPointFP2BN254_P2_y1)
        $ => D  :MLOAD(addPointFP2BN254_P2_y2)
        A       :MSTORE(addPointFP2BN254_P3_x1)
        B       :MSTORE(addPointFP2BN254_P3_x2)
        C       :MSTORE(addPointFP2BN254_P3_y1)
        D       :MSTORE(addPointFP2BN254_P3_y2), JMP(addPointFP2BN254_end)

        ; till the end -> [steps: 21, bin: 4]

addPointFP2BN254_P2_is_zero:
        ; before (w.c.) -> [steps: 20, bin: 8]

        ; P3 = P1
        $ => A  :MLOAD(addPointFP2BN254_P1_x1)
        $ => B  :MLOAD(addPointFP2BN254_P1_x2)
        $ => C  :MLOAD(addPointFP2BN254_P1_y1)
        $ => D  :MLOAD(addPointFP2BN254_P1_y2)
        A       :MSTORE(addPointFP2BN254_P3_x1)
        B       :MSTORE(addPointFP2BN254_P3_x2)
        C       :MSTORE(addPointFP2BN254_P3_y1)
        D       :MSTORE(addPointFP2BN254_P3_y2), JMP(addPointFP2BN254_end)

        ; till the end -> [steps: 30, bin: 8]

addPointFP2BN254_P1_and_P2_are_inverted:
        ; before (w.c.) -> [steps: 32, bin: 12]

        ; Check -P1.y == P2.y
        %BN254_P => A
        $ => B          :MLOAD(addPointFP2BN254_P1_y1)
        $ => C          :SUB
        $ => B          :MLOAD(addPointFP2BN254_P1_y2)
        $ => D          :SUB

        $ => A          :MLOAD(addPointFP2BN254_P2_y1)
        C               :ASSERT
        $ => A          :MLOAD(addPointFP2BN254_P2_y2)
        D               :ASSERT

        ; P3 = 𝒪
        0n      :MSTORE(addPointFP2BN254_P3_x1)
        0n      :MSTORE(addPointFP2BN254_P3_x2)
        0n      :MSTORE(addPointFP2BN254_P3_y1)
        0n      :MSTORE(addPointFP2BN254_P3_y2), JMP(addPointFP2BN254_end)

        ; till the end -> [steps: 47, bin: 14]
; End of branching

addPointFP2BN254_same:
        ; before (w.c.) -> [steps: 32, bin: 12]

        $ => A  :MLOAD(addPointFP2BN254_P1_y1)
        $ => B  :MLOAD(addPointFP2BN254_P1_y2)
        $ => C  :MLOAD(addPointFP2BN254_P1_y1)
        $ => D  :MLOAD(addPointFP2BN254_P1_y2), CALL(addFp2BN254)
        ; E + C·u = 2y
        ; [steps: 39, bin: 12, arith: 1]

        E => A
        C => B  :CALL(invFp2BN254)
        ; C + D·u = 1 / 2y
        ; [steps: 64, bin: 16, arith: 2]

        3n => A :CALL(scalarMulFp2BN254)
        ; E + C·u = 3/2y
        ; [steps: 69, bin: 16, arith: 3]

        $ => A  :MLOAD(addPointFP2BN254_P1_x1)
        $ => B  :MLOAD(addPointFP2BN254_P1_x2)
        C => D
        E => C  :CALL(mulFp2BN254)
        ; E + C·u = 3x/2y

        $ => A  :MLOAD(addPointFP2BN254_P1_x1)
        $ => B  :MLOAD(addPointFP2BN254_P1_x2)
        C => D
        E => C  :CALL(mulFp2BN254)
        ; E + C·u = lambda = 3x²/2y

        E       :MSTORE(addPointFP2BN254_lambda_x)
        C       :MSTORE(addPointFP2BN254_lambda_y), JMP(addPointFP2BN254_common_calculate)
        ; E + C·u = lambda
        ; [steps: 85, bin: 16, arith: 5]

addPointFP2BN254_different:
        ; block costs: [steps: 51, bin: 4, arith: 4]

        ; before (w.c.) ->  [steps: 26, bin: 10]

        $ => A  :MLOAD(addPointFP2BN254_P2_x1)
        $ => B  :MLOAD(addPointFP2BN254_P2_x2)
        $ => C  :MLOAD(addPointFP2BN254_P1_x1)
        $ => D  :MLOAD(addPointFP2BN254_P1_x2), CALL(subFp2BN254)
        ; E + C·u = P2.x - P1.x
        ; [steps: 33, bin: 10, arith: 1]

        E => A
        C => B  :CALL(invFp2BN254)
        ; C + D·u = 1 / (P2_x - P1_x)
        C       :MSTORE(addPointFP2BN254_lambda_x)
        D       :MSTORE(addPointFP2BN254_lambda_y)
        ; [steps: 60, bin: 14, arith: 2]

        $ => A  :MLOAD(addPointFP2BN254_P2_y1)
        $ => B  :MLOAD(addPointFP2BN254_P2_y2)
        $ => C  :MLOAD(addPointFP2BN254_P1_y1)
        $ => D  :MLOAD(addPointFP2BN254_P1_y2), CALL(subFp2BN254)
        ; E + C·u = P2.y - P1.y
        ; [steps: 67, bin: 14, arith: 3]

        $ => A  :MLOAD(addPointFP2BN254_lambda_x)
        $ => B  :MLOAD(addPointFP2BN254_lambda_y)
        C => D
        E => C  :CALL(mulFp2BN254)
        ; E + C·u = lambda = (P2_y - P1_y) / (P2_x - P1_x)

        E       :MSTORE(addPointFP2BN254_lambda_x)
        C       :MSTORE(addPointFP2BN254_lambda_y)

        0       :MSTORE(addPointFP2BN254_diff) ; Reset the flag
        ; [steps: 77, bin: 14, arith: 4]

addPointFP2BN254_common_calculate:
        ; block costs: [steps: 48, bin: 0, arith: 6]

        E => A
        C => B  :CALL(squareFp2BN254)
        ; E + C·u = lambda²
        ; [steps: 7, bin: 0, arith: 1]

        E => A
        C => B
        $ => C  :MLOAD(addPointFP2BN254_P1_x1)
        $ => D  :MLOAD(addPointFP2BN254_P1_x2), CALL(subFp2BN254)
        ; E + C·u = lambda² - P1.x

        E => A
        C => B
        $ => C  :MLOAD(addPointFP2BN254_P2_x1)
        $ => D  :MLOAD(addPointFP2BN254_P2_x2), CALL(subFp2BN254)
        ; E + C·u = lambda² - P1.x - P2.x
        ; [steps: 21, bin: 0, arith: 3]

        E           :MSTORE(addPointFP2BN254_P3_x1)
        C           :MSTORE(addPointFP2BN254_P3_x2)
        ; P3.x = lambda² - P1.x - P2.x

        $ => A  :MLOAD(addPointFP2BN254_P1_x1)
        $ => B  :MLOAD(addPointFP2BN254_P1_x2)
        C => D
        E => C  :CALL(subFp2BN254)
        ; E + C·u = P1.x - P3.x
        ; [steps: 30, bin: 0, arith: 4]

        $ => A  :MLOAD(addPointFP2BN254_lambda_x)
        $ => B  :MLOAD(addPointFP2BN254_lambda_y)
        C => D
        E => C  :CALL(mulFp2BN254)
        ; E + C·u = lambda·(P1.x - P3.x)
        ; [steps: 37, bin: 0, arith: 5]

        E => A
        C => B
        $ => C  :MLOAD(addPointFP2BN254_P1_y1)
        $ => D  :MLOAD(addPointFP2BN254_P1_y2), CALL(subFp2BN254)
        ; E + C·u = lambda·(P1.x - P3.x) - P1.y

        E           :MSTORE(addPointFP2BN254_P3_y1)
        C           :MSTORE(addPointFP2BN254_P3_y2)

        ; till the end -> ; [steps: 48, bin: 0, arith: 6]

addPointFP2BN254_end:
        $ => RR         :MLOAD(addPointFP2BN254_RR)
                        :RETURN