;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; addPointBN254:
;;             in: P1 = (P1.x1 + P1.x2·u, P1.y1 + P1.y2·u), P2 = (P2.x1 + P2.x2·u, P2.y1 + P2.y2·u) ∈ E'(Fp2)
;;             out: P3 = (P3.x1 + P3.x2·u, P3.y1 + P3.y2·u) = P1 + P2 ∈ E'(Fp2)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Since the curve is E'/Fp2: y² = x³ + 3/(9+u), there is no issue in representing the point at infinity as (0, 0).

VAR GLOBAL addPointBN254_P1_x1
VAR GLOBAL addPointBN254_P1_x2
VAR GLOBAL addPointBN254_P1_y1
VAR GLOBAL addPointBN254_P1_y1_double
VAR GLOBAL addPointBN254_P1_y2
VAR GLOBAL addPointBN254_P1_y2_double
VAR GLOBAL addPointBN254_P2_x1
VAR GLOBAL addPointBN254_P2_x2
VAR GLOBAL addPointBN254_P2_y1
VAR GLOBAL addPointBN254_P2_y2
VAR GLOBAL addPointBN254_P3_x1
VAR GLOBAL addPointBN254_P3_x2
VAR GLOBAL addPointBN254_P3_y1
VAR GLOBAL addPointBN254_P3_y2
VAR GLOBAL addPointBN254_lambda_x
VAR GLOBAL addPointBN254_lambda_y
VAR GLOBAL addPointBN254_RR

addPointBN254:
        RR      :MSTORE(addPointBN254_RR)

        ; Check if P1 = 0
        ${Fp2BN254neq0(mem.addPointBN254_P1_x1) || Fp2BN254neq0(mem.addPointBN254_P1_x2) || Fp2BN254neq0(mem.addPointBN254_P1_y1) || Fp2BN254neq0(mem.addPointBN254_P1_y2)}   :JMPZ(addPointBN254_P1_is_zero)
        
        ; Check if P2 = 0
        ${Fp2BN254neq0(mem.addPointBN254_P2_x1) || Fp2BN254neq0(mem.addPointBN254_P2_x2) || Fp2BN254neq0(mem.addPointBN254_P2_y1) || Fp2BN254neq0(mem.addPointBN254_P2_y2)}   :JMPZ(addPointBN254_P2_is_zero)

        ; P1 and P2 are not 0, let's check whether they are different points, the same point or inverses of each other
        $ => A  :MLOAD(addPointBN254_P1_x1)
        $ => B  :MLOAD(addPointBN254_P1_x2)
        $ => C  :MLOAD(addPointBN254_P2_x1)
        $ => D  :MLOAD(addPointBN254_P2_x2)

        ; check P1.x == P2.x
        ${(A == C) && (B == D)}     :JMPZ(addPointBN254_different)
        C                           :ASSERT
        B => A                  
        D                           :ASSERT

        $ => A  :MLOAD(addPointBN254_P1_y1)
        $ => B  :MLOAD(addPointBN254_P1_y2)
        $ => C  :MLOAD(addPointBN254_P2_y1)
        $ => D  :MLOAD(addPointBN254_P2_y2)

        ; check P1.y == P2.y
        ${(A == C) && (B == D)}     :JMPZ(addPointBN254_end)
        C                           :ASSERT
        B => A                  
        D                           :ASSERT

        ; P1 == P2
                                    :JMP(addPointBN254_same)

addPointBN254_P1_is_zero:
        ; Check that P1 is zero
        0n => B
        $ => A  :MLOAD(addPointBN254_P1_x1)
        1       :EQ
        $ => A  :MLOAD(addPointBN254_P1_x2)
        1       :EQ
        $ => A  :MLOAD(addPointBN254_P1_y1)
        1       :EQ
        $ => A  :MLOAD(addPointBN254_P1_y2)
        1       :EQ

        ; P3 = P2
        $ => A  :MLOAD(addPointBN254_P2_x1)
        $ => B  :MLOAD(addPointBN254_P2_x2)
        $ => C  :MLOAD(addPointBN254_P2_y1)
        $ => D  :MLOAD(addPointBN254_P2_y2)
        A       :MSTORE(addPointBN254_P3_x1)
        B       :MSTORE(addPointBN254_P3_x2)
        C       :MSTORE(addPointBN254_P3_y1)
        D       :MSTORE(addPointBN254_P3_y2)

                :JMP(addPointBN254_end)

addPointBN254_P2_is_zero:
        ; Check that P2 is zero
        0n => B
        $ => A  :MLOAD(addPointBN254_P2_x1)
        1       :EQ
        $ => A  :MLOAD(addPointBN254_P2_x2)
        1       :EQ
        $ => A  :MLOAD(addPointBN254_P2_y1)
        1       :EQ
        $ => A  :MLOAD(addPointBN254_P2_y2)
        1       :EQ

        ; P3 = P1
        $ => A  :MLOAD(addPointBN254_P1_x1)
        $ => B  :MLOAD(addPointBN254_P1_x2)
        $ => C  :MLOAD(addPointBN254_P1_y1)
        $ => D  :MLOAD(addPointBN254_P1_y2)
        A       :MSTORE(addPointBN254_P3_x1)
        B       :MSTORE(addPointBN254_P3_x2)
        C       :MSTORE(addPointBN254_P3_y1)
        D       :MSTORE(addPointBN254_P3_y2)

                :JMP(addPointBN254_end)    

addPointBN254_same:        
        $ => A  :MLOAD(addPointBN254_P1_y1)
        $ => B  :MLOAD(addPointBN254_P1_y2)
        $ => C  :MLOAD(addPointBN254_P1_y1)
        $ => D  :MLOAD(addPointBN254_P1_y2)
                :CALL(addFp2BN254)
        ; E + C·u = 2y

        E => A
        C => B
                :CALL(invFp2BN254)
        ; C + D·u = 1 / 2y

        3n => A 
                :CALL(escalarMulFp2BN254)
        ; E + C·u = 3/2y

        $ => A  :MLOAD(addPointBN254_P1_x1)
        $ => B  :MLOAD(addPointBN254_P1_x2)
        C => D
        E => C
                :CALL(mulFp2BN254)
        ; E + C·u = 3x/2y

        $ => A  :MLOAD(addPointBN254_P1_x1)
        $ => B  :MLOAD(addPointBN254_P1_x2)
        C => D
        E => C
                :CALL(mulFp2BN254)
        ; E + C·u = lambda = 3x²/2y

        E       :MSTORE(addPointBN254_lambda_x)
        C       :MSTORE(addPointBN254_lambda_y)
        ; E + C·u = lambda

        E => A
        C => B
                :CALL(squareFp2BN254)
        ; E + C·u = lambda²

        E => A  
        C => B  
        $ => C  :MLOAD(addPointBN254_P1_x1)
        $ => D  :MLOAD(addPointBN254_P1_x2)
                :CALL(subFp2BN254)
        ; E + C·u = lambda² - x

        E => A  
        C => B  
        $ => C  :MLOAD(addPointBN254_P1_x1)
        $ => D  :MLOAD(addPointBN254_P1_x2)
                :CALL(subFp2BN254)
        ; E + C·u = lambda² - x - x

                :JMP(addPointBN254_common_calculate)

addPointBN254_different:
        $ => A  :MLOAD(addPointBN254_P2_x1)
        $ => B  :MLOAD(addPointBN254_P2_x2)
        $ => C  :MLOAD(addPointBN254_P1_x1)
        $ => D  :MLOAD(addPointBN254_P1_x2)
                :CALL(subFp2BN254)
        ; E + C·u = P2.x - P1.x

        E => A
        C => B
                :CALL(invFp2BN254)
        ; C + D·u = 1 / (P2_x - P1_x)
        C       :MSTORE(addPointBN254_lambda_x)
        D       :MSTORE(addPointBN254_lambda_y)

        $ => A  :MLOAD(addPointBN254_P2_y1)
        $ => B  :MLOAD(addPointBN254_P2_y2)
        $ => C  :MLOAD(addPointBN254_P1_y1)
        $ => D  :MLOAD(addPointBN254_P1_y2)
                :CALL(subFp2BN254)
        ; E + C·u = P2.y - P1.y

        $ => A  :MLOAD(addPointBN254_lambda_x)
        $ => B  :MLOAD(addPointBN254_lambda_y)
        C => D
        E => C
                :CALL(mulFp2BN254)
        ; E + C·u = lambda = (P2_y - P1_y) / (P2_x - P1_x)
        E       :MSTORE(addPointBN254_lambda_x)
        C       :MSTORE(addPointBN254_lambda_y)

        E => A
        C => B
                :CALL(squareFp2BN254)
        ; E + C·u = lambda² 

        E => A
        C => B
        $ => C  :MLOAD(addPointBN254_P1_x1)
        $ => D  :MLOAD(addPointBN254_P1_x2)
                :CALL(subFp2BN254)
        ; E + C·u = lambda² - P1.x

        E => A
        C => B
        $ => C  :MLOAD(addPointBN254_P2_x1)
        $ => D  :MLOAD(addPointBN254_P2_x2)
                :CALL(subFp2BN254)
        ; E + C·u = lambda² - P1.x - P2.x

addPointBN254_common_calculate:

        E           :MSTORE(addPointBN254_P3_x1)
        C           :MSTORE(addPointBN254_P3_x2)    
        ; P3.x = lambda² - P1.x - P2.x   
 
        $ => A  :MLOAD(addPointBN254_P1_x1)
        $ => B  :MLOAD(addPointBN254_P1_x2)
        C => D
        E => C
                :CALL(subFp2BN254)
        ; E + C·u = P1.x - P3.x

        $ => A  :MLOAD(addPointBN254_lambda_x)
        $ => B  :MLOAD(addPointBN254_lambda_y)
        C => D
        E => C
                :CALL(mulFp2BN254)
        ; E + C·u = lambda·(P1.x - P3.x) 

        E => A  
        C => B  
        $ => C  :MLOAD(addPointBN254_P1_y1)
        $ => D  :MLOAD(addPointBN254_P1_y2)
                :CALL(subFp2BN254)
        ; E + C·u = lambda·(P1.x - P3.x) - P1.y

        E           :MSTORE(addPointBN254_P3_y1)
        C           :MSTORE(addPointBN254_P3_y2)

addPointBN254_end:

        $ => RR         :MLOAD(addPointBN254_RR)
                        :RETURN