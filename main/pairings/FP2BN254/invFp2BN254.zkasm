;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; POST: ARITH_BN254_MULFP2 ensures that the result is in the range [0,BN254_P)
;;
;; invFp2BN254
;;             in: (A + B·u) ∈ Fp2, where A,B ∈ Fp
;;             out: C + D·u = (A·(A² + B²)⁻¹) + (-B·(A² + B²)⁻¹)·u ∈ Fp2
;;
;; NOTE: On input 0, it returns 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

VAR GLOBAL invFp2BN254_x
VAR GLOBAL invFp2BN254_y

VAR GLOBAL invFp2BN254_RR

; RESOURCES:
; -------------------------------------------
; PATH 1 A,B < p: [steps: 3,  bin: 1] + [steps: 4,  bin: 1] +
;       PATH 1.1 A == 0 (p): [steps: 5, bin: 2] +
;               PATH 1.1.1 B == 0 (p): [steps: 3]
;               PATH 1.1.2 B != 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3] = [steps: 23, bin: 4, arith: 1]
;       PATH 1.2 A != 0 (p): [steps: 3, bin: 1] +
;               PATH 1.2.1 B == 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]
;               PATH 1.2.2 B != 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]

; PATH 2 A < p, B > p: [steps: 3,  bin: 1] + [steps: 14, bin: 2, arith: 1] +
;       PATH 2.1 A == 0 (p): [steps: 5, bin: 2] +
;               PATH 2.1.1 B == 0 (p): [steps: 3]
;               PATH 2.1.2 B != 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]
;       PATH 2.2 A != 0 (p): [steps: 3, bin: 1] +
;               PATH 2.2.1 B == 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]
;               PATH 2.2.2 B != 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]

; PATH 3 A > p, B < p: [steps: 13, bin: 2, arith: 1] + [steps: 4,  bin: 1] +
;       PATH 3.1 A == 0 (p): [steps: 5, bin: 2] +
;               PATH 3.1.1 B == 0 (p): [steps: 3]
;               PATH 3.1.2 B != 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]
;       PATH 3.2 A != 0 (p): [steps: 3, bin: 1] +
;               PATH 3.2.1 B == 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]
;               PATH 3.2.2 B != 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]

; PATH 4 A,B > p: [steps: 13, bin: 2, arith: 1] + [steps: 14, bin: 2, arith: 1] +
;       PATH 4.1 A == 0 (p): [steps: 5, bin: 2] +
;               PATH 4.1.1 B == 0 (p): [steps: 3]
;               PATH 4.1.2 B != 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3] = [steps: 43, bin: 6, arith: 3] <--- w.c.
;       PATH 4.2 A != 0 (p): [steps: 3, bin: 1] +
;               PATH 4.2.1 B == 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]
;               PATH 4.2.2 B != 0 (p): [steps: 8, bin: 0, arith: 1] + [steps: 3]
; -------------------------------------------

invFp2BN254:
        RR              :MSTORE(invFp2BN254_RR)

        B               :MSTORE(invFp2BN254_y)

        ; [steps: 2]

; Normalization of A,B
invFp2BN254_norm_A:
        ; block counters:
        ; A > p -> [steps: 13, bin: 2, arith: 1]
        ; A < p -> [steps: 3,  bin: 1]

        %BN254_P => B
        $               :LT, JMPC(__invFp2BN254_reduce_A_continue)
                        :CALL(reduceFpBN254)
                        __invFp2BN254_reduce_A_continue:
        A               :MSTORE(invFp2BN254_x)

invFp2BN254_norm_B:
        ; block counters:
        ; B > p -> [steps: 14, bin: 2, arith: 1]
        ; B < p -> [steps: 4,  bin: 1]

        $ => A          :MLOAD(invFp2BN254_y)
        %BN254_P => B
        $               :LT, JMPC(__invFp2BN254_reduce_B_continue)
                        :CALL(reduceFpBN254)
                        __invFp2BN254_reduce_B_continue:
        A               :MSTORE(invFp2BN254_y)
        ; From here, it is guaranteed that A,B ∈ [0,BN254_P)

invFp2BN254_zero_check:
        ; block counters:
        ; A == 0 -> [steps: 5, bin: 2]
        ; A != 0 -> [steps: 3, bin: 1]

        ; Check if A = B = 0, and if so, return 0
        $ => B          :MLOAD(invFp2BN254_x)
        0 => A
        $               :EQ, JMPNC(invFp2BN254_normalized)
        $ => B          :MLOAD(invFp2BN254_y)
        $               :EQ, JMPC(invFp2BN254_input_is_zero)

invFp2BN254_normalized:
        ; block counters till end: [steps: 8, bin: 0, arith: 1]

        $ => A          :MLOAD(invFp2BN254_x)
        $ => B          :MLOAD(invFp2BN254_y)
        ; Remember that an element y ∈ Fp2 is the inverse of x ∈ Fp2 if and only if x·y = 1 in Fp2
        ; We therefore check that (A + B·u)·(C + D·u) = 1 + 0·u
        ; A·[C] - B·[D] = 1 + (q0·BN254_P)
        ; A·[D] + B·[C] = 0 + (q1·BN254_P)
        ${fp2InvBN254_x(mem.invFp2BN254_x,mem.invFp2BN254_y)} => C
        ${fp2InvBN254_y(mem.invFp2BN254_x,mem.invFp2BN254_y)} => D
        1n => E
        0n                      :ARITH_BN254_MULFP2, JMP(invFp2BN254_end)

invFp2BN254_input_is_zero:
        0 => C,D

invFp2BN254_end:
        $ => RR         :MLOAD(invFp2BN254_RR)
                        :RETURN