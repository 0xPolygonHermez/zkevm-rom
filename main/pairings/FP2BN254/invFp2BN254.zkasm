;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: A,B are assumed to be in the range [0,BN254_P)
;; POST: ARITH_BN254_MULFP2 ensures that the result is in the range [0,BN254_P)
;;
;; invFp2BN254
;;             in: (A + B·u) ∈ Fp2, where A,B ∈ Fp
;;             out: C + D·u = (A·(A² + B²)⁻¹) + (-B·(A² + B²)⁻¹)·u ∈ Fp2
;;
;; NOTE: On input 0, it returns 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; RESOURCES:
; -------------------------------------------
; PATH 1 A,B == 0:       [steps: 3,  bin: 0, arith: 0]
; PATH 2 A != 0, B == 0: [steps: 16, bin: 3, arith: 1]
; PATH 3 A,B != 0:       [steps: 18, bin: 4, arith: 1] <-- w.c.
; -------------------------------------------

VAR GLOBAL invFp2BN254_x
VAR GLOBAL invFp2BN254_y

invFp2BN254:
        ; Check if A = B = 0, and if so, return 0
        ${checkIfZero(A,B)}     :JMPNZ(invFp2BN254_input_is_zero)

        A               :MSTORE(invFp2BN254_x)
        B               :MSTORE(invFp2BN254_y)

invFp2BN254_zero_check:

        0 => A
        $               :EQ, JMPNC(invFp2BN254_normalized)
        $ => B          :MLOAD(invFp2BN254_x)
        0               :EQ
        ; From here, either A != 0 or B != 0

invFp2BN254_normalized:
        $ => A          :MLOAD(invFp2BN254_x)
        $ => B          :MLOAD(invFp2BN254_y)
        ; Remember that an element y ∈ Fp2 is the inverse of x ∈ Fp2 if and only if x·y = 1 in Fp2
        ; We therefore check that (A + B·u)·(C + D·u) = 1 + 0·u
        ; A·[C] - B·[D] = 1 + (q0·BN254_P)
        ; A·[D] + B·[C] = 0 + (q1·BN254_P)
        ${fp2InvBN254_x(mem.invFp2BN254_x,mem.invFp2BN254_y)} => C
        ${fp2InvBN254_y(mem.invFp2BN254_x,mem.invFp2BN254_y)} => D
        1n => E
        0n                      :ARITH_BN254_MULFP2

        ; Check that the resulting elements are lower than BN254_P
        %BN254_P => B
        C => A
        1               :LT
        D => A
        1               :LT, RETURN

invFp2BN254_input_is_zero:
        0 => C,D        :ASSERT
        B               :ASSERT, RETURN