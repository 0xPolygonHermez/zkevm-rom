
processTx:

        ; We get a new hashId
        $ => E                          :MLOAD(lastHashIdUsed)
        E+1 => E                        :MSTORE(lastHashIdUsed)
        0 => C

;;;;;;;;;
;; Signaure Verification
;;;;;;;;;

        ; Check the signature
        $ => A                          :HASHR(E)
        $ => B                          :MLOAD(txR)
        $ => C                          :MLOAD(txS)
        $ => D                          :MLOAD(txV)
        $ => A                          :ECRECOVER
        A                               :MSTORE(txSrcAddr)
        A                               :MSTORE(txSrcOriginAddr)

;;;;;;;;;
;; Store init state
;;;;;;;;;

        SR                              :MSTORE(initSR)

;;;;;;;;
; Check chainID
;;;;;;;;
        $ => A                          :MLOAD(txChainId)                                       ; A: chainId tx
        $ => B                          :MLOAD(chainId)                                         ; B: chainId
        A-B                             :JMPC(check_defaultChainId)                             ; If A - B < 0, A is not equal to B --> check defaultChainId
        B-A                             :JMPC(check_defaultChainId)                             ; If B - A < 0, A is not equal to B --> check defaultChainId
                                        :JMP(endCheckChainId)
check_defaultChainId:
        $ => B                          :MLOAD(defaultChainId)                                  ; B: defaultChainId, A: chainId tx
        A-B                             :JMPC(invalidTx)                                        ; If A - B < 0, A is not equal to B --> check defaultChainId
        B-A                             :JMPC(invalidTx)                                        ; If A - B < 0, A is not equal to B --> check defaultChainId
                                        :JMP(endCheckChainId)

endCheckChainId:

;;;;;;;;
; Check and update Nonce
;;;;;;;;

        $ => A, E                       :MLOAD(txSrcOriginAddr)                                 ; Address of the origin to a and D
        1 => B                                                                                  ; Constance for nonce
        0 => C                                                                                  ; 3rd parameter does not apply to nonce
        $ => A                          :SLOAD                                                  ; Load the nonce to A and C from storage
        $ => B                          :MLOAD(txNonce)
        B-A                             :JMPC(invalidTx)                                        ; Compare "nonce storage" (A) and "nonce tx" (B). If -A+B < 0 --> invalidTx, further check A-B < 0.
        A-B                             :JMPC(invalidTx)                                        ; Compare "nonce storage" (A) and "nonce tx" (B). If -B+A < 0 --> invalidTx.
        B                               :ASSERT
        A+1 => D                                                                                ; Set to A the current address
        E => A
        1 => B                                                                                  ; Constance for nonce
        0 => C
        $   => SR                       :SSTORE                                                 ; Store the nonce plus one


;;;;;;;;
; Buy Gas
;;;;;;;;

        $ => A                          :MLOAD(txGas)                                           ; Multiplies the txGas amd the txGasPrice 
        $ => B                          :MLOAD(txGasPrice)
        0 => C
        0 => D                                                                                  ; Forces no overflow 
        ${A*B} => D                     :ARITH                                                                                  ; gas*gasPrice in D

        $ => A                          :MLOAD(txSrcOriginAddr)
        0 => B,C
        $ => E                          :SLOAD                                                  ; Original Balance in E
        E                               :MSTORE(initSrcOriginBalance)
        D => C                                                                                  ; A = E - C
        ${E-C} => A
        31 => D
        $ => B                          :SHR
        0x7F - B                        :JMPC(invalidTx)                                       ; If A is a negative value --> invalidTx
        1 => B
        0 => D
        E                                :ARITH                                                 ; originalBalance -gas*gasPrice in A

        A => D                                                                                  ; originalBalance -gas*gasPrice in D

        $ => A                          :MLOAD(txSrcOriginAddr)
        0 => B,C
        $ => SR                         :SSTORE

;;;;;;;;
; Set the gas
;;;;;;;;

        $ => GAS                        :MLOAD(txGas)
        GAS - 21000 => GAS

;;;;;;;;
; Gas calldata
;;;;;;;;
        $ => A                          :MLOAD(txNData)
        A - 1                           :JMPC(txType)
        0 => D
        -1 => C

addGas:
        C + 1 => C
        0 => D
        1024 + C => SP
                                        :JMP(loopBytes)
loopBytes:
        A - ${C*32} - D - 1             :JMPC(txType)
        32 - D - 1                      :JMPC(addGas)
        $ => B                          :MLOAD(SP)
        ${getByte(B,D)} => B
        D + 1 => D
        B - 1                           :JMPC(add4Gas)
                                        :JMP(add16Gas)

add4Gas:
        GAS - 4 => GAS
                                        :JMP(loopBytes)

add16Gas:
        GAS - 16 => GAS
                                        :JMP(loopBytes)
txType:
;;;;;;;;;;
;;;;; Tx type
;;;;;;;;;;
        $ => A                          :MLOAD(txIsCreateContract)
        0 - A                           :JMPC(deploy)
        $ => A                          :MLOAD(txDestAddr)
        2 => B
        0 => C
        $ => A                          :SLOAD
        0 => D

checkTxType:
        32 - D                          :JMPC(moveBalances)
        ${getByte(A,D)} => B
        0 - B                           :JMPC(callContract)
        D + 1 => D
                                        :JMP(checkTxType)

deploy:
        1024                            :MSTORE(SPr)
        0                               :MSTORE(SPw)
        0 => PC
        0 => SP
        GAS - 32000 => GAS
                                        :JMP(readCode)

readDeployBytecode:
        SP                              :MSTORE(SPw)
        $ => SP                         :MLOAD(SPr)
        SP + ${PC/32} => SP
        ${PC%32} => C
        $ => B                          :MLOAD(txNData)
        B - PC                          :JMPC(endDeploy)
        $ => A                          :MLOAD(SP)
        $ => SP                         :MLOAD(SPw)
        ${getByte(A,C)} => B
        ${addrOp(B)} => E
        PC + 1 => PC
                                        :JMP(E)

callContract:
        0 => PC
        0 => SP
                                        :JMP(readCode)

readByteCode:
        $ => A                          :MLOAD(txDestAddr)
        2 => B
        0 => C
        $ => A                          :SLOAD
        ${getBytecodeLength(A)} => B
        B - PC                          :JMPC(endByteCode)
        ${getBytecode(A,PC)} => B
        ${addrOp(B)} => E
        PC + 1 => PC
                                        :JMP(E)

readCode:
        $ => A                          :MLOAD(txIsCreateContract)
        0 - A                           :JMPC(readDeployBytecode)
                                        :JMP(readByteCode)

endCode:
        $ => A                          :MLOAD(txIsCreateContract)
        0 - A                           :JMPC(endDeploy)
                                        :JMP(endByteCode)

endDeploy:
        ; Update contract nonce
        $ => A                          :MLOAD(txSrcOriginAddr)
        $ => B                          :MLOAD(txNonce)
        ${getContractAddress(A,B)} => A
        1 => B                                                                                  ; Constance for nonce
        0 => C
        1 => D
        $ => SR                         :SSTORE

        $ => A                          :MLOAD(txSrcOriginAddr)
        $ => B                          :MLOAD(txNonce)
        ${getHashBytecode(A,B)} => D
        ${getContractAddress(A,B)} => A
        2 => B
        0 => C
        $ => SR                         :SSTORE

endByteCode:

moveBalances:

;;;;;;;;
; evmCALL (Move Balances)
;;;;;;;;

        ; Decrement original balance
        $ => A                          :MLOAD(txSrcAddr)
        0 => B,C
        $ => E                          :SLOAD                                                  ; Original Balance in E
        E                               :MSTORE(initSrcBalance)
        $ => C                          :MLOAD(txValue)                                         ; A = E - C
        ${E-C} => A
        31 => D
        $ => B                          :SHR
        0x7F - B                        :JMPC(invalidTx)                                        ; If A is a negative value --> invalidTx
        1 => B 
        0 => D
        E                               :ARITH                                                  ; originalBalance -value in A

        A => D                                                                                  ; originalBalance -value in D

        $ => A                          :MLOAD(txSrcAddr)
        0 => B,C
        $ => SR                         :SSTORE

        ; Increment destination balance
        $ => A                          :MLOAD(txDestAddr)
        0 => B,C
        $ => C                          :SLOAD                                                  ; Original Balance in E

        $ => A                          :MLOAD(txValue)                                         ; E = A + C
        1 => B
        0 => D
        ${A+C} => D                     :ARITH                                                  ; originalBalance + value in D

        $ => A                          :MLOAD(txDestAddr)
        0 => B,C
        $ => SR                         :SSTORE



;;;;;;;;
; Refund GAS
;;;;;;;;

        0 => A
        $ => B                          :MLOAD(gasRefund)
        B - 1                           :JMPC(refundGas)
        $ => A                          :MLOAD(txGas)
        A - GAS => A
        ${A/2} => A
        A - B                           :JMPC(refundGas)
        B => A

refundGas:
        GAS + A => GAS
        GAS => A
        $ => B                          :MLOAD(txGasPrice)
        0 => C                          
        0 => D                                                                                  ; Forces no overflow 
        ${A*B} => D                     :ARITH                                                  ; valueToReturn in D

        $ => A                          :MLOAD(txSrcOriginAddr)
        0 => B,C
        $ => A                          :SLOAD                                                  ; Original Balance in A

        1 => B
        D => C
        0 => D
        ${A+C} => D                     :ARITH                                                  ; New Balance in D

        $ => A                          :MLOAD(txSrcOriginAddr)
        0 => B,C
        $ => SR                         :SSTORE

;;;;;;;;
; Send remaining gas to sequencer
;;;;;;;;

        $ => A                          :MLOAD(txGas)                                           ; Multiplies the txGas amd the txGasPrice
        A - GAS => A                                                                            ; A = txGas -GAS

        $ => B                          :MLOAD(txGasPrice)
        0 => C                          
        0 => D                                                                                  ; Forces no overflow 
        ${A*B} => D                     :ARITH                                                  ; value to pay the sequencer in D

        $ => A                          :MLOAD(sequencerAddr)
        0 => B,C
        $ => A                          :SLOAD                                                  ; Original Balance in A

        1 => B
        D => C
        0 => D
        ${A+C} => D                     :ARITH                                                   ; New Balance in D

        $ => A                          :MLOAD(sequencerAddr)
        0 => B,C
        $ => SR                         :SSTORE                                         


terminateTX:

                                        :JMP(processTxEnd)

invalidTx:
        $ => SR                         :MLOAD(initSR)
                                        :JMP(terminateTX)
