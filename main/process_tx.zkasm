
processTx:

;;;;;;;;
; Check chainID
;;;;;;;;
        $ => A                          :MLOAD(txChainId)             ; A: chainId tx
        $ => B                          :MLOAD(chainId)               ; B: chainId
        A-B                             :JMPC(check_defaultChainId)   ; If A - B < 0, A is not equal to B --> check defaultChainId
        B-A                             :JMPC(check_defaultChainId)   ; If B - A < 0, A is not equal to B --> check defaultChainId
                                        :JMP(endChainId)
check_defaultChainId:
        $ => B                          :MLOAD(defaultChainId)        ; B: defaultChainId, A: chainId tx
        A-B                             :JMPC(invalidTx)              ; If A - B < 0, A is not equal to B --> check defaultChainId
        B-A                             :JMPC(invalidTx)              ; If A - B < 0, A is not equal to B --> check defaultChainId
                                        :JMP(endChainId)

endChainId:

;;;;;;;;
; Check and update Nonce
;;;;;;;;

        $ => A, E                       :MLOAD(txSrcOriginAddr)                                 ; Address of the origin to a and D
        1 => B                                                                                  ; Constance for nonce
        0 => C                                                                                  ; 3rd parameter does not apply to nonce
        $ => A                          :SLOAD                                                  ; Load the nonce to A and C from storage
        $                               :MLOAD(txNonce), ASSERT                                 ; Check the txNonce matches  TODO: JMP to invalid TX
        A+1 => D                                                                                ; Set to A the current address
        E   => A
        $   => SR                       :SSTORE                                                 ; Store the nonce plus one


;;;;;;;;
; Buy Gas
;;;;;;;;

        $ => A                          :MLOAD(txGas)                                           ; Multiplies the txGas amd the txGasPrice 
        $ => B                          :MLOAD(txGasPrice)
        0 => C                          
        0 => D                                                                                  ; Forces no overflow 
        ${A*B} => D                     :ARITH                                                  ; gas*gasPrice in D

        $ => A                          :MLOAD(txSrcOriginAddr)
        0 => B,C
        $ => E                          :SLOAD                                                  ; Original Balance in E

        D => C                                                                                  ; A = E - C
        1 => B 
        0 => D
        ${E-C} => A                     
        E                                :ARITH                                                 ; originalBalance -gas*gasPrice in A

        A => D                                                                                  ; originalBalance -gas*gasPrice in D

        $ => A                          :MLOAD(txSrcOriginAddr)
        0 => B,C
        $ => SR                         :SSTORE

;;;;;;;;
; Set the gas
;;;;;;;;

        $ => GAS                        :MLOAD(txGas)

;;;;;;;;
; evmCALL (Move Balances)
;;;;;;;;

        GAS - 21000 => GAS

        ; Decrement original balance
        $ => A                          :MLOAD(txSrcAddr)
        0 => B,C
        $ => E                          :SLOAD                                                  ; Original Balance in E

        $ => C                          :MLOAD(txValue)                                         ; A = E - C
        1 => B 
        0 => D
        ${E-C} => A                     
        E                               :ARITH                                                  ; originalBalance -value in A

        A => D                                                                                  ; originalBalance -value in D

        $ => A                          :MLOAD(txSrcAddr)
        0 => B,C
        $ => SR                         :SSTORE

        ; Increment destination balance
        $ => A                          :MLOAD(txDestAddr)
        0 => B,C
        $ => C                          :SLOAD                                                  ; Original Balance in E

        $ => A                          :MLOAD(txValue)                                         ; E = A + C
        1 => B 
        0 => D
        ${A+C} => D                     :ARITH                                                  ; originalBalance + value in D

        $ => A                          :MLOAD(txDestAddr)
        0 => B,C
        $ => SR                         :SSTORE



;;;;;;;;
; Refund GAS
;;;;;;;;

        ; We assume gas is exact

        GAS => A
        $ => B                          :MLOAD(txGasPrice)
        0 => C                          
        0 => D                                                                                  ; Forces no overflow 
        ${A*B} => D                     :ARITH                                                  ; valueToReturn in D

        $ => A                          :MLOAD(txSrcOriginAddr)
        0 => B,C
        $ => A                          :SLOAD                                                  ; Original Balance in A

        1 => B
        D => C
        0 => D
        ${A+C} => D                     :ARITH                                                  ; New Balance in D

        $ => A                          :MLOAD(txSrcOriginAddr)
        0 => B,C
        $ => SR                         :SSTORE

;;;;;;;;
; Send remaining gas to sequencer
;;;;;;;;

        $ => A                          :MLOAD(txGas)                                           ; Nultiplies the txGas amd the txGasPrice 
        -GAS => B
        A+B => A                                                                                ; A = txGas -GAS

        $ => B                          :MLOAD(txGasPrice)
        0 => C                          
        0 => D                                                                                  ; Forces no overflow 
        ${A*B} => C                     :ARITH                                                  ; valueToAccumulate in C

        $ => A                          :MLOAD(sequencerAccValue)
        1 => B
        0 => D
        ${A+C} => A                     :ARITH, MSTORE(sequencerAccValue)                                                


terminateTX:

                                        :JMP(processTxEnd)

invalidTx:
                                        :JMP(processTxEnd)


