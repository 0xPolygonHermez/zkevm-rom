processChangeL2Block:

    ; checks zk-counters
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - %MAX_CNT_POSEIDON_SLOAD_SSTORE*6     :JMPN(outOfCountersPoseidon)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - 1                                        :JMPN(outOfCountersKeccak)
    %MAX_CNT_STEPS - STEP - 500                                                 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 7                                            :JMPN(outOfCountersBinary)

    ; If it is not the first transaction, we must consolidate previous block
    $ => A                              :MLOAD(currentTx)
    A - 1                               :JMPZ(continueProcessChangeL2Block)
                                        :CALL(consolidateBlock)

continueProcessChangeL2Block:
    $${eventLog(onStartBlock)}
    ; Reset tx index, logIndex and cumulative gas used
    0                                   :MSTORE(txIndex)
    0                                   :MSTORE(cumulativeGasUsed)
    0                                   :MSTORE(currentLogIndex)
    ;; Set block hash (current state root) on storage
    ; Update state root mapping
    32 => D
    0 => HASHPOS ; A new hash with position 0 is started
    $ => E                              :MLOAD(nextHashKId)
    E + 1                               :MSTORE(nextHashKId)

    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    ${mem.blockNum}                     :HASHK(E), MLOAD(blockNum)
    %STATE_ROOT_STORAGE_POS             :HASHK(E)
    HASHPOS                             :HASHKLEN(E)
    $ => C                              :HASHKDIGEST(E)
    SR => D                             :MSTORE(previousBlockHash)
    $ => SR                             :SSTORE, CALL(initBlockInfoTree)

    ; Read block number, increase it by 1 and write it
    ; Get last block number
    $ => A                              :MLOAD(blockNum)

    ; Update last block number at system storage
    1 => B
    $ => D                              :ADD, MSTORE(blockNum)
    %LAST_BLOCK_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => SR                             :SSTORE

    ; Load current timestamp
    $ => A                              :MLOAD(timestamp) ; currentTimestamp => A

    ; If it is NOT a forced tx ==> verify Timestamp & L1InfoRoot
    $                                   :MLOAD(isForced), JMPZ(verifyTimestampAndL1InfoRoot)

    ; forced batch
    ;   - update timestamp only if currentTimestamp < limitTimestamp
    ;   - set blockHash to default
    $ => C                              :MLOAD(forcedBlockHashL1InfoTree)
    C                                   :MSTORE(blockHashL1InfoTree)
    $ => B                              :MLOAD(forcedTimestamp)
    $                                   :LT, JMPC(setNewTimestamp, initSetGERL1InfoTree)

verifyTimestampAndL1InfoRoot:
    $ => B                              :MLOAD(deltaTimestamp)
    ; Addition of two values of 8 bytes [B: currentTimestamp(A) + deltaTimestamp(B)]
    $ => B                              :ADD, MSTORE(timestamp)

    ; Set new timestamp
    %TIMESTAMP_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => D                              :MLOAD(timestamp)
    $ => SR                             :SSTORE

    ; check indexL1InfoTree != 0 to verify data L1InfoTree
    $ => A                                              :MLOAD(indexL1InfoTree), JMPZ(skipSetGERL1InfoTree)
    ; Verify indexL1InfoTree > currentL1InfoTreeIndex
    A - $ - 1                                           :F_MLOAD(currentL1InfoTreeIndex), JMPN(invalidL1InfoTreeIndex)
    ${getL1InfoGER(mem.indexL1InfoTree)}                :MSTORE(gerL1InfoTree)
    ${getL1InfoBlockHash(mem.indexL1InfoTree)}          :MSTORE(blockHashL1InfoTree)
    ${getL1InfoMinTimestamp(mem.indexL1InfoTree)} => B  :MSTORE(timestampL1InfoTree)
    ; Verify (currentTimestamp + deltaTimestamp) >= l1InfoRoot.minTimestamp
    $ => A                                              :MLOAD(timestamp)
    $                                                   :LT, JMPC(invalidChangeL2BlockMinTimestamp)
    ; Compute infoTreeData
                                            :CALL(computeL1InfoTreeValue)
    $                                       :MLOAD(currentL1InfoTreeIndex), JMPNZ(previousL1InfoTreeIndexIsNotZero)
    ; if previous L1 Info TreeIndex is zero, currentL1InfoTreeRoot = keccak(HistoricRoot, blockHashL1InfoTree)
                                            :CALL(computeNewCurrentL1InfoRootFromHistoric)
    $ => A                                  :MLOAD(indexL1InfoTree)
    ; Update currentL1InfoTreeIndex
    A                                       :MSTORE(currentL1InfoTreeIndex), JMP(initSetGERL1InfoTree)

previousL1InfoTreeIndexIsNotZero:
                                            :CALL(computeMerkleProof)  ; out: [C: computed merkle root]
    ; Compute newL1InfoTreeRoot
                                            :CALL(computeNewCurrentL1InfoRoot)
    ; Update currentL1InfoTreeIndex
    $ => A                                  :MLOAD(indexL1InfoTree)
    A                                       :MSTORE(currentL1InfoTreeIndex), JMP(initSetGERL1InfoTree)

setNewTimestamp:
    ; Set forcedTimestamp (now new Timestamp) from forced batch data
    %TIMESTAMP_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    B => D                                  :MSTORE(timestamp)
    %SMT_KEY_SC_STORAGE => B
    $ => SR                                 :SSTORE

initSetGERL1InfoTree:
    ; Set new GER
    $ => A                                  :MLOAD(gerL1InfoTree)
    ; If it is a forced tx ==> gerL1InfoTree = forcedGER
    $                                       :MLOAD(isForced), JMPZ(setGERL1InfoTree)
    $ => A                                  :MLOAD(forcedGER)
    A                                       :MSTORE(gerL1InfoTree)

setGERL1InfoTree:
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - 1                                        :JMPN(outOfCountersKeccak)
    0 => B
    ; Do not set if zero
    $                                       :EQ, JMPC(skipSetGERL1InfoTree)
    0 => HASHPOS
    $ => E                                  :MLOAD(nextHashKId)
    E + 1                                   :MSTORE(nextHashKId)

    32 => D
    A                                       :HASHK(E)
    %GLOBAL_EXIT_ROOT_STORAGE_POS           :HASHK(E) ; Storage position of the global exit root map
    HASHPOS                                 :HASHKLEN(E)
    $ => C                                  :HASHKDIGEST(E)

    ; read blockHashL1InfoTree given the l1InfoRoot
    ; skip overwrite blockHashL1 if it is different than 0 (already set)
    %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A
    %SMT_KEY_SC_STORAGE => B
    $ => A                                  :SLOAD
    0 => B
    $                                       :EQ, JMPNC(skipSetGERL1InfoTree)

    ; write blockhashL1
    %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A
    %SMT_KEY_SC_STORAGE => B
    $ => D                                  :MLOAD(blockHashL1InfoTree)
    $ => SR                                 :SSTORE ; Store 'blockHashL1InfoTree' in storage position 'keccak256(gerL1InfoTree, 0)'

skipSetGERL1InfoTree:
                                            :CALL(setupNewBlockInfoTree)
                                            :JMP(txLoop)

INCLUDE "process-change-l2-block-utils.zkasm"