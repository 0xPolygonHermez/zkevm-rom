processChangeL2Block:
    ; Verify valid deltaTimestamp (not zero)
    $ => B, D                               :MLOAD(deltaTimestamp)
    0 => A
    $                                       :EQ, JMPC(invalidChangeL2Block)

    ; Load current timestamp
    %TIMESTAMP_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => A                                  :SLOAD
    D => B
    ; Addition of two values of 8 bytes (currentTimestamp + deltaTimestamp)
    $ => B                                  :ADD, MSTORE(timestamp)

    ; Verify currentTimestamp + deltaTimestamp =< limitTimestamp
    $ => A                                  :MLOAD(timestampLimit)
    $                                       :LT, JMPC(invalidChangeL2Block)

    ; Verify newGER | indexHistoricalGERTree belong to historicGER
                                          ;  :CALL(verifyMerkleProof)

    ; Set new timestamp (currentTimestamp + deltaTimestamp)
    %TIMESTAMP_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => D                                  :MLOAD(timestamp)
    $ => SR                                 :SSTORE

    ; Set new GER
    $ => A                                  :MLOAD(newGER)
    0 => B
    ; Dont set if zero
    $                                       :EQ, JMPC(skipSetHistoricGERRoot)
    0 => HASHPOS
    $ => E                                  :MLOAD(lastHashKIdUsed)
    E + 1 => E                              :MSTORE(lastHashKIdUsed)

    32 => D
    A                                       :HASHK(E)
    %GLOBAL_EXIT_ROOT_STORAGE_POS           :HASHK(E) ; Storage position of the global exit root map
    HASHPOS                                 :HASHKLEN(E)
    $ => C                                  :HASHKDIGEST(E)

    %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A
    %SMT_KEY_SC_STORAGE => B

    ; read timestampLimit given the historicGER
    ; skip overwrite timestampLimit if it is different than 0 (already set)
    ; Since timestampLimit is enforced by the smart contract it is safe to compare only 32 bits in 'op0' with JMPNZ
    $                                       :SLOAD, JMPNZ(skipSetHistoricGERRoot)
    $ => D                                  :MLOAD(timestamp)
    $ => SR                                 :SSTORE ; Store 'timestamp' in storage position 'keccak256(historicGER, 0)'

    skipSetHistoricGERRoot:
    ; Read block number, increase it by 1 and write it
     ; Get last block number
    $ => A                              :MLOAD(blockNum)
    ;Update last tx Count at system storage
    1 => B
    $ => D                              :ADD, MSTORE(blockNum)
    %LAST_BLOCK_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => SR                             :SSTORE

    ;Update state root mapping
    D => A
    32 => D
    0 => HASHPOS ; A new hash with position 0 is started
    $ => E                              :MLOAD(lastHashKIdUsed)
    E + 1 => E                          :MSTORE(lastHashKIdUsed)
    A                                   :HASHK(E)
    %STATE_ROOT_STORAGE_POS             :HASHK(E)
    HASHPOS                             :HASHKLEN(E)
    $ => C                              :HASHKDIGEST(E)
    %ADDRESS_SYSTEM => A
    SR => D
    $ => SR                             :SSTORE, JMP(txLoop)