; This file is WIP

VAR GLOBAL auxA
VAR GLOBAL auxB
VAR GLOBAL auxC
VAR GLOBAL auxD
VAR GLOBAL auxE

; @info complement a 2 conversion
; @in A => number to convert
; @out A => number converted in ca2
ca2:
    31 => D
    $ => B          :SHR
    B - 0x80        :JMPC(endca2) ; no conversion if positive number
    ${bitwise_xor(A, 115792089237316195423570985008687907853269984665640564039457584007913129639935)} => A
    A + 1 => A

endca2:
                    :RETURN

; @info copy MEM A to ctxB SP = 1024
; TODO: copy + 32 bytes
copySP:
    CTX             :MSTORE(currentCTX)
    1024 => SP                             ;destOffset = 0
    $ => CTX        :MLOAD(originCTX)
    $ => E          :MLOAD(argsOffsetCall) ;offset
    $ => C          :MLOAD(argsLengthCall) ;length
    0 - ${E%32}     :JMPC(copyInit2)

copyInit:
    C - 1           :JMPC(copyEnd)
    C - 32          :JMPC(copyFinal)
    $ => A          :MLOAD(MEM:E)
    E + 32 => E
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(SP++)
    $ => CTX        :MLOAD(originCTX)
    C - 32 => C
                    :JMP(copyInit)

copyFinal:
    $ => A          :MLOAD(MEM:E)
    32 - C => D
    $ => A          :SHR
    $ => A          :SHL
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(SP++)
                    :JMP(copyEnd)

copyInit2:
    C - 1           :JMPC(copyEnd)
    C - 32          :JMPC(copyFinal2)
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A          :MLOAD(MEM:E)
    $ => B          :SHL
    32 - D => D
    E + 32 => E
    $ => A          :MLOAD(MEM:E)
    $ => A          :SHR
    $ => CTX        :MLOAD(currentCTX)
    A + B           :MSTORE(SP++)
    $ => CTX        :MLOAD(originCTX)
    C - 32 => C
                    :JMP(copyInit2)

copyFinal2:
    32 - ${E%32} - C => D       :JMPC(copyFinal22)
    ${E%32} => B
    ${(E/32)*32} => E
    $ => A                      :MLOAD(MEM:E)
    32 - C => D
    $ => A                      :SHR
    $ => A                      :SHL
    $ => CTX                    :MLOAD(currentCTX)
    A                           :MSTORE(SP++)
                                :JMP(copyEnd)

copyFinal22:
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A                  :MLOAD(MEM:E)
    $ => B                  :SHL
    E + 32 => E
    $ => A                  :MLOAD(MEM:E)
    C - 32 + D => D
    32 - D => D
    $ => A                  :SHR
    32 - C => D
    $ => A                  :SHL
    $ => CTX                :MLOAD(currentCTX)
    A + B                   :MSTORE(SP++)

copyEnd:
    $ => CTX        :MLOAD(currentCTX)
                    :RETURN

; @info byte length of B
; @in B => number
; @out A => bytes length
getLenBytes:
    C               :MSTORE(auxC)
    0 => C
    B => A

getLenBytesLoop:
    ${comp_eq(A, 0)} => B
    0 - B           :JMPC(getLenEnd)
    1 => D
    $ => A          :SHR
    C + 1 => C
                    :JMP(getLenBytesLoop)

getLenEnd:
    C => A
                    :RETURN

; @info save value to memory 32 bytes with offset
; REQUIRE: set bytesToStore with value to use in MSTORE
; @in E => offset
; @out E => new offset

VAR GLOBAL bytesToStore

MSTORE32:
    A               :MSTORE(auxA)
    B               :MSTORE(auxB)
    C               :MSTORE(auxC)
    D               :MSTORE(auxD)
    E               :MSTORE(auxE)
    ${E%32} - 1     :JMPC(MSTORE322)
    ${E%32} => C
    ${(E/32)*32} => E
    $ => A          :MLOAD(MEM:E)
    32 - C => D
    $ => A          :SHR
    $ => A          :SHL
    A => B
    $ => A          :MLOAD(bytesToStore)
    C => D
    $ => A          :SHR
    A + B           :MSTORE(MEM:E)
    E + 32 => E                                    ;new offset
    $ => A          :MLOAD(MEM:E)
    C => D
    $ => A          :SHL
    $ => A          :SHR
    A => B
    $ => A          :MLOAD(bytesToStore)
    32 - C => D
    $ => A          :SHL
    A + B           :MSTORE(MEM:E)
    $ => E          :MLOAD(auxE)
    E + 32 => E
                    :JMP(MSTOREend)

MSTORE322:
    $ => A          :MLOAD(bytesToStore)
    A               :MSTORE(MEM:E)
    E + 32 => E
                    :JMP(MSTOREend)

; @info save value to memory < 32 bytes with offset
; REQUIRE: set bytesToStore with value to use in MSTORE
; @in E => offset
; @in C => length
; @out E => new offset

MSTOREX:
    A                           :MSTORE(auxA)
    B                           :MSTORE(auxB)
    C                           :MSTORE(auxC)
    D                           :MSTORE(auxD)
    32 - ${E%32} - C            :JMPC(MSTOREX2)
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A                      :MLOAD(bytesToStore)
    $ => A                      :SHR
    $ => B                      :SHL
    $ => A                      :MLOAD(MEM:E)
    32 - D => D
    $ => A                      :SHR
    $ => A                      :SHL
    A + B                       :MSTORE(MEM:E)
    E + C => E                                    ;new offset
                                :JMP(MSTOREend)

MSTOREX2:
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A                      :MLOAD(bytesToStore)
    $ => B                      :SHR
    $ => A                      :MLOAD(MEM:E)
    32 - D => D
    $ => A                      :SHR
    $ => A                      :SHL
    A + B                       :MSTORE(MEM:E)
    E + 32 => E
    $ => A                      :MLOAD(bytesToStore)
    $ => B                      :SHL
    $ => A                      :MLOAD(MEM:E)
    C - D => D
    $ => A                      :SHR
    A + B                       :MSTORE(MEM:E)
    E - 32 + C => E                                    ;new offset

MSTOREend:
    $ => A                      :MLOAD(auxA)
    $ => B                      :MLOAD(auxB)
    $ => C                      :MLOAD(auxC)
    $ => D                      :MLOAD(auxD)
                                :RETURN


; @info get value from memory (32 bytes)
; @in E => offset
; @out A => value
; @out E => new offset

MLOAD32:
    B               :MSTORE(auxB)
    C               :MSTORE(auxC)
    D               :MSTORE(auxD)
    ${E%32} - 1     :JMPC(MLOAD322)
    ${E%32} => C
    ${(E/32)*32} => E
    $ => A          :MLOAD(MEM:E)
    C => D
    $ => B          :SHL
    32 - C => D
    E + 32 => E                                    ;new offset
    $ => A          :MLOAD(MEM:E)
    $ => A          :SHR
    A + B => A
                    :JMP(MLOADend)

MLOAD322:
    $ => A          :MLOAD(MEM:E)
    E + 32 => E                                     ;new offset
                    :JMP(MLOADend)

; @info get value from memory (32 bytes)
; @in E => offset
; @in C => length
; @out A => value
; @out E => new offset

MLOADX:
    B               :MSTORE(auxB)
    C               :MSTORE(auxC)
    D               :MSTORE(auxD)
    32 - ${E%32} - C => D       :JMPC(MLOADX2)
    ${E%32} => B
    ${(E/32)*32} => E
    $ => A                      :MLOAD(MEM:E)
    32 - C => D
    $ => A                      :SHR
    $ => A                      :SHL
    E + B => E                                    ;new offset
                                :JMP(MLOADend)

MLOADX2:
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A                  :MLOAD(MEM:E)
    $ => B                  :SHL
    E + 32 => E
    $ => A                  :MLOAD(MEM:E)
    C - 32 + D => D
    32 - D => D
    $ => A                  :SHR
    32 - C => D
    $ => A                  :SHL
    A + B => A
    E - 32 + C => E                                    ;new offset

MLOADend:
    $ => B                      :MLOAD(auxB)
    $ => C                      :MLOAD(auxC)
    $ => D                      :MLOAD(auxD)
                                :RETURN

;copyInit:
;    C - 1           :JMPC(copyEnd)
;    C - 32          :JMPC(copyFinal)
;    ${B%32} => D
;    1024 + ${B/32} => SP
;    $ => A          :MLOAD(SP)
;    $ => C          :SHL
;    1024 + ${B/32} + 1 => SP
;    32 - D => D
;    $ => A          :MLOAD(SP)
;    $ => A          :SHR
;    $ => CTX        :MLOAD(currentCTX)
;    1024 + E => SP
;    A + C           :MSTORE(SP)
;    E + 1 => E
;    $ => CTX        :MLOAD(originCTX)
;    $ => C          :MLOAD(argsLengthCall)   ;length
;    C - 32 => C
;    C               :MSTORE(argsLengthCall)
;    B + 32 => B
;                    :JMP(copyInit)
;
;copyFinal:
;    ${B%32} => D
;    1024 + ${B/32} => SP
;    $ => A          :MLOAD(SP)
;    $ => A          :SHL
;    1024 + ${B/32} + 1 => SP
;    C - 32 + D => D
;    D               :JMPC(copyXor)
;    A => C
;    $ => A          :MLOAD(SP)
;    $ => A          :SHR
;    $ => CTX        :MLOAD(currentCTX)
;    1024 + E => SP
;    A + C           :MSTORE(SP)
;    E + 1 => E
;                    :JMP(copyEnd)
;
;copyXor:
;    $ => CTX        :MLOAD(currentCTX)
;    1024 + E => SP
;    A               :MSTORE(SP)
;
;copyEnd:
;    $ => CTX        :MLOAD(currentCTX)
;    $ => E          :MLOAD(txNData)
;    $ => B          :MLOAD(memLength)
;    B - E           :JMPC(saveMemLength)
;                    :RETURN