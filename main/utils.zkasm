; @info Get absolute value and sign
; @in A => number to convert
; @out A => Absolute value of A
; @out B => Sign of A [1 if negative, 0 positive]
abs:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 20       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    0 => B
    ; if is negative, change sign
    $ => B          :SLT, JMPC(absIsNeg)
                    :RETURN

absIsNeg:
    A => B
    0 => A
    ; 0 - (-A) = A
    $ => A          :SUB
    1 => B          :RETURN

VAR GLOBAL tmpVarBgetLen
VAR GLOBAL tmpVarCgetLen
VAR GLOBAL tmpVarDgetLen
VAR GLOBAL tmpZkPCgetLen
; @info byte length of B
; @in B => number
; @out A => bytes length
getLenBytes:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    ; store current registries
    RR              :MSTORE(tmpZkPCgetLen)
    B               :MSTORE(tmpVarBgetLen)
    C               :MSTORE(tmpVarCgetLen)
    D               :MSTORE(tmpVarDgetLen)
    ; set C as counter to 0
    0 => C
    B => A

getLenBytesLoop:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)

    0 => B
    ; if A is zero, finish counter
    $               :EQ,JMPC(getLenEnd)
    ; right shift one byte
    1 => D
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    ; increase counter
    C + 1 => C      :JMP(getLenBytesLoop)

getLenEnd:
    ; counter to A
    C => A
    ; recover registries
    $ => B          :MLOAD(tmpVarBgetLen)
    $ => C          :MLOAD(tmpVarCgetLen)
    $ => RR         :MLOAD(tmpZkPCgetLen)
    $ => D          :MLOAD(tmpVarDgetLen), RETURN

; @info bits length of B
; @in B => number
; @out A => bits length
getLenBits:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    ; store current registries
    RR              :MSTORE(tmpZkPCgetLen)
    B               :MSTORE(tmpVarBgetLen)
    C               :MSTORE(tmpVarCgetLen)
    D               :MSTORE(tmpVarDgetLen)
    ; set C as counter to 0
    0 => C
    B => A

getLenBitsLoop:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    0 => B
    ; if B is zero, finish counter
    $               :EQ,JMPC(getLenBitsEnd)
    ; divide value by 2
    A               :MSTORE(arithA)
    2               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A          :MLOAD(arithRes1)
    ; increase counter
    C + 1 => C      :JMP(getLenBitsLoop)

getLenBitsEnd:
    ; counter to A
    C => A
    ; recover registries
    $ => B          :MLOAD(tmpVarBgetLen)
    $ => C          :MLOAD(tmpVarCgetLen)
    $ => RR         :MLOAD(tmpZkPCgetLen)
    $ => D          :MLOAD(tmpVarDgetLen), RETURN

VAR GLOBAL tmpVarAmstore
VAR GLOBAL tmpVarBmstore
VAR GLOBAL tmpVarCmstore
VAR GLOBAL tmpVarDmstore
VAR GLOBAL tmpVarEmstore
VAR GLOBAL tmpZkPCmstore

VAR GLOBAL bytesToStore
VAR GLOBAL isMSTOREX
; @info save value to memory < 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @in C => length
; @out E => new offset
MSTOREX:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    C               :JMPZ(endMSTOREX)
    32 - C          :JMPN(errorMLOADMSTORE)
    32 - C - 1      :JMPN(MSTORE32); in: [bytesToStore, E: offset] out: [E: new offset]
    1               :MSTORE(isMSTOREX)

; @info save value to memory 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @out E => new offset
MSTORE32:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 50              :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1        :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)
    ; store current registries
    RR              :MSTORE(tmpZkPCmstore)
    A               :MSTORE(tmpVarAmstore)
    B               :MSTORE(tmpVarBmstore)
    C               :MSTORE(tmpVarCmstore)
    D               :MSTORE(tmpVarDmstore)
    ; check offset is lower than max memory
    E => A
    %MAX_MEM_EXPANSION_BYTES => B
    $               :LT,JMPC(initMSTORE, errorMLOADMSTORE)

initMSTORE:
    zkPC+1 => RR    :JMP(offsetUtil); in: [A: offset] out: [E: offset/32, C: offset%32]
    ; is storing <32 bytes, jump to store last bytes or finish if 0 bytes left
    $ => B          :MLOAD(isMSTOREX), JMPZ(finalMSTORE)
    ; if C has value, offset != 0
    C               :JMPNZ(MSTOREX2)
    $ => C          :MLOAD(tmpVarCmstore)
    ; load bytes to store
    $ => A          :MLOAD(bytesToStore)
    32 - C => D
    ; shift bytes to store
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    A => B
    ; load from memory
    $ => A          :MLOAD(MEM:E)
    32 - D => D
    ; shift loaded bytes
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    A + B           :MSTORE(bytesToStore)
    A + B => A
    0 => C          :JMP(finalMSTORE)

; used if bytesToStore.length < 32 && offset != 0
MSTOREX2:
    $ => D          :MLOAD(tmpVarCmstore)
    C + D => D
    32 - D          :JMPN(MSTOREX3)
    ; if bytesToStore.length < 32 && memory to load is allocated in two different slots
    ; load memory from slot E
    $ => A          :MLOAD(MEM:E)
    ; shift loaded memory from slot E
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    $ => D          :MLOAD(tmpVarCmstore)
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    A => B
    ; load memory from slot E+1
    $ => A          :MLOAD(MEM:E+1)
    32 - C => D
    ; right shift loaded memory from slot E+1
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    ; join both results
    A + B => B
    $ => A          :MLOAD(bytesToStore)
    $ => D          :MLOAD(tmpVarCmstore)
    32 - D => D
    ; shift bytes to store
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    ; append loaded bytes from concurrent slots
    A + B => A      :MSTORE(bytesToStore)
                    :JMP(finalMSTORE)

; used if bytesToStore.length < 32 && memory to load is allocated in one slot
MSTOREX3:
    D - 32 => D
    ; load memory from slot E+1
    $ => A          :MLOAD(MEM:E+1)
    ; shift bytes to store
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    $ => D          :MLOAD(tmpVarCmstore)
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    ; join both results
    A => B
    $ => A          :MLOAD(bytesToStore)
    $ => D          :MLOAD(tmpVarCmstore)
    32 - D => D
    ; shift bytes to store
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    ; append loaded bytes from concurrent slots
    A + B => A      :MSTORE(bytesToStore)

finalMSTORE:
    C               :JMPNZ(memAlignOptionMSTORE)
    $ => A          :MLOAD(bytesToStore)
    A               :MSTORE(MEM:E)
    E*32 => E
    $               :MLOAD(isMSTOREX),JMPZ(offsetMSTORE32)
    $ => C          :MLOAD(tmpVarCmstore)
    E + C => E
    0               :MSTORE(isMSTOREX),JMP(endMSTORE)

memAlignOptionMSTORE:
    E               :MSTORE(tmpVarEmstore)

    $ => A          :MLOAD(MEM:E)
    $ => B          :MLOAD(MEM:E+1)

    ${memAlignWR_W0(A,mem.bytesToStore,C)} => D                    ; no trust calculate W0
    ${memAlignWR_W1(B,mem.bytesToStore,C)} => E                    ; no trust calculate W1
    $               :MEM_ALIGN_WR,MLOAD(bytesToStore)
    E => A
    $ => E          :MLOAD(tmpVarEmstore)
    D               :MSTORE(MEM:E)          ; write W0
    A               :MSTORE(MEM:E+1)        ; write W1
    E*32 + C => E
    $ => A          :MLOAD(isMSTOREX), JMPZ(offsetMSTORE32)
    $ => C          :MLOAD(tmpVarCmstore)
    E + C => E
    0               :MSTORE(isMSTOREX), JMP(endMSTORE)

offsetMSTORE32:
    E + 32 => E

endMSTORE:
    $ => A          :MLOAD(tmpVarAmstore)
    $ => B          :MLOAD(tmpVarBmstore)
    $ => C          :MLOAD(tmpVarCmstore)
    $ => RR         :MLOAD(tmpZkPCmstore)
    $ => D          :MLOAD(tmpVarDmstore), RETURN
endMSTOREX:
                    :RETURN

VAR GLOBAL tmpVarAmload
VAR GLOBAL tmpVarBmload
VAR GLOBAL tmpVarCmload
VAR GLOBAL tmpVarDmload
VAR GLOBAL tmpVarEmload
VAR GLOBAL tmpZkPCmload

VAR GLOBAL isMLOADX
; @info get value from memory (< 32 bytes)
; @in E => offset
; @in C => length
; @out A => value
; @out E => new offset
MLOADX:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100             :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2        :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

    32 - C          :JMPN(errorMLOADMSTORE)
    32 - C - 1      :JMPN(MLOAD32)
    1               :MSTORE(isMLOADX)

; @info get value from memory (32 bytes)
; @in E => offset
; @out A => value
; @out E => new offset
MLOAD32:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100             :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2        :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)
    ; store current registries
    RR              :MSTORE(tmpZkPCmload)
    B               :MSTORE(tmpVarBmload)
    C               :MSTORE(tmpVarCmload)
    D               :MSTORE(tmpVarDmload)
    ; check offset is lower than max memory
    E => A
    %MAX_MEM_EXPANSION_BYTES => B
    $               :LT,JMPC(initMLOAD, errorMLOADMSTORE)

initMLOAD:
                    :CALL(offsetUtil); in: [A: offset] out: [E: offset/32, C: offset%32]
    ; if C has value, bytes split in two memory slots
    C               :JMPNZ(memAlignOptionMLOAD)
    ; load memory from one slot
    $ => A          :MLOAD(MEM:E)
    $ => B          :MLOAD(isMLOADX)
    E*32 => E
    B               :JMPZ(offsetMLOAD32, sliceA)

memAlignOptionMLOAD:
    $ => A          :MLOAD(MEM:E)
    $ => B          :MLOAD(MEM:E+1)
    ; get memory value
    $ => A          :MEM_ALIGN_RD
    E*32 + C => E
    $ => B          :MLOAD(isMLOADX)
    B               :JMPZ(offsetMLOAD32)

sliceA:
    ; if is mloadx, slice the result by the length
    $ => C          :MLOAD(tmpVarCmload)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    0               :MSTORE(isMLOADX)
    E + C => E      :JMP(endMLOAD)

offsetMLOAD32:
    E + 32 => E

endMLOAD:
    ; restore stored values
    $ => B          :MLOAD(tmpVarBmload)
    $ => C          :MLOAD(tmpVarCmload)
    $ => RR         :MLOAD(tmpZkPCmload)
    $ => D          :MLOAD(tmpVarDmload), RETURN

errorMLOADMSTORE:
                    :JMP(outOfGas)

VAR GLOBAL tmpVarAemptyAcc
VAR GLOBAL tmpVarBemptyAcc
VAR GLOBAL tmpVarCemptyAcc
VAR GLOBAL tmpVarDemptyAcc

; @info check account is empty ( balance == nonce == code == 0x )
; @in E => address
; @out E => isEmpty => 1 = true, 0 = false
isEmptyAccount:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50                                              :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3                                        :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - %MAX_CNT_POSEIDON_SLOAD_SSTORE*3 :JMPN(outOfCountersPoseidon)

    ; store current registries
    A                           :MSTORE(tmpVarAemptyAcc)
    B                           :MSTORE(tmpVarBemptyAcc)
    C                           :MSTORE(tmpVarCemptyAcc)
    D                           :MSTORE(tmpVarDemptyAcc)

    E => A
    ; read balance
    ; set key for smt balance query.
    %SMT_KEY_BALANCE => B
    0 => C
    $ => B                      :SLOAD
    ; balance in A
    0 => A
    ; if balance is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    ; check nonce
    E => A
    ; set key for smt nonce query
    %SMT_KEY_NONCE => B
    ; nonce in B
    $ => B                      :SLOAD
    0 => A
    ; if nonce is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    ; read bytecode
    E => A
    ; set key for smt smart contract query
    %SMT_KEY_SC_CODE => B
    ; sc in B
    $ => B                      :SLOAD
    0 => A
    ; if code is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    1 => E                      :JMP(ISEMPTYEnd)

isNotEmptyAccount:
    0 => E                      :JMP(ISEMPTYEnd)

ISEMPTYEnd:
    ; recover registries
    $ => A                      :MLOAD(tmpVarAemptyAcc)
    $ => B                      :MLOAD(tmpVarBemptyAcc)
    $ => C                      :MLOAD(tmpVarCemptyAcc)
    $ => D                      :MLOAD(tmpVarDemptyAcc), RETURN

VAR GLOBAL tmpVarBcompGas
VAR GLOBAL tmpVarCcompGas
VAR GLOBAL tmpVarDcompGas
VAR GLOBAL tmpVarEcompGas

; @info Compute gas to send to call following EIP 150
; @in gasCall: gas sent to call
; @out A => min( requested_gas , all_but_one_64th(63/64) )
computeGasSendCall:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 30       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    ; save tmp vars
    B                       :MSTORE(tmpVarBcompGas)
    C                       :MSTORE(tmpVarCcompGas)
    D                       :MSTORE(tmpVarDcompGas)
    E                       :MSTORE(tmpVarEcompGas)

    ; compute all_but_one_64th gas
    GAS => A

    ; C = [c7, c6, ..., c0]
    ; JMPN instruction assures c0 is within the range [0, 2**32 - 1]
    ${GAS >> 6} => C        :JMPN(failAssert)
    ${GAS & 0x3f} => D

    ; since D is assured to be less than 0x40
    ; it is enforced that [c7, c6, ..., c1] are 0 since there is no value multiplied by 64
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, c0 * 64 + d0 could not overflow the field
    C * 64 + D              :ASSERT
    D => A
    0x40 => B
    $                       :LT,JMPNC(failAssert)
    GAS - C => A
    $ => B                  :MLOAD(gasCall)
    ; gas_sent_with_call = min(requested_gas, all_but_one_64th)
    $                       :LT,JMPC(computeGasSendCallEnd)
    ; gas to substract
    B => A

computeGasSendCallEnd:
    ; restore stored values
    $ => B                  :MLOAD(tmpVarBcompGas)
    $ => C                  :MLOAD(tmpVarCcompGas)
    $ => D                  :MLOAD(tmpVarDcompGas)
    $ => E                  :MLOAD(tmpVarEcompGas), RETURN

VAR GLOBAL tmpVarAsaveMem
VAR GLOBAL tmpVarBsaveMem
VAR GLOBAL tmpVarCsaveMem
VAR GLOBAL tmpVarDsaveMem
VAR GLOBAL tmpVarEsaveMem
VAR GLOBAL tmpZkPCsaveMem
; @info compute memory expansion gas cost
; @in: lastMemOffset: offset to copy bytes
; @in: lastMemLength: size of the bytes to copy
saveMem:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100      :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 5 :JMPN(outOfCountersBinary)
    RR                          :MSTORE(tmpZkPCsaveMem)
    A                           :MSTORE(tmpVarAsaveMem)
    B                           :MSTORE(tmpVarBsaveMem)
    C                           :MSTORE(tmpVarCsaveMem)
    D                           :MSTORE(tmpVarDsaveMem)
    E                           :MSTORE(tmpVarEsaveMem)
    $ => A                      :MLOAD(lastMemLength)
    ; If no len, no memory expansion
    0 => B
    $                           :EQ, JMPC(saveMemEnd)
    $ => B                      :MLOAD(lastMemOffset)
    ; If the binary has a carry, means the mem expansion is very big. We can jump to oog directly
    ; offset + length in B
    $ => B                      :ADD, JMPC(outOfGas)
    ; check new memory length is lower than 2**22 - 31 - 1 (max supported memory expansion for %TX_GAS_LIMIT of gas)
    %MAX_MEM_EXPANSION_BYTES => A
    $                           :LT,JMPC(outOfGas)


    ; load old memory length, if is greater than new memory length, no expansion cost
    $ => A                      :MLOAD(memLength)
    $                           :LT, JMPC(saveMemGAS, saveMemEnd)

saveMemGAS:
    ; store new memory length
    B                           :MSTORE(memLength)
    B => E
    ; memory_size_word = (memory_byte_size + 31) / 32 in E
    ; ${(B+31)/32} => E
    E + 31 => A

    ; E = [e7, e6, ..., e0]
    ; JMPN instruction assures e0 is within the range [0, 2**32 - 1]
    ${A >> 5} => E              :JMPN(failAssert)
    ${A & 0x1f} => D

    ; since D is assured to be less than 0x20
    ; it is enforced that [e7, e6, ..., e1] are 0 since there is no value multiplied by 32
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, e0 * 32 + d0 could not overflow the field
    E * 32 + D                  :ASSERT
    D => A
    0x20 => B
    $                           :LT,JMPNC(failAssert)
    ; memory_cost = (memory_size_word ** 2) / 512 + (3 * memory_size_word) in A
    ; ${E*E/512} + 3*E=> A
    E                           :MSTORE(arithA)
    E                           :MSTORE(arithB), CALL(mulARITH); in: [arithA, arithB] out: [arithRes1: arithA*arithB, mulFlagOverflow: value overflow, mulArithOverflowFlag: set to 1 if operation causes overflow]
    $ => C                      :MLOAD(arithRes1)
    $                           :MLOAD(mulArithOverflowFlag), JMPNZ(outOfGas)
    C                           :MSTORE(arithA)
    512                         :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A                      :MLOAD(arithRes1)
    A + 3*E => A
    $ => B                      :MLOAD(lastMemoryExpansionCost)
    A                           :MSTORE(lastMemoryExpansionCost)
    ; memory_expansion_cost = new_memory_cost - last_memory_cost
    A - B => A
    ; update new gas
    GAS - A => GAS               :JMPN(outOfGas)

saveMemEnd:
    ; restore stored values
    $ => A                      :MLOAD(tmpVarAsaveMem)
    $ => B                      :MLOAD(tmpVarBsaveMem)
    $ => C                      :MLOAD(tmpVarCsaveMem)
    $ => D                      :MLOAD(tmpVarDsaveMem)
    $ => RR                     :MLOAD(tmpZkPCsaveMem)
    $ => E                      :MLOAD(tmpVarEsaveMem), RETURN

VAR GLOBAL tmpVarAArith
VAR GLOBAL tmpVarBArith
VAR GLOBAL tmpVarCArith
VAR GLOBAL tmpVarDArith
VAR GLOBAL tmpVarEArith
VAR GLOBAL tmpZkPCArith
VAR GLOBAL arithA
VAR GLOBAL arithB
VAR GLOBAL arithRes1
VAR GLOBAL arithRes2

VAR GLOBAL addArithOverflow
; @info binary addition
; @in: arithA: addend value
; @in: arithB: addend value
; @out: arithRes1: arithA + arithB
addARITH:

    RR              :MSTORE(tmpZkPCArith), CALL(storeTmp)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => E          :ADD, MSTORE(arithRes1), JMPC(setAddArithOverflow)
    0               :MSTORE(addArithOverflow), JMP(finishAddArith)

setAddArithOverflow:
    1               :MSTORE(addArithOverflow)

finishAddArith:
    $ => RR         :MLOAD(tmpZkPCArith), JMP(loadTmp)

; @info binary subtraction
; @in: arithA: minuend value
; @in: arithB: subtrahend value
; @out: arithRes1: arithA - arithB
subARITH:

    RR              :MSTORE(tmpZkPCArith),CALL(storeTmp)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => A          :SUB,MSTORE(arithRes1)
    $ => RR         :MLOAD(tmpZkPCArith),JMP(loadTmp)

VAR GLOBAL mulArithOverflowValue
VAR GLOBAL mulArithOverflowFlag
; @info arithmetic multiplication
; @in: arithA: multiplier value
; @in: arithB: multiplicand value
; @out: arithRes1: product of multiplication arithA * arithB
; @out: mulArithOverflowValue: overflow value
; @out: mulArithOverflowFlag: set to 1 if operation causes overflow
mulARITH:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)

    RR              :MSTORE(tmpZkPCArith), CALL(storeTmp)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    0 => C
    $${var _mulArith = A * B}
    ${_mulArith >> 256} => D
    ${_mulArith} => E :ARITH

    E               :MSTORE(arithRes1)
    D               :MSTORE(mulArithOverflowValue)
    D => A
    0 => B
    $               :EQ,JMPNC(setMulArithOverflow)
    0               :MSTORE(mulArithOverflowFlag), JMP(finishMulArith)

setMulArithOverflow:
    1               :MSTORE(mulArithOverflowFlag)

finishMulArith:
    $ => RR        :MLOAD(tmpZkPCArith),JMP(loadTmp)

; @info arithmetic division
; @in: arithA: dividend value
; @in: arithB: divisor value
; @out: arithRes1: quotient of division arithA / arithB
; @out: arithRes2: remainder of division arithA % arithB
divARITH:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)

    RR              :MSTORE(tmpZkPCArith), CALL(storeTmp)
    $ => E          :MLOAD(arithA)
    $ => A          :MLOAD(arithB)
    ; Check denominator(A) is not zero
    0 => B
    $               :EQ, JMPC(zeroDiv)

    ; Check if divisor (E) is smaller than denominator E < A
    A => C ; store temporally A in C
    E => A ; divisor
    C => B ; denominator
    $               :LT, JMPC(divisorSmallerDiv)
    C => A

    ${E%A} => C ; remainder
    ${E/A} => B
    0 => D
    E               :ARITH

    B               :MSTORE(arithRes1)
    C               :MSTORE(arithRes2)

    ; check divisor > remainder
    A => B ; divisor
    C => A ; remainder
    $ => A          :LT
    1               :ASSERT,CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

zeroDiv:
    0               :MSTORE(arithRes1)
    0               :MSTORE(arithRes2), CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

divisorSmallerDiv:
    0               :MSTORE(arithRes1)
    E               :MSTORE(arithRes2), CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

loadTmp:
    $ => A          :MLOAD(tmpVarAArith)
    $ => B          :MLOAD(tmpVarBArith)
    $ => C          :MLOAD(tmpVarCArith)
    $ => D          :MLOAD(tmpVarDArith)
    $ => E          :MLOAD(tmpVarEArith), RETURN

storeTmp:
    A               :MSTORE(tmpVarAArith)
    B               :MSTORE(tmpVarBArith)
    C               :MSTORE(tmpVarCArith)
    D               :MSTORE(tmpVarDArith)
    E               :MSTORE(tmpVarEArith), RETURN

VAR GLOBAL tmpSHXZkPC
VAR GLOBAL tmpSHXZkPC2

VAR GLOBAL tmpVarBSHX
VAR GLOBAL tmpVarCSHX
VAR GLOBAL tmpVarDSHX
VAR GLOBAL tmpVarESHX

VAR GLOBAL result
;@info Shift right D bytes to A
;@in A - (A >> D)
;@in D - (A >> D) D bytes
;@out A - A >> D => A
SHRarith:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)

    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarBSHX)
    C                       :MSTORE(tmpVarCSHX)
    D                       :MSTORE(tmpVarDSHX)
    E                       :MSTORE(tmpVarESHX)
    ; E init number
    A => E
    ; A bytes
    D => A
    ; B = 8 (1 byte = 8 bits)
    8 => B
    0 => C
    0 => D
    ; A * B = op --> D = op (D bits)
    ${A*B} => D             :ARITH
    ; A init number
    E => A                  :JMP(SHRarithinit)

;@in A - (A >> D)
;@in D - (A >> D) D bits
;@out A -  A >> D => A
SHRarithBit:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 30       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarBSHX)
    C                       :MSTORE(tmpVarCSHX)
    D                       :MSTORE(tmpVarDSHX)
    E                       :MSTORE(tmpVarESHX)

SHRarithinit:
    0 => B
    ; if A == 0 --> no shift
    $                       :EQ,JMPC(SHRarithfinal)
    ; E init number
    A => E
    ; B bits
    D => B
    255 => A
    ; A < B, 255 < bits
    $                       :LT,JMPC(SHRarith0)
    D => RR
    E => A                  :MSTORE(arithA)
                            :CALL(@exp_num + RR); out:[B: 2**RR]
    B                       :MSTORE(arithB),CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A                  :MLOAD(arithRes1),JMP(SHRarithfinal)

SHRarith0:
    0 => A

SHRarithfinal:
    $ => B                  :MLOAD(tmpVarBSHX)
    $ => C                  :MLOAD(tmpVarCSHX)
    $ => D                  :MLOAD(tmpVarDSHX)
    $ => RR                 :MLOAD(tmpSHXZkPC2)
    $ => E                  :MLOAD(tmpVarESHX), RETURN

;@info Shift left D bytes to A
;@in A - (A << D)
;@in D - (A << D) D bytes
;@out A -  A << D => A
SHLarith:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 4    :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 2      :JMPN(outOfCountersArith)
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarBSHX)
    C                       :MSTORE(tmpVarCSHX)
    D                       :MSTORE(tmpVarDSHX)
    E                       :MSTORE(tmpVarESHX)
    ; E init number
    A => E
    ; A bytes
    D => A
    8 => B
    0 => C, D
    ; D = A * 8, D bits
    ${A*B} => D             :ARITH
    ; A init number
    E => A
                            :JMP(SHLarithinit)
SHLarithBit:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2    :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1      :JMPN(outOfCountersArith)
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarBSHX)
    C                       :MSTORE(tmpVarCSHX)
    D                       :MSTORE(tmpVarDSHX)
    E                       :MSTORE(tmpVarESHX)

SHLarithinit:
    ; E init number
    A => E
    0 => A
    ; D --> B bits
    D => B
    ; if D == 0 --> no shift
    $                       :EQ,JMPC(SHLarithfinal)
    255 => A
     ; A < B, 255 < bits
    $                       :LT,JMPC(SHLarith0)

    D => RR
    ; A init number and calculate B = 2**D
    E => A                  :CALL(@exp_num + RR); out:[B: 2**RR]
    ; E = init number * 2**D (result)
    ${A*B} => E
    E                       :MSTORE(result)
    ; D = 256 - D
    256 - D => D, RR
    B => C                  :CALL(@exp_num + RR); out:[B: 2**RR]
    ${A/B} => D
    C => B
    0 => C
    E                       :ARITH, JMP(SHLarithfinal)

SHLarith0:
    0 => E
                            :JMP(SHLarithfinal)

SHLarithfinal:
    E => A
    $ => B                  :MLOAD(tmpVarBSHX)
    $ => C                  :MLOAD(tmpVarCSHX)
    $ => D                  :MLOAD(tmpVarDSHX)
    $ => RR                 :MLOAD(tmpSHXZkPC2)
    $ => E                  :MLOAD(tmpVarESHX), RETURN

; out of counters full tracer event trigger
outOfCountersStep:
    $${eventLog(onError, OOCS)}                     :JMP(handleBatchError)
outOfCountersKeccak:
    $${eventLog(onError, OOCK)}                     :JMP(handleBatchError)
outOfCountersBinary:
    $${eventLog(onError, OOCB)}                     :JMP(handleBatchError)
outOfCountersMemalign:
    $${eventLog(onError, OOCM)}                     :JMP(handleBatchError)
outOfCountersArith:
    $${eventLog(onError, OOCA)}                     :JMP(handleBatchError)
outOfCountersPadding:
    $${eventLog(onError, OOCPA)}                    :JMP(handleBatchError)
outOfCountersPoseidon:
    $${eventLog(onError, OOCPO)}                    :JMP(handleBatchError)
outOfCountersSha256:
    $${eventLog(onError, OOCSH)}                    :JMP(handleBatchError)
invalidChangeL2BlockLimitTimestamp:
    $${eventLog(onError, invalid_change_l2_block_limit_timestamp)}  :JMP(handleBatchError)
invalidChangeL2BlockMinTimestamp:
    $${eventLog(onError, invalid_change_l2_block_min_timestamp)}    :JMP(handleBatchError)
outOfGas:
    $${eventLog(onError, OOG)}                      :JMP(handleError)
invalidJump:
    $${eventLog(onError, invalidJump)}              :JMP(handleError)
invalidOpcode:
    $${eventLog(onError, invalidOpcode)}            :JMP(handleError)
stackUnderflow:
    $${eventLog(onError, underflow)}                :JMP(handleError)
stackOverflow:
    $${eventLog(onError, overflow)}                 :JMP(handleError)
deployAddressCollision:
    $${eventLog(onError, invalidAddressCollision)}  :JMP(handleError)
invalidStaticTx:
    $${eventLog(onError, invalidStaticTx)}          :JMP(handleError)
invalidCodeSize:
    $${eventLog(onError, invalidCodeSize)}          :JMP(handleError)
invalidCodeStartsEF:
    $${eventLog(onError, invalidCodeStartsEF)}      :JMP(handleError)

handleError:
    %MAX_CNT_STEPS - STEP - 500         :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2    :JMPN(outOfCountersBinary)
    ;revert all state changes
    $ => SR         :MLOAD(initSR), CALL(revertTouched)
                    :CALL(revertBlockInfoTree)

    $ => A          :MLOAD(originCTX), JMPZ(errorAtFirstContext)
    A => CTX
    ; Add return data context value to origin context
    ; Clear return data context
    0               :MSTORE(retDataCTX)
    CTX             :MSTORE(currentCTX)
    $ => GAS        :MLOAD(gasCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++), JMP(readCode)

handleBatchError:
    ; restore init state root and finish batch
    $ => SR                     :MLOAD(batchSR)
    ; if batch error is triggered while parsing the RLP, it jumps to 'appendTxsInit'
    ; to fill the missing bytes to complete 'batchDataHash'
    $                           :MLOAD(isLoadingRLP),JMPNZ(appendTxsInit)
    $${eventLog(onFinishTx)}    :JMP(finalizeBatch)

errorAtFirstContext:
    ; Set tx status to failure
    0               :MSTORE(txStatus)
    ;save Root and jump to send gas to sequencer
    0               :MSTORE(gasRefund)
    ;remaining gas = 0
    0 => GAS        :JMP(sendGasSeq)

VAR GLOBAL tmpVarAoffsetUtil
VAR GLOBAL tmpVarBoffsetUtil
;Get offset/32 & offset%32
;@in A offset (offset is assumed to be less than %MAX_MEM_EXPANSION_BYTES)
;@out E offset/32
;@out C offset%32
offsetUtil:
    %MAX_CNT_STEPS - STEP - 20          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    A                                   :MSTORE(tmpVarAoffsetUtil)
    B                                   :MSTORE(tmpVarBoffsetUtil)

    ; E = [e7, e6, ..., e0]
    ; JMPN instruction assures e0 is within the range [0, 2**32 - 1]
    ${A >> 5} => E                      :JMPN(failAssert)
    ${A & 0x1F} => C

    ; since C is assured to be less than 0x20
    ; it is enforced that [e7, e6, ..., e1] are 0 since there is no value multiplied by 32
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, e0 * 32 + c0 could not overflow the field
    E * 32 + C                          :ASSERT
    C => A
    0x20 => B
    $                                   :LT,JMPNC(failAssert)

    $ => A                              :MLOAD(tmpVarAoffsetUtil)
    $ => B                              :MLOAD(tmpVarBoffsetUtil), RETURN

;@info: move balances between two accounts
;@in: txSrcAddr: source address
;@in: storageAddr: destination address
;@in: txValue: transaction value
moveBalances:
;;;;;;;;
; evmCALL (Move Balances)
;;;;;;;;
    %MAX_CNT_STEPS - STEP - 50                                              :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 5                                        :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - %MAX_CNT_POSEIDON_SLOAD_SSTORE*4 :JMPN(outOfCountersPoseidon)
    ;Check if is a delegate call
    $ => A                          :MLOAD(isDelegateCall), JMPNZ(endMoveBalances)
    ; Decrement source balance
    $ => A                          :MLOAD(txSrcAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE => B
    0 => C
    ; Balance in A
    $ => A                          :SLOAD
    ; value in B
    $ => B                          :MLOAD(txValue)
    ; Check has enough balance to pay the value. In case not, means we are in a CALL/CALLCODE
    $                               :LT,JMPC(invalidCall)
    ; sourceBalance - value in D
    $ => D                          :SUB
    ; update source balance
    $ => A                          :MLOAD(txSrcAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE => B
    $ => SR                         :SSTORE
    ; Increment destination balance
    $ => A                          :MLOAD(storageAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE  => B
    ; Balance in A
    $ => A                          :SLOAD
    $ => B                          :MLOAD(txValue)
    $ => D                          :ADD
    $ => A                          :MLOAD(storageAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE  => B
    0 => C
    $ => SR                         :SSTORE
endMoveBalances:
                                    :RETURN

invalidCall:
    ; return to origin context
    $ => SR                         :MLOAD(initSR)
    $ => A                          :MLOAD(originCTX)
    0 => B
    ; if last context, finish tx
    $                               :EQ,JMPC(handleGas)
    A => CTX
    0                               :MSTORE(retDataCTX)
    CTX                             :MSTORE(currentCTX)
    $ => A                          :MLOAD(gasCTX)
    GAS + A => GAS
    $ => SP                         :MLOAD(lastSP)
    $ => PC                         :MLOAD(lastPC)
    0                               :MSTORE(SP++), JMP(readCode)

VAR GLOBAL pushBytes
VAR GLOBAL pushBytes_RR
; @info Read bytes opcode PUSHX
; @internalParam {numBlocks} 4 bytes blocks to read
; @internalParam {leftBytes} remaining bytes
; @in D,E => bytes to read (1..32)
; @out E => value read

readPush:
                            :JMP(@readPush+E)    ;0
readPush1:
    PC => HASHPOS           :JMP(_readPush1)     ;1
readPush2:
    PC => HASHPOS           :JMP(_readPush2)     ;2
readPush3:
    PC => HASHPOS           :JMP(_readPush3)     ;3
readPush4:
    PC => HASHPOS           :JMP(_readPush4)     ;4
readPush5:
    PC => HASHPOS           :JMP(_readPushX)     ;5
readPush6:
    PC => HASHPOS           :JMP(_readPushX)     ;6
readPush7:
    PC => HASHPOS           :JMP(_readPushX)     ;7
readPush8:
    PC => HASHPOS           :JMP(_readPushX)     ;8
readPush9:
    PC => HASHPOS           :JMP(_readPushX)     ;9
readPush10:
    PC => HASHPOS           :JMP(_readPushX)     ;10
readPush11:
    PC => HASHPOS           :JMP(_readPushX)     ;11
readPush12:
    PC => HASHPOS           :JMP(_readPushX)     ;12
readPush13:
    PC => HASHPOS           :JMP(_readPushX)     ;13
readPush14:
    PC => HASHPOS           :JMP(_readPushX)     ;14
readPush15:
    PC => HASHPOS           :JMP(_readPushX)     ;15
readPush16:
    PC => HASHPOS           :JMP(_readPushX)     ;16
readPush17:
    PC => HASHPOS           :JMP(_readPushX)     ;17
readPush18:
    PC => HASHPOS           :JMP(_readPushX)     ;18
readPush19:
    PC => HASHPOS           :JMP(_readPushX)     ;19
readPush20:
    PC => HASHPOS           :JMP(_readPushX)     ;20
readPush21:
    PC => HASHPOS           :JMP(_readPushX)     ;21
readPush22:
    PC => HASHPOS           :JMP(_readPushX)     ;22
readPush23:
    PC => HASHPOS           :JMP(_readPushX)     ;23
readPush24:
    PC => HASHPOS           :JMP(_readPushX)     ;24
readPush25:
    PC => HASHPOS           :JMP(_readPushX)     ;25
readPush26:
    PC => HASHPOS           :JMP(_readPushX)     ;26
readPush27:
    PC => HASHPOS           :JMP(_readPushX)     ;27
readPush28:
    PC => HASHPOS           :JMP(_readPushX)     ;28
readPush29:
    PC => HASHPOS           :JMP(_readPushX)     ;29
readPush30:
    PC => HASHPOS           :JMP(_readPushX)     ;30
readPush31:
    PC => HASHPOS           :JMP(_readPushX)     ;31
readPush32:
    PC => HASHPOS           :JMP(_readPush32)    ;32

_readPush1:
    %MAX_CNT_STEPS - STEP - 2   :JMPN(outOfCountersStep)

    $ => E                      :MLOAD(contractHashId)
    $ => E                      :HASHP1(E),RETURN

_readPush2:
    %MAX_CNT_STEPS - STEP - 4   :JMPN(outOfCountersStep)

    $ => E                      :MLOAD(contractHashId)
    $ => C                      :HASHP1(E)
    $ => E                      :HASHP1(E)
    C * 256 + E => E            :RETURN

_readPush3:
    %MAX_CNT_STEPS - STEP - 5   :JMPN(outOfCountersStep)

    $ => E                      :MLOAD(contractHashId)
    $ => A                      :HASHP1(E)
    $ => C                      :HASHP1(E)
    $ => E                      :HASHP1(E)
    A * 2**16 + C * 2**8 + E => E   :RETURN

_readPush4:
    %MAX_CNT_STEPS - STEP - 6   :JMPN(outOfCountersStep)

    $ => E                      :MLOAD(contractHashId)
    $ => A                      :HASHP1(E)
    $ => B                      :HASHP1(E)
    $ => C                      :HASHP1(E)
    $ => E                      :HASHP1(E)
    A * 2**24 + B * 2**16 + C * 2**8 + E => E :RETURN


_readPush32:
    %MAX_CNT_STEPS - STEP - 50  :JMPN(outOfCountersStep)

    $ => E                      :MLOAD(contractHashId)

    $ => B                      :HASHP1(E)
    $ => RCX                    :HASHP1(E)
    $ => D                      :HASHP1(E)
    $ => A                      :HASHP1(E)
    2**24 * B + 2**16 * RCX + 2**8 * D + A => C

    ; 28 bytes

    $ => B                      :HASHP1(E)
    $ => RCX                    :HASHP1(E)
    $ => D                      :HASHP1(E)
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

    ; 24 bytes

    $ => B                      :HASHP1(E)
    $ => RCX                    :HASHP1(E)
    $ => D                      :HASHP1(E)
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

    ; 20 bytes

    $ => B                      :HASHP1(E)
    $ => RCX                    :HASHP1(E)
    $ => D                      :HASHP1(E)
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

    ; 16 bytes

    $ => B                      :HASHP1(E)
    $ => RCX                    :HASHP1(E)
    $ => D                      :HASHP1(E)
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

    ; 12 bytes

    $ => B                      :HASHP1(E)
    $ => RCX                    :HASHP1(E)
    $ => D                      :HASHP1(E)
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

    ; 8 bytes

    $ => B                      :HASHP1(E)
    $ => RCX                    :HASHP1(E)
    $ => D                      :HASHP1(E)
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

    ; 4 bytes

    $ => B                      :HASHP1(E)
    $ => RCX                    :HASHP1(E)
    $ => D                      :HASHP1(E)
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => E

    32 => D                     :RETURN

_readPushX:
    %MAX_CNT_STEPS - STEP - 20 - D :JMPN(outOfCountersStep)
    D => A,E                    :MSTORE(pushBytes)

    $ => B                      :MLOAD(contractHashId)

readPushBytes:
    B => E                     :JMP(@readPushBytes + E)

    0 => RCX, B, D, A, C       :JMP(readPushBytes_1)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_2)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_3)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_4)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_5)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_6)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_7)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_8)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_9)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_10)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_11)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_12)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_13)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_14)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_15)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_16)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_17)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_18)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_19)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_20)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_21)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_22)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_23)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_24)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_25)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_26)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_27)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_28)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_29)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_30)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_31)
    0 => RCX, B, D, A, C       :JMP(readPushBytes_32)


readPushBytes_32:
    $ => B                      :HASHP1(E)
readPushBytes_31:
    $ => RCX                    :HASHP1(E)
readPushBytes_30:
    $ => D                      :HASHP1(E)
readPushBytes_29:
    $ => A                      :HASHP1(E)
    2**24 * B + 2**16 * RCX + 2**8 * D + A => C

readPushBytes_28:
    $ => B                      :HASHP1(E)
readPushBytes_27:
    $ => RCX                    :HASHP1(E)
readPushBytes_26:
    $ => D                      :HASHP1(E)
readPushBytes_25:
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

readPushBytes_24:
    $ => B                      :HASHP1(E)
readPushBytes_23:
    $ => RCX                    :HASHP1(E)
readPushBytes_22:
    $ => D                      :HASHP1(E)
readPushBytes_21:
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

readPushBytes_20:
    $ => B                      :HASHP1(E)
readPushBytes_19:
    $ => RCX                    :HASHP1(E)
readPushBytes_18:
    $ => D                      :HASHP1(E)
readPushBytes_17:
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

readPushBytes_16:
    $ => B                      :HASHP1(E)
readPushBytes_15:
    $ => RCX                    :HASHP1(E)
readPushBytes_14:
    $ => D                      :HASHP1(E)
readPushBytes_13:
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

readPushBytes_12:
    $ => B                      :HASHP1(E)
readPushBytes_11:
    $ => RCX                    :HASHP1(E)
readPushBytes_10:
    $ => D                      :HASHP1(E)
readPushBytes_9:
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

readPushBytes_8:
    $ => B                      :HASHP1(E)
readPushBytes_7:
    $ => RCX                    :HASHP1(E)
readPushBytes_6:
    $ => D                      :HASHP1(E)
readPushBytes_5:
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => C

readPushBytes_4:
    $ => B                      :HASHP1(E)
readPushBytes_3:
    $ => RCX                    :HASHP1(E)
readPushBytes_2:
    $ => D                      :HASHP1(E)
readPushBytes_1:
    $ => A                      :HASHP1(E)
    ROTL_C + 2**24 * B + 2**16 * RCX + 2**8 * D + A => E

    $ => D                      :MLOAD(pushBytes), RETURN

VAR GLOBAL tmpVarDaddB
VAR GLOBAL tmpVarBaddB
VAR GLOBAL tmpZkPCaddB
VAR GLOBAL auxBytes

;@info: adds data to batchHashdata byte by byte
;@in: A: bytes to add
;@in D: bytes length
addBatchHashByteByByte:
        %MAX_CNT_STEPS - STEP - 10      :JMPN(outOfCountersStep)
        RR                              :MSTORE(tmpZkPCaddB)
        A                               :MSTORE(auxBytes)
        D                               :MSTORE(tmpVarDaddB)
        B                               :MSTORE(tmpVarBaddB)
        1 => D

utilsAddBatchHashBytebyByteLoop:
        %MAX_CNT_STEPS - STEP - 50          :JMPN(outOfCountersStep)
        %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
        32 - D => D
        $ => A                          :MLOAD(auxBytes), CALL(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
        ; get last byte in A
        0xFFn => B
        $ => A                          :AND
        D => B
        ; add last byte to batchHashData
        1 => D                          :CALL(addBatchHashData); in:[D: length of the hash]
        ; check loop
        B => D
        ; D + 1 => D, we set 33 instead of 32 to earn 1 step
        33 - D => D
        $ => B                          :MLOAD(tmpVarDaddB)
        D - B - 1                       :JMPN(utilsAddBatchHashBytebyByteLoop)
        $ => B                          :MLOAD(tmpVarBaddB)
        $ => RR                         :MLOAD(tmpZkPCaddB)
                                        :RETURN

VAR GLOBAL startsWithEF
VAR GLOBAL tmpVarAEF
VAR GLOBAL tmpVarBEF
VAR GLOBAL tmpVarCEF
VAR GLOBAL tmpVarDEF
VAR GLOBAL tmpVarEEF
VAR GLOBAL tmpZkPCEF
; @info check bytecode first byte != 0xEF as defined in EIP-3541 (https://eips.ethereum.org/EIPS/eip-3541)
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {startsWithEF} flag to indicate if first deployed byte on the bytecode is 0xEF
checkBytecodeStartsEF:
    %MAX_CNT_STEPS - STEP - 50      :JMPN(outOfCountersStep)
    ; save temporary registers
    A                               :MSTORE(tmpVarAEF)
    B                               :MSTORE(tmpVarBEF)
    C                               :MSTORE(tmpVarCEF)
    D                               :MSTORE(tmpVarDEF)
    E                               :MSTORE(tmpVarEEF)
    RR                              :MSTORE(tmpZkPCEF)

    ; set flag to 0
    0                               :MSTORE(startsWithEF)

    ; check length
    $                               :MLOAD(memSizeLinearPoseidon),JMPZ(checkBytecodeStartsEFend)

    ; load memOffset
    $ => E                          :MLOAD(memOffsetLinearPoseidon)

    ; get 1 byte from memory
    1 => C                          :CALL(MLOADX) ; in: [E: offset, C: length] out: [A: value , E: new offset]
    31 => D                         :CALL(SHRarith) ; in: [A: value, D: #bytes to right shift] out: [A: shifted result]

    ; check if byte read is equal to 0xEF
    %BYTECODE_STARTS_EF - A         :JMPNZ(checkBytecodeStartsEFend)
    1                               :MSTORE(startsWithEF)

checkBytecodeStartsEFend:
    ; set back tmp registers
    $ => RR         :MLOAD(tmpZkPCEF)
    $ => A          :MLOAD(tmpVarAEF)
    $ => B          :MLOAD(tmpVarBEF)
    $ => C          :MLOAD(tmpVarCEF)
    $ => D          :MLOAD(tmpVarDEF)
    $ => E          :MLOAD(tmpVarEEF), RETURN

VAR GLOBAL tmpVarAhashP
VAR GLOBAL tmpVarBhashP
VAR GLOBAL tmpVarChashP
VAR GLOBAL tmpVarEhashP
VAR GLOBAL tmpZkPChashP
VAR GLOBAL memOffsetLinearPoseidon
VAR GLOBAL memSizeLinearPoseidon
; @info Computes hash bytecode from memory bytes
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {memSize} memory size to read bytes from
; @out D => resulting linear poseidon
hashPoseidonLinearFromMemory:
    %MAX_CNT_STEPS - STEP - 50          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    A                               :MSTORE(tmpVarAhashP)
    B                               :MSTORE(tmpVarBhashP)
    C                               :MSTORE(tmpVarChashP)
    E                               :MSTORE(tmpVarEhashP)
    RR                              :MSTORE(tmpZkPChashP)
    $ => E                          :MLOAD(memOffsetLinearPoseidon)
    $ => C                          :MLOAD(memSizeLinearPoseidon)
    0 => D
    C                               :JMPZ(hashPoseidonReturn)
    ; check poseidon counters
    ; 56 is the value used by the prover to increment poseidon counters depending on the hash length
    C                                                       :MSTORE(arithA)
    56                                                      :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => B                                                  :MLOAD(arithRes1)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 1 - B            :JMPN(outOfCountersPoseidon)
    %MAX_CNT_PADDING_PG_LIMIT - CNT_PADDING_PG - 1 - B      :JMPN(outOfCountersPadding)

    ; get a new hashPId
    $ => B                          :MLOAD(nextHashPId)
    B                               :MSTORE(tmpContractHashId)
    B + 1                           :MSTORE(nextHashPId)
    32 => D
    0 => HASHPOS

hashPoseidonLoop:
    %MAX_CNT_STEPS - STEP - 50 :JMPN(outOfCountersStep)

    C               :JMPZ(hashPoseidonEnd)
    C - 32          :JMPN(hashPoseidonFinal)
                    :CALL(MLOAD32)
    E => B
    $ => E          :MLOAD(tmpContractHashId)
    A               :HASHP(E)
    B => E
    C - 32 => C     :JMP(hashPoseidonLoop)


hashPoseidonFinal:
                    :CALL(MLOADX)
    32 - C => D     :CALL(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    $ => E          :MLOAD(tmpContractHashId)
    C => D
    A               :HASHP(E)

hashPoseidonEnd:
    $ => E          :MLOAD(tmpContractHashId)
    HASHPOS         :HASHPLEN(E)
    $ => D          :HASHPDIGEST(E)

hashPoseidonReturn:
    $ => RR         :MLOAD(tmpZkPChashP)
    $ => A          :MLOAD(tmpVarAhashP)
    $ => B          :MLOAD(tmpVarBhashP)
    $ => C          :MLOAD(tmpVarChashP)
    $ => E          :MLOAD(tmpVarEhashP), RETURN

VAR GLOBAL tmpVarBmask
; @info Mask address to 20 bytes
; @in A => address not masked
; @out A => masked address
maskAddress:
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    B               :MSTORE(tmpVarBmask)
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn => B
    $ => A          :AND
    $ => B          :MLOAD(tmpVarBmask), RETURN

VAR GLOBAL tmpVarAmulmod
VAR GLOBAL tmpVarBmulmod
VAR GLOBAL tmpVarDmulmod
VAR GLOBAL tmpVarEmulmod
VAR GLOBAL tmpZkPCmulmod
; @info (A*B)%C => C
; @in A
; @in B
; @in C
; @out C
utilMULMOD:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 4    :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 2      :JMPN(outOfCountersArith)

    RR              :MSTORE(tmpZkPCmulmod)
    A               :MSTORE(tmpVarAmulmod)
    B               :MSTORE(tmpVarBmulmod)
    D               :MSTORE(tmpVarDmulmod)
    E               :MSTORE(tmpVarEmulmod)

    ; The following approach will be followed in order to verify the mulmod operation
    ; A * B + 0 = D*2^256 + E
    ; K * N + mulModResult = D*2^256 + E

    ; Since the k can be bigger than 2 and therefore does not fit in a register, we split it in the
    ; most significant and less significant part:

    ; (k.l + k.h * 2) * N + mulModResult = (D1 + D2) * 2 + E
    ; And divide this operation in 2 which fits in 2 digits

    ;k.l * N + mulModResult = D1 * 2 + E
    ;k.h * 2 * N  = D2 * 2 --> k.h  * N  = D2

    ; Mul operation with Arith
    $${var _mulMod = A * B}
    A               :MSTORE(arithA)
    ; here we perform the: A * B + 0 = D*2^256 + E
    ; result is stored in: arithRes1(E) and mulArithOverflowValue(D)
    B               :MSTORE(arithB), CALL(mulARITH)
    C => A
    ; Check if modulus is 0 or 1
    2 => B
    $               :LT, JMPC(zeroOneMod)
    ; Now we will try to perform the following equation:
    ; (k.l + k.h * 2) * N + mulModResult = (D1 + D2) * 2 + E

    ${(_mulMod / C) >> 256} => B     ; k.h
    ; We can jump with Js, because later it's all verified by the ARITH
    ; the two paths must be mutually exclusive.
    ; mulModNoKH: if kh is non zero, not found a solution only with kl
    ${cond(B == 0)}  :JMPN(mulModNoKH)

    ; in case of malicious prover, check that B was different of zero to
    ; avoid dual path.
    0 => A
    0       :EQ ; assert B != 0

    ; Since there's k.h we will split the equation in those 2
    ;k.l * N + mulModResult = D1 * 2 + E
    ;k.h * 2 * N  = D2 * 2 --> k.h  * N  = D2

    ; k.h  * N  = D2
    ; B * A + 0 = 0 * 2 + E
    ; D2 must be less than 2
    C => A ; Modulus
    0 => C, D
    ${B * A} => E   :MSTORE(tmpVarDmulmod), ARITH ; D2

    ; k.l * N + mulModResult = D1 * 2 + E
    ; B * A + C = D*2^256 + E
    ; remember that:
    ; result of mul is stored in: arithRes1(E) and mulArithOverflowValue(D)

    ${(_mulMod / A) % (1 << 256)} => B   ; k.l
    ${_mulMod % A} => C        ; mulModResult
    ${(B * A + C) >> 256} => D ; D1
    $               :MLOAD(arithRes1), ARITH

    ; Finally we need to assert the following:
    ; N>resultModulus
    ; D1 + D2 = D
    ; N>resultModulus   ; LT; ASSERT
    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT

    ; Assert D1 + D2 = D ; ADD ;ASSERT
    D => A ; D1
    $ => B          :MLOAD(tmpVarDmulmod) ;D2

    ; verify no carry, because D = D1 + D2 must be less than 2**256
    ; to pass arithmetic equation A * B + C = D * 2**256 + op
    $ => A          :ADD,JMPC(failAssert)
    $               :MLOAD(mulArithOverflowValue), ASSERT, JMP(utilMULMODend)

mulModNoKH:
    ; if theres no K.h the equation is simplified as:
    ; K * N + mulModResult = D*2^256 + E
    ; B * A + C = D*2^256 + E

    C => A ; Modulus on A
    ${(_mulMod / A)} => B   ; k
    ${_mulMod % A} => C     ; mulModResult
    $ => D         :MLOAD(mulArithOverflowValue)
    $              :MLOAD(arithRes1), ARITH

    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT, JMP(utilMULMODend)

zeroOneMod:
    0 => C

utilMULMODend:
    $ => A          :MLOAD(tmpVarAmulmod)
    $ => B          :MLOAD(tmpVarBmulmod)
    $ => D          :MLOAD(tmpVarDmulmod)
    $ => RR         :MLOAD(tmpZkPCmulmod)
    $ => E          :MLOAD(tmpVarEmulmod), RETURN

VAR GLOBAL tmpVarBexp
VAR GLOBAL tmpVarCexp
VAR GLOBAL tmpVarEexp
VAR GLOBAL tmpZkPCexp

;@info exp(A,D) --> A^D
;@in A, D => A^D
;@out A => result
expAD:
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 20       :JMPN(outOfCountersStep)
    RR              :MSTORE(tmpZkPCexp)
    B               :MSTORE(tmpVarBexp)
    C               :MSTORE(tmpVarCexp)
    E               :MSTORE(tmpVarEexp)
    ;E base
    A => E
    ;B exp
    D => B
    0 => A
    ;if exp == 0 --> expAD0
    $               :EQ,JMPC(expAD0)
    ;A base
    E => A
    0 => B
    ;if base == 0 --> expA0D
    $               :EQ,JMPC(expA0D)
    1 => C
    D => B          :CALL(getLenBits)  ;A exp bits length

    ; check zk-counters on each loop (A loops)
    ; - 3 ARITH: 1 in divARITH + 1 in 2*mulARITH
    ; - 5 BINARIES: 5 in divARITH
    ; - 100 steps (rounded up): 37 in divARITH + 11 in 2*mulARITH + 18 self
    %MAX_CNT_BINARY - CNT_BINARY - 2*A  :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 50*A        :JMPN(outOfCountersStep)

expADloop:
    ;A exp
    D => A
    0 => B
    ;if exp == 0 --> expADend
    $               :EQ,JMPC(expADend)
    A               :MSTORE(arithA)
    ;divARITH --> exp/2
    2               :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    ;D = exp/2
    $ => D          :MLOAD(arithRes1)
    ;A = exp%2 (0 or 1)
    $ => A          :MLOAD(arithRes2)
    0 => B
    ;if exp%2 == 0 --> expADloop0
    $               :EQ,JMPC(expADloop0)
    E               :MSTORE(arithA)
    ;mulARITH --> E*C
    C               :MSTORE(arithB), CALL(mulARITH)
     ;C = E*C (acc = bp*acc)
    $ => C          :MLOAD(arithRes1)

expADloop0:
    E               :MSTORE(arithA)
    ;mulARITH --> E*E
    E               :MSTORE(arithB), CALL(mulARITH)
    ;E = E*E (bp = bp*bp)
    $ => E          :MLOAD(arithRes1), JMP(expADloop)
;if base == 0, result0
expA0D:
    0 => C
    0 => D          :JMP(expADend)
 ;if exp == 0, result 1
expAD0:
    1 => C
    0 => D

expADend:
    C => A
    $ => B          :MLOAD(tmpVarBexp)
    $ => C          :MLOAD(tmpVarCexp)
    $ => RR         :MLOAD(tmpZkPCexp)
    $ => E          :MLOAD(tmpVarEexp), RETURN

;@info function to force a failed assert
failAssert:
    1 => A
    2               :ASSERT

VAR GLOBAL tmpZkPCVerifyMerkleProof
;@info verifies L1Info data with sibilings
;@in A: ger
;@in B: blockhashL1
;@in C: timestamp
verifyMerkleProof:
    ; check zk-counters
    $ => E                                      :MLOAD(cntKeccakPreProcess)

    ; 1 keccak for the leaf and 32 for the L1InfoTree
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - E - 33   :JMPN(outOfCountersKeccak)
    ; 7 steps at most per bit + 21 statics
    %MAX_CNT_STEPS - STEP - 7 * 32 - 21         :JMPN(outOfCountersStep)

    RR                                          :MSTORE(tmpZkPCVerifyMerkleProof)

    ;;;;;;;;;;;;;;;;;;;;;
    ;; compute leaf value
    ;;;;;;;;;;;;;;;;;;;;;

    ; new keccak address
    $ => E                                  :MLOAD(lastHashKIdUsed)
    E + 1 => E                              :MSTORE(lastHashKIdUsed)

    ; add gerL1InfoTree (32 bytes)
    0 => HASHPOS
    32 => D
    A                                       :HASHK(E)

    ; add blockHashL1 (32 bytes)
    B                                       :HASHK(E)

    ; add timestamp (8 bytes)
    8 => D
    C                                       :HASHK(E)

    ; compute l1InfoTree Leaf value
    HASHPOS                                 :HASHKLEN(E)
    $ => C                                  :HASHKDIGEST(E) ; initial value

    ; initialization registers for smt verify
    0 => D, A

    $ => B                                  :MLOAD(indexL1InfoTree)

    ; prepare new hash
    $ => E                                  :MLOAD(lastHashKIdUsed)
    E + 1 => E                              :MSTORE(lastHashKIdUsed)
    32 => D

    ; - Start loop 32 levels:
    ;    - provide each 'indexL1InfoTree' bit to either hash left/right the merkle tree nodes
    ;    - compute linear combination of 'indexL1InfoTree' bits to match the 'indexL1InfoTree' itself at the end of the loop

    ; BIT 0
    0 => HASHPOS
    ${B & 0x00000001}                           :JMPZ(hashLeft0)

hashRight0:
    ${getSmtProof(mem.indexL1InfoTree, 0)}      :HASHK(E+0)
    C                                           :HASHK(E+0)
    A + 0x00000001 => A                         :JMP(hashBranchEnd0)

hashLeft0:
    C                                           :HASHK(E+0)
    ${getSmtProof(mem.indexL1InfoTree, 0)}      :HASHK(E+0)

hashBranchEnd0:
    HASHPOS                                     :HASHKLEN(E+0)
    $ => C                                      :HASHKDIGEST(E+0)

    ; BIT 1
    0 => HASHPOS
    ${B & 0x00000002}                           :JMPZ(hashLeft1)

hashRight1:
    ${getSmtProof(mem.indexL1InfoTree, 1)}      :HASHK(E+1)
    C                                           :HASHK(E+1)
    A + 0x00000002 => A                         :JMP(hashBranchEnd1)

hashLeft1:
    C                                           :HASHK(E+1)
    ${getSmtProof(mem.indexL1InfoTree, 1)}      :HASHK(E+1)

hashBranchEnd1:
    HASHPOS                                     :HASHKLEN(E+1)
    $ => C                                      :HASHKDIGEST(E+1)

    ; BIT 2
    0 => HASHPOS
    ${B & 0x00000004}                           :JMPZ(hashLeft2)

hashRight2:
    ${getSmtProof(mem.indexL1InfoTree, 2)}      :HASHK(E+2)
    C                                           :HASHK(E+2)
    A + 0x00000004 => A                         :JMP(hashBranchEnd2)

hashLeft2:
    C                                           :HASHK(E+2)
    ${getSmtProof(mem.indexL1InfoTree, 2)}      :HASHK(E+2)

hashBranchEnd2:
    HASHPOS                                     :HASHKLEN(E+2)
    $ => C                                      :HASHKDIGEST(E+2)

    ; BIT 3
    0 => HASHPOS
    ${B & 0x00000008}                           :JMPZ(hashLeft3)

hashRight3:
    ${getSmtProof(mem.indexL1InfoTree, 3)}      :HASHK(E+3)
    C                                           :HASHK(E+3)
    A + 0x00000008 => A                         :JMP(hashBranchEnd3)

hashLeft3:
    C                                           :HASHK(E+3)
    ${getSmtProof(mem.indexL1InfoTree, 3)}      :HASHK(E+3)

hashBranchEnd3:
    HASHPOS                                     :HASHKLEN(E+3)
    $ => C                                      :HASHKDIGEST(E+3)

    ; BIT 4
    0 => HASHPOS
    ${B & 0x00000010}                           :JMPZ(hashLeft4)

hashRight4:
    ${getSmtProof(mem.indexL1InfoTree, 4)}      :HASHK(E+4)
    C                                           :HASHK(E+4)
    A + 0x00000010 => A                         :JMP(hashBranchEnd4)

hashLeft4:
    C                                           :HASHK(E+4)
    ${getSmtProof(mem.indexL1InfoTree, 4)}      :HASHK(E+4)

hashBranchEnd4:
    HASHPOS                                     :HASHKLEN(E+4)
    $ => C                                      :HASHKDIGEST(E+4)

    ; BIT 5
    0 => HASHPOS
    ${B & 0x00000020}                           :JMPZ(hashLeft5)

hashRight5:
    ${getSmtProof(mem.indexL1InfoTree, 5)}      :HASHK(E+5)
    C                                           :HASHK(E+5)
    A + 0x00000020 => A                         :JMP(hashBranchEnd5)

hashLeft5:
    C                                           :HASHK(E+5)
    ${getSmtProof(mem.indexL1InfoTree, 5)}      :HASHK(E+5)

hashBranchEnd5:
    HASHPOS                                     :HASHKLEN(E+5)
    $ => C                                      :HASHKDIGEST(E+5)

    ; BIT 6
    0 => HASHPOS
    ${B & 0x00000040}                           :JMPZ(hashLeft6)

hashRight6:
    ${getSmtProof(mem.indexL1InfoTree, 6)}      :HASHK(E+6)
    C                                           :HASHK(E+6)
    A + 0x00000040 => A                         :JMP(hashBranchEnd6)

hashLeft6:
    C                                           :HASHK(E+6)
    ${getSmtProof(mem.indexL1InfoTree, 6)}      :HASHK(E+6)

hashBranchEnd6:
    HASHPOS                                     :HASHKLEN(E+6)
    $ => C                                      :HASHKDIGEST(E+6)

    ; BIT 7
    0 => HASHPOS
    ${B & 0x00000080}   :JMPZ(hashLeft7)

hashRight7:
    ${getSmtProof(mem.indexL1InfoTree, 7)}      :HASHK(E+7)
    C                                           :HASHK(E+7)
    A + 0x00000080 => A                         :JMP(hashBranchEnd7)

hashLeft7:
    C                                           :HASHK(E+7)
    ${getSmtProof(mem.indexL1InfoTree, 7)}      :HASHK(E+7)

hashBranchEnd7:
    HASHPOS                                     :HASHKLEN(E+7)
    $ => C                                      :HASHKDIGEST(E+7)

    ; BIT 8
    0 => HASHPOS
    ${B & 0x00000100}                           :JMPZ(hashLeft8)

hashRight8:
    ${getSmtProof(mem.indexL1InfoTree, 8)}      :HASHK(E+8)
    C                                           :HASHK(E+8)
    A + 0x00000100 => A                         :JMP(hashBranchEnd8)

hashLeft8:
    C                                           :HASHK(E+8)
    ${getSmtProof(mem.indexL1InfoTree, 8)}      :HASHK(E+8)

hashBranchEnd8:
    HASHPOS                                     :HASHKLEN(E+8)
    $ => C                                      :HASHKDIGEST(E+8)

    ; BIT 9
    0 => HASHPOS
    ${B & 0x00000200}                           :JMPZ(hashLeft9)

hashRight9:
    ${getSmtProof(mem.indexL1InfoTree, 9)}      :HASHK(E+9)
    C                                           :HASHK(E+9)
    A + 0x00000200 => A                         :JMP(hashBranchEnd9)

hashLeft9:
    C                                           :HASHK(E+9)
    ${getSmtProof(mem.indexL1InfoTree, 9)}      :HASHK(E+9)

hashBranchEnd9:
    HASHPOS                                     :HASHKLEN(E+9)
    $ => C                                      :HASHKDIGEST(E+9)

    ; BIT 10
    0 => HASHPOS
    ${B & 0x00000400}                           :JMPZ(hashLeft10)

hashRight10:
    ${getSmtProof(mem.indexL1InfoTree, 10)}     :HASHK(E+10)
    C                                           :HASHK(E+10)
    A + 0x00000400 => A                         :JMP(hashBranchEnd10)

hashLeft10:
    C                                           :HASHK(E+10)
    ${getSmtProof(mem.indexL1InfoTree, 10)}     :HASHK(E+10)

hashBranchEnd10:
    HASHPOS                                     :HASHKLEN(E+10)
    $ => C                                      :HASHKDIGEST(E+10)

    ; BIT 11
    0 => HASHPOS
    ${B & 0x00000800}                           :JMPZ(hashLeft11)

hashRight11:
    ${getSmtProof(mem.indexL1InfoTree, 11)}     :HASHK(E+11)
    C                                           :HASHK(E+11)
    A + 0x00000800 => A                         :JMP(hashBranchEnd11)

hashLeft11:
    C                                           :HASHK(E+11)
    ${getSmtProof(mem.indexL1InfoTree, 11)}     :HASHK(E+11)

hashBranchEnd11:
    HASHPOS                                     :HASHKLEN(E+11)
    $ => C                                      :HASHKDIGEST(E+11)


    ; BIT 12
    0 => HASHPOS
    ${B & 0x00001000}                           :JMPZ(hashLeft12)

hashRight12:
    ${getSmtProof(mem.indexL1InfoTree, 12)}     :HASHK(E+12)
    C                                           :HASHK(E+12)
    A + 0x00001000 => A                         :JMP(hashBranchEnd12)

hashLeft12:
    C                                           :HASHK(E+12)
    ${getSmtProof(mem.indexL1InfoTree, 12)}     :HASHK(E+12)

hashBranchEnd12:
    HASHPOS                                     :HASHKLEN(E+12)
    $ => C                                      :HASHKDIGEST(E+12)

    ; BIT 13
    0 => HASHPOS
    ${B & 0x00002000}                           :JMPZ(hashLeft13)

hashRight13:
    ${getSmtProof(mem.indexL1InfoTree, 13)}     :HASHK(E+13)
    C                                           :HASHK(E+13)
    A + 0x00002000 => A                         :JMP(hashBranchEnd13)

hashLeft13:
    C                                           :HASHK(E+13)
    ${getSmtProof(mem.indexL1InfoTree, 13)}     :HASHK(E+13)

hashBranchEnd13:
    HASHPOS                                     :HASHKLEN(E+13)
    $ => C                                      :HASHKDIGEST(E+13)

    ; BIT 14
    0 => HASHPOS
    ${B & 0x00004000}                           :JMPZ(hashLeft14)

hashRight14:
    ${getSmtProof(mem.indexL1InfoTree, 14)}     :HASHK(E+14)
    C                                           :HASHK(E+14)
    A + 0x00004000 => A                         :JMP(hashBranchEnd14)

hashLeft14:
    C                                           :HASHK(E+14)
    ${getSmtProof(mem.indexL1InfoTree, 14)}     :HASHK(E+14)

hashBranchEnd14:
    HASHPOS                                     :HASHKLEN(E+14)
    $ => C                                      :HASHKDIGEST(E+14)

    ; BIT 15
    0 => HASHPOS
    ${B & 0x00008000}                           :JMPZ(hashLeft15)

hashRight15:
    ${getSmtProof(mem.indexL1InfoTree, 15)}     :HASHK(E+15)
    C                                           :HASHK(E+15)
    A + 0x00008000 => A                         :JMP(hashBranchEnd15)

hashLeft15:
    C                                           :HASHK(E+15)
    ${getSmtProof(mem.indexL1InfoTree, 15)}     :HASHK(E+15)

hashBranchEnd15:
    HASHPOS                                     :HASHKLEN(E+15)
    $ => C                                      :HASHKDIGEST(E+15)

    ; BIT 16
    0 => HASHPOS
    ${B & 0x00010000}                           :JMPZ(hashLeft16)

hashRight16:
    ${getSmtProof(mem.indexL1InfoTree, 16)}     :HASHK(E+16)
    C                                           :HASHK(E+16)
    A + 0x00010000 => A                         :JMP(hashBranchEnd16)

hashLeft16:
    C                                           :HASHK(E+16)
    ${getSmtProof(mem.indexL1InfoTree, 16)}     :HASHK(E+16)

hashBranchEnd16:
    HASHPOS                                     :HASHKLEN(E+16)
    $ => C                                      :HASHKDIGEST(E+16)

    ; BIT 17
    0 => HASHPOS
    ${B & 0x00020000}                           :JMPZ(hashLeft17)

hashRight17:
    ${getSmtProof(mem.indexL1InfoTree, 17)}     :HASHK(E+17)
    C                                           :HASHK(E+17)
    A + 0x00020000 => A                         :JMP(hashBranchEnd17)

hashLeft17:
    C                                           :HASHK(E+17)
    ${getSmtProof(mem.indexL1InfoTree, 17)}     :HASHK(E+17)

hashBranchEnd17:
    HASHPOS                                     :HASHKLEN(E+17)
    $ => C                                      :HASHKDIGEST(E+17)

    ; BIT 18
    0 => HASHPOS
    ${B & 0x00040000}                           :JMPZ(hashLeft18)

hashRight18:
    ${getSmtProof(mem.indexL1InfoTree, 18)}     :HASHK(E+18)
    C                                           :HASHK(E+18)
    A + 0x00040000 => A                         :JMP(hashBranchEnd18)

hashLeft18:
    C                                           :HASHK(E+18)
    ${getSmtProof(mem.indexL1InfoTree, 18)}     :HASHK(E+18)

hashBranchEnd18:
    HASHPOS                                     :HASHKLEN(E+18)
    $ => C                                      :HASHKDIGEST(E+18)

    ; BIT 19
    0 => HASHPOS
    ${B & 0x00080000}                           :JMPZ(hashLeft19)

hashRight19:
    ${getSmtProof(mem.indexL1InfoTree, 19)}     :HASHK(E+19)
    C                                           :HASHK(E+19)
    A + 0x00080000 => A                         :JMP(hashBranchEnd19)

hashLeft19:
    C                                           :HASHK(E+19)
    ${getSmtProof(mem.indexL1InfoTree, 19)}     :HASHK(E+19)

hashBranchEnd19:
    HASHPOS                                     :HASHKLEN(E+19)
    $ => C                                      :HASHKDIGEST(E+19)

    ; BIT 20
    0 => HASHPOS
    ${B & 0x00100000}                           :JMPZ(hashLeft20)

hashRight20:
    ${getSmtProof(mem.indexL1InfoTree, 20)}     :HASHK(E+20)
    C                                           :HASHK(E+20)
    A + 0x00100000 => A                         :JMP(hashBranchEnd20)

hashLeft20:
    C                                           :HASHK(E+20)
    ${getSmtProof(mem.indexL1InfoTree, 20)}     :HASHK(E+20)

hashBranchEnd20:
    HASHPOS                                     :HASHKLEN(E+20)
    $ => C                                      :HASHKDIGEST(E+20)

    ; BIT 21
    0 => HASHPOS
    ${B & 0x00200000}                           :JMPZ(hashLeft21)

hashRight21:
    ${getSmtProof(mem.indexL1InfoTree, 21)}     :HASHK(E+21)
    C                                           :HASHK(E+21)
    A + 0x00200000 => A                         :JMP(hashBranchEnd21)

hashLeft21:
    C                                           :HASHK(E+21)
    ${getSmtProof(mem.indexL1InfoTree, 21)}     :HASHK(E+21)

hashBranchEnd21:
    HASHPOS                                     :HASHKLEN(E+21)
    $ => C                                      :HASHKDIGEST(E+21)

    ; BIT 22
    0 => HASHPOS
    ${B & 0x00400000}                           :JMPZ(hashLeft22)

hashRight22:
    ${getSmtProof(mem.indexL1InfoTree, 22)}     :HASHK(E+22)
    C                                           :HASHK(E+22)
    A + 0x00400000 => A                         :JMP(hashBranchEnd22)

hashLeft22:
    C                                           :HASHK(E+22)
    ${getSmtProof(mem.indexL1InfoTree, 22)}     :HASHK(E+22)

hashBranchEnd22:
    HASHPOS                                     :HASHKLEN(E+22)
    $ => C                                      :HASHKDIGEST(E+22)

    ; BIT 23
    0 => HASHPOS
    ${B & 0x00800000}                           :JMPZ(hashLeft23)

hashRight23:
    ${getSmtProof(mem.indexL1InfoTree, 23)}     :HASHK(E+23)
    C                                           :HASHK(E+23)
    A + 0x00800000 => A                         :JMP(hashBranchEnd23)

hashLeft23:
    C                                           :HASHK(E+23)
    ${getSmtProof(mem.indexL1InfoTree, 23)}     :HASHK(E+23)

hashBranchEnd23:
    HASHPOS                                     :HASHKLEN(E+23)
    $ => C                                      :HASHKDIGEST(E+23)

    ; BIT 24
    0 => HASHPOS
    ${B & 0x01000000}                           :JMPZ(hashLeft24)

hashRight24:
    ${getSmtProof(mem.indexL1InfoTree, 24)}     :HASHK(E+24)
    C                                           :HASHK(E+24)
    A + 0x01000000 => A                         :JMP(hashBranchEnd24)

hashLeft24:
    C                                           :HASHK(E+24)
    ${getSmtProof(mem.indexL1InfoTree, 24)}     :HASHK(E+24)

hashBranchEnd24:
    HASHPOS                                     :HASHKLEN(E+24)
    $ => C                                      :HASHKDIGEST(E+24)

    ; BIT 25
    0 => HASHPOS
    ${B & 0x02000000}                           :JMPZ(hashLeft25)

hashRight25:
    ${getSmtProof(mem.indexL1InfoTree, 25)}     :HASHK(E+25)
    C                                           :HASHK(E+25)
    A + 0x02000000 => A                         :JMP(hashBranchEnd25)

hashLeft25:
    C                                           :HASHK(E+25)
    ${getSmtProof(mem.indexL1InfoTree, 25)}     :HASHK(E+25)

hashBranchEnd25:
    HASHPOS                                     :HASHKLEN(E+25)
    $ => C                                      :HASHKDIGEST(E+25)

    ; BIT 26
    0 => HASHPOS
    ${B & 0x04000000}                           :JMPZ(hashLeft26)

hashRight26:
    ${getSmtProof(mem.indexL1InfoTree, 26)}     :HASHK(E+26)
    C                                           :HASHK(E+26)
    A + 0x04000000 => A                         :JMP(hashBranchEnd26)

hashLeft26:
    C                                           :HASHK(E+26)
    ${getSmtProof(mem.indexL1InfoTree, 26)}     :HASHK(E+26)

hashBranchEnd26:
    HASHPOS                                     :HASHKLEN(E+26)
    $ => C                                      :HASHKDIGEST(E+26)

    ; BIT 27
    0 => HASHPOS
    ${B & 0x08000000}                           :JMPZ(hashLeft27)

hashRight27:
    ${getSmtProof(mem.indexL1InfoTree, 27)}     :HASHK(E+27)
    C                                           :HASHK(E+27)
    A + 0x08000000 => A                         :JMP(hashBranchEnd27)

hashLeft27:
    C                                           :HASHK(E+27)
    ${getSmtProof(mem.indexL1InfoTree, 27)}     :HASHK(E+27)

hashBranchEnd27:
    HASHPOS                                     :HASHKLEN(E+27)
    $ => C                                      :HASHKDIGEST(E+27)

    ; BIT 28
    0 => HASHPOS
    ${B & 0x10000000}                           :JMPZ(hashLeft28)

hashRight28:
    ${getSmtProof(mem.indexL1InfoTree, 28)}     :HASHK(E+28)
    C                                           :HASHK(E+28)
    A + 0x10000000 => A                         :JMP(hashBranchEnd28)

hashLeft28:
    C                                           :HASHK(E+28)
    ${getSmtProof(mem.indexL1InfoTree, 28)}     :HASHK(E+28)

hashBranchEnd28:
    HASHPOS                                     :HASHKLEN(E+28)
    $ => C                                      :HASHKDIGEST(E+28)

    ; BIT 29
    0 => HASHPOS
    ${B & 0x20000000}                           :JMPZ(hashLeft29)

hashRight29:
    ${getSmtProof(mem.indexL1InfoTree, 29)}     :HASHK(E+29)
    C                                           :HASHK(E+29)
    A + 0x20000000 => A                         :JMP(hashBranchEnd29)

hashLeft29:
    C                                           :HASHK(E+29)
    ${getSmtProof(mem.indexL1InfoTree, 29)}     :HASHK(E+29)

hashBranchEnd29:
    HASHPOS                                     :HASHKLEN(E+29)
    $ => C                                      :HASHKDIGEST(E+29)

    ; BIT 30
    0 => HASHPOS
    ${B & 0x40000000}                           :JMPZ(hashLeft30)

hashRight30:
    ${getSmtProof(mem.indexL1InfoTree, 30)}     :HASHK(E+30)
    C                                           :HASHK(E+30)
    A + 0x40000000 => A                         :JMP(hashBranchEnd30)

hashLeft30:
    C                                           :HASHK(E+30)
    ${getSmtProof(mem.indexL1InfoTree, 30)}     :HASHK(E+30)

hashBranchEnd30:
    HASHPOS                                     :HASHKLEN(E+30)
    $ => C                                      :HASHKDIGEST(E+30)

    ; BIT 31
    0 => HASHPOS
    ${B & 0x80000000}                           :JMPZ(hashLeft31)

hashRight31:
    ${getSmtProof(mem.indexL1InfoTree, 31)}     :HASHK(E+31)
    C                                           :HASHK(E+31)
    A + 0x80000000 => A                         :JMP(hashBranchEnd31)

hashLeft31:
    C                                           :HASHK(E+31)
    ${getSmtProof(mem.indexL1InfoTree, 31)}     :HASHK(E+31)

hashBranchEnd31:
    HASHPOS                                     :HASHKLEN(E+31)
    $ => C                                      :HASHKDIGEST(E+31)

    ; verify linear combination of 'indexL1InfoTree'
    B                                       :ASSERT
    E + 31 => E                             :MSTORE(lastHashKIdUsed)


verifyMerkleProofEnd:
    $ => A                        :MLOAD(l1InfoRoot)
    C                             :ASSERT

verifyMerkleProofReturn:
    $ => RR                       :MLOAD(tmpZkPCVerifyMerkleProof)
                                  :RETURN

VAR GLOBAL tmpZkPCreadXFromOffset
VAR GLOBAL readXFromCalldataOffset
VAR GLOBAL readXFromCalldataLength
VAR GLOBAL readXFromCalldataResult
VAR GLOBAL tmpVarAReadXFromOffset
VAR GLOBAL tmpVarBReadXFromOffset
VAR GLOBAL tmpVarCReadXFromOffset
VAR GLOBAL tmpVarDReadXFromOffset
VAR GLOBAL tmpVarEReadXFromOffset
; @info Reads {readXFromCalldataOffset} bytes (max 32) from a given offset in calldata memory. If offset or offset + length exceeds txCalldataLen, zeros are added
; @internalParam {readXFromCalldataOffset} offset to read from calldata
; @internalParam {readXFromCalldataLength} length to read from calldata
; @returns {readXFromCalldataResult} bytes read from calldata
readFromCalldataOffset:
    %MAX_CNT_STEPS - STEP - 100       :JMPN(outOfCountersStep)
    RR              :MSTORE(tmpZkPCreadXFromOffset)
    A               :MSTORE(tmpVarAReadXFromOffset)
    B               :MSTORE(tmpVarBReadXFromOffset)
    C               :MSTORE(tmpVarCReadXFromOffset)
    E               :MSTORE(tmpVarEReadXFromOffset)
    $ => A          :MLOAD(txCalldataLen), JMPZ(return0FromCalldata)
    $ => B          :MLOAD(calldataOffset)
    $ => C          :MLOAD(readXFromCalldataLength)
    $ => E          :MLOAD(readXFromCalldataOffset)
    A - E - 1       :JMPN(return0FromCalldata) ; If offset >= txCalldataLen, return 0
    ; if readOffset + readLength > txCalldataLen, readLength = txCalldataLen - readOffset
    E + C - A       :JMPN(dontLimitLength)
    A - E => C

dontLimitLength:
    $ => CTX        :MLOAD(calldataCTX) ; get calldata context
    B + E => E      :CALL(MLOADX); in: [E: offset, C: length] out: [A: value, E: new offset]
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(readXFromCalldataResult), JMP(readFromCalldataOffsetEnd)

return0FromCalldata:
    0               :MSTORE(readXFromCalldataResult)

readFromCalldataOffsetEnd:
    $ => RR         :MLOAD(tmpZkPCreadXFromOffset)
    $ => A          :MLOAD(tmpVarAReadXFromOffset)
    $ => B          :MLOAD(tmpVarBReadXFromOffset)
    $ => C          :MLOAD(tmpVarCReadXFromOffset)
    $ => E          :MLOAD(tmpVarEReadXFromOffset), RETURN

; @info store calldata pointer to read calldata
saveCalldataPointer:
    %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)
    ; load data: previous CTX & argsOffsetCall
    $ => A, CTX         :MLOAD(originCTX)
    $ => B              :MLOAD(argsOffsetCall)
    ; move to current CTX and store data
    $ => CTX            :MLOAD(currentCTX)
    A                   :MSTORE(calldataCTX)
    B                   :MSTORE(calldataOffset), RETURN