; @info Get absolute value and sign
; @in A => number to convert
; @out A => Absolute value of A
; @out B => Sign of A [1 if negative, 0 positive]
abs:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 20       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    0 => B
    ; if is negative, change sign
    $ => B          :SLT, JMPC(absIsNeg)
                    :RETURN

absIsNeg:
    A => B
    0 => A
    ; 0 - (-A) = A
    $ => A          :SUB
    1 => B          :RETURN


; @info bits length of B
; @in B => number
; @out A => bits length
getLenBits:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    ; store current registries
                               :SAVE(B,C,D,E,RR,RCX)
    ; set C as counter to 0
    0 => C
    B => A

getLenBitsLoop:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    0 => B
    ; if B is zero, finish counter
    $               :EQ,JMPC(getLenBitsEnd)
    ; divide value by 2
    A               :MSTORE(arithA)
    2               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A          :MLOAD(arithRes1)
    ; increase counter
    C + 1 => C      :JMP(getLenBitsLoop)

getLenBitsEnd:
    ; counter to A
    C => A
    ; recover registries
                    :RESTORE, RETURN

VAR GLOBAL __MSTOREX_len
VAR GLOBAL bytesToStore

; @info save value to memory 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @out E => new offset

MSTORE32:
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        A                           :SAVE(B,C,D,E,RR,RCX)
        32 => C                     :MSTORE(__MSTOREX_len), JMP(__MSTOREX_afterSave)

; @info save value to memory < 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @in C => length
; @out E => new offset

MSTOREX:
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        C           :MSTORE(__MSTOREX_len), JMPZ(__MSTOREX_end)

        A           :SAVE(B,C,D,E,RR,RCX)
        C           :JMP_GT(32, errorMLOADMSTORE)

__MSTOREX_afterSave:

        ; verification without binary, required in non trust if E > 2**32, after that will verify two paths
        ; path E < 2**32:
        ;   A0 < 2**32 => JMPN fails (if A0 < 0 then path __errorEmore32bits)
        ;   A7..A1 == 0 because use $0
        ;   A < 2**32
        ;   E == A if not ASSERT fails => E < 2**32
        ;   E >= MAX_MEM_EXPANSION_BYTES ==> errorMLOADMSTORE

        $0{E > 0xFFFFFFFF ? -1:E} => A  :JMPN(__errorEmore32bits)
        E                               :ASSERT,JMP_GE(%MAX_MEM_EXPANSION_BYTES, errorMLOADMSTORE)

        $0{E / 32} => RR                :JMPN(failAssert)
        ; RR = 32 bits positive value

        $BYTE{E%32} => RCX,A
        RCX                             :JMP_GT(31, failAssert)

        ; E === 32 * RR + A (RCX)
        ; E - 32 * RR === A
        ; secure: E < MAX_MEM_EXPANSION_BYTES < 32 bits, RR < 32 bits, 32*RR < 37 bits, all < 38 bits
        E - 32 * RR                 :ASSERT

        RCX + %MEM_ALIGN_LEN * C + %MEM_ALIGN_LEFT_ALIGNMENT => C     :JMP_EQ(%MEM_ALIGN_LEN * 32 + %MEM_ALIGN_LEFT_ALIGNMENT, __MSTORE32_offset0_len32)

        $ => A                  :MLOAD(MEM:RR)
        $ => B                  :MLOAD(MEM:RR+1)

        ${memAlignWR_W0(A,mem.bytesToStore,C)} => D    :MSTORE(MEM:RR)      ; no trust calculate W0
        ${memAlignWR_W1(B,mem.bytesToStore,C)} => E    :MSTORE(MEM:RR + 1)  ; no trust calculate W1

        $                       :MEM_ALIGN_WR,MLOAD(bytesToStore),JMP(__MSTORE32_restore)

__MSTORE32_offset0_len32:
        $ => C                  :MLOAD(bytesToStore)
        C                       :MSTORE(MEM:RR)

__MSTORE32_restore:
        $ => A                  :RESTORE
        __MSTOREX_len + E => E  :RETURN


__MSTOREX_end:
                                :RETURN

; @info get value from memory (32 bytes)
; @in E => offset
; @out A => value
; @out E => new offset

MLOAD32:
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        32 => C                         :SAVE(B,C,D,E,RR,RCX), JMP(__MLOADX_afterSave)

; @info get value from memory (< 32 bytes)
; @in E => offset
; @in C => length
; @out A => value
; @out E => new offset

MLOADX:
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        C                                       :JMP_GT(32, errorMLOADMSTORE)
        C                                       :SAVE(B,C,D,E,RR,RCX), JMPZ(__MLOADX_len0)

__MLOADX_afterSave:

        ; verification without binary, required in non trust if E > 2**32, after that will verify two paths
        ; path E < 2**32:
        ;   A0 < 2**32 => JMPN fails (if A0 < 0 then path __errorEmore32bits)
        ;   A7..A1 == 0 because use $0
        ;   A < 2**32
        ;   E == A if not ASSERT fails => E < 2**32
        ;   E >= MAX_MEM_EXPANSION_BYTES ==> errorMLOADMSTORE

        $0{E > 0xFFFFFFFF ? -1:E} => A  :JMPN(__errorEmore32bits)
        E                               :ASSERT,JMP_GE(%MAX_MEM_EXPANSION_BYTES, errorMLOADMSTORE)

        $0{E / 32} => RR                :JMPN(failAssert)
        ; RR = 32 bits positive value

        $BYTE{E%32} => RCX,A
        RCX                             :JMP_GT(31, failAssert)

        ; E === 32 * RR + A (RCX)
        ; E - 32 * RR === A
        ; secure: E < MAX_MEM_EXPANSION_BYTES < 32 bits, RR < 32 bits, 32*RR < 37 bits, all < 38 bits
        E - 32 * RR                 :ASSERT

        RCX + %MEM_ALIGN_LEN * C + %MEM_ALIGN_LEFT_ALIGNMENT => C     :JMP_EQ(%MEM_ALIGN_LEN * 32 + %MEM_ALIGN_LEFT_ALIGNMENT, __MLOAD32_offset0_len32)

        $ => A                  :MLOAD(MEM:RR)
        $ => B                  :MLOAD(MEM:RR+1)

        $ => A                  :MEM_ALIGN_RD,JMP(__MLOAD32_restore)

__MLOAD32_offset0_len32:
        $ => A                  :MLOAD(MEM:RR)

__MLOAD32_restore:
        $                       :RESTORE,MSTORE(__MSTOREX_len)
        __MSTOREX_len + E => E  :RETURN

__MLOADX_len0:
        0 => A                  :RESTORE, RETURN

__errorEmore32bits:
        ; path E >= 2**32 must be verified (dual path protection)
        ; E >= 2**32 === !(E < 2**32)
        E => A
        2n**32n => B
        ; don't check binary counter, because here was a problem of dual path, if check
        ; before this path was a performance problem. It's only one binary and it's outOfGas
        0   :LT,JMP(errorMLOADMSTORE)

errorMLOADMSTORE:
                    :JMP(outOfGas)

; @info check account is empty ( balance == nonce == code == 0x )
; @in A => address
; @out A => isEmpty => 1 = true, 0 = false
isEmptyAccount:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50                                              :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3                                        :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - %MAX_CNT_POSEIDON_SLOAD_SSTORE*3 :JMPN(outOfCountersPoseidon)

    ; store current registries
                                :SAVE(B,C,D,E,RR,RCX)
    A => E
    ; read balance
    ; set key for smt balance query.
    %SMT_KEY_BALANCE => B
    0 => C
    $ => B                      :SLOAD
    ; balance in A
    0 => A
    ; if balance is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    ; check nonce
    E => A
    ; set key for smt nonce query
    %SMT_KEY_NONCE => B
    ; nonce in B
    $ => B                      :SLOAD
    0 => A
    ; if nonce is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    ; read bytecode
    E => A
    ; set key for smt smart contract query
    %SMT_KEY_SC_CODE => B
    ; sc in B
    $ => B                      :SLOAD
    0 => A
    ; if code is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    1 => A                      :JMP(IsEmptyEnd)

isNotEmptyAccount:
    0 => A                      :JMP(IsEmptyEnd)

IsEmptyEnd:
    ; recover registries
                                :RESTORE,RETURN

; @info Compute gas to send to call following EIP 150
; @in gasCall: gas sent to call
; @out A => min( requested_gas , all_but_one_64th(63/64) )
computeGasSendCall:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 30       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    ; save tmp vars
                            :SAVE(B,C,D,E,RR,RCX)
    ; compute all_but_one_64th gas
    GAS => A

    ; C = [c7, c6, ..., c0]
    ; JMPN instruction assures c0 is within the range [0, 2**32 - 1]
    ${GAS >> 6} => C        :JMPN(failAssert)
    ; We secure D to be less than 32 bits with $0{}
    $0{GAS & 0x3f} => D

    ; since D is assured to be less than 0x40
    ; it is enforced that [c7, c6, ..., c1] are 0 since there is no value multiplied by 64
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, c0 * 64 + d0 could not overflow the field
    C * 64 + D              :ASSERT
    0x3f - D                :JMPN(failAssert) ; D is less than 32 bits, we can use JMPN

    GAS - C => A
    ; gasCall can be more than 32 bits, obtained from stack
    $ => B                  :MLOAD(gasCall)
    ; gas_sent_with_call = min(requested_gas, all_but_one_64th)
    $                       :LT,JMPC(computeGasSendCallEnd)
    ; gas to subtract
    B => A

computeGasSendCallEnd:
    ; restore stored values
                            :RESTORE, RETURN

; @info compute memory expansion gas cost
; @in: lastMemOffset: offset to copy bytes
; @in: lastMemLength: size of the bytes to copy
saveMem:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100      :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 5 :JMPN(outOfCountersBinary)
    A                           :SAVE(B,C,D,E,RR,RCX)
    $ => A                      :MLOAD(lastMemLength)
    ; If no len, no memory expansion
    0 => B
    $                           :EQ, JMPC(saveMemEnd)
    $ => B                      :MLOAD(lastMemOffset)
    ; If the binary has a carry, means the mem expansion is very big. We can jump to oog directly
    ; offset + length in B
    $ => B                      :ADD, JMPC(outOfGas)
    ; check new memory length is lower than 2**22 - 31 - 1 (max supported memory expansion for %TX_GAS_LIMIT of gas)
    %MAX_MEM_EXPANSION_BYTES => A
    $                           :LT,JMPC(outOfGas)


    ; load old memory length, if is greater than new memory length, no expansion cost
    $ => A                      :MLOAD(memLength)
    ; Both A and B are LT than MAX_MEM_EXPANSION_BYTES, this means they are lower than 32 bits, we don't need to use a binary to operate
    A - B                       :JMPN(saveMemGAS, saveMemEnd)

saveMemGAS:
    ; store new memory length
    B => E                          :MSTORE(memLength)
    ; memory_size_word = (memory_byte_size + 31) / 32 in E
    ; ${(B+31)/32} => E
    E + 31 => A

    ; E = [e7, e6, ..., e0]
    ; JMPN instruction assures e0 is within the range [0, 2**32 - 1]
    ${A >> 5} => E              :JMPN(failAssert)
    $0{A & 0x1f} => D

    ; since D is assured to be less than 0x20
    ; it is enforced that [e7, e6, ..., e1] are 0 since there is no value multiplied by 32
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, e0 * 32 + d0 could not overflow the field
    E * 32 + D                  :ASSERT
    0x1f - D                    :JMPN(failAssert) ; D is less than 32 bits, we can use JMPN

    ; memory_cost = (memory_size_word ** 2) / 512 + (3 * memory_size_word) in A
    ; ${E*E/512} + 3*E=> A
    E                           :MSTORE(arithA)
    E                           :MSTORE(arithB), CALL(mulARITH); in: [arithA, arithB] out: [arithRes1: arithA*arithB, mulFlagOverflow: value overflow, mulArithOverflowFlag: set to 1 if operation causes overflow]
    $ => C                      :MLOAD(arithRes1)
    $                           :MLOAD(mulArithOverflowFlag), JMPNZ(outOfGas)
    C                           :MSTORE(arithA)
    512                         :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A                      :MLOAD(arithRes1)
    A + 3*E => A
    $ => B                      :MLOAD(lastMemoryExpansionCost)
    A                           :MSTORE(lastMemoryExpansionCost)
    ; memory_expansion_cost = new_memory_cost - last_memory_cost
    A - B => A
    ; update new gas
    GAS - A => GAS               :JMPN(outOfGas)

saveMemEnd:
    ; restore stored values
                                 :RESTORE, RETURN

VAR GLOBAL arithA
VAR GLOBAL arithB
VAR GLOBAL arithRes1
VAR GLOBAL arithRes2

VAR GLOBAL addArithOverflow
; @info binary addition
; @in: arithA: addend value
; @in: arithB: addend value
; @out: arithRes1: arithA + arithB
addARITH:

    A               :SAVE(B,C,D,E,RR,RCX)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => E          :ADD, MSTORE(arithRes1), JMPC(setAddArithOverflow)
    0               :MSTORE(addArithOverflow), JMP(finishAddArith)

setAddArithOverflow:
    1               :MSTORE(addArithOverflow)

finishAddArith:
    $ => A          :RESTORE, RETURN

; @info binary subtraction
; @in: arithA: minuend value
; @in: arithB: subtrahend value
; @out: arithRes1: arithA - arithB
subARITH:
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 10       :JMPN(outOfCountersStep)
    A               :SAVE(B,C,D,E,RR,RCX)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => A          :SUB,MSTORE(arithRes1)
    $ => A          :RESTORE, RETURN

VAR GLOBAL mulArithOverflowValue
VAR GLOBAL mulArithOverflowFlag
; @info arithmetic multiplication
; @in: arithA: multiplier value
; @in: arithB: multiplicand value
; @out: arithRes1: product of multiplication arithA * arithB
; @out: mulArithOverflowValue: overflow value
; @out: mulArithOverflowFlag: set to 1 if operation causes overflow
mulARITH:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)

    A               :SAVE(B,C,D,E,RR,RCX)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    0 => C
    $${var _mulArith = A * B}
    ${_mulArith >> 256} => D
    ${_mulArith} => E :ARITH

    E               :MSTORE(arithRes1)
    D               :MSTORE(mulArithOverflowValue)
    D => A
    0 => B
    $               :EQ,JMPNC(setMulArithOverflow)
    0               :MSTORE(mulArithOverflowFlag), JMP(finishMulArith)

setMulArithOverflow:
    1               :MSTORE(mulArithOverflowFlag)

finishMulArith:
    $ => A          :RESTORE, RETURN

; @info arithmetic division
; @in: arithA: dividend value
; @in: arithB: divisor value
; @out: arithRes1: quotient of division arithA / arithB
; @out: arithRes2: remainder of division arithA % arithB
divARITH:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)
    A               :SAVE(B,C,D,E,RR,RCX)
    $ => E          :MLOAD(arithA)
    $ => A          :MLOAD(arithB)
    ; Check denominator(A) is not zero
    0 => B
    $               :EQ, JMPC(zeroDiv)

    ; Check if divisor (E) is smaller than denominator E < A
    A => C ; store temporally A in C
    E => A ; divisor
    C => B ; denominator
    $               :LT, JMPC(divisorSmallerDiv)
    C => A

    ${E%A} => C ; remainder
    ${E/A} => B
    0 => D
    E               :ARITH

    B               :MSTORE(arithRes1)
    C               :MSTORE(arithRes2)

    ; check divisor > remainder
    A => B ; divisor
    C => A ; remainder
    $ => A          :LT
    1               :ASSERT
    $ => A          :RESTORE, RETURN

zeroDiv:
    0               :MSTORE(arithRes1)
    0               :MSTORE(arithRes2)
    $ => A          :RESTORE, RETURN

divisorSmallerDiv:
    0               :MSTORE(arithRes1)
    E               :MSTORE(arithRes2)
    $ => A          :RESTORE, RETURN

; @info Shift right D bytes to A
; @in A
; @in D -> WARNING: expect D to be less than 32 bits
; @out A - A >> (8*D) => A
SHRarith:
    %MAX_CNT_STEPS - STEP - 8               :JMPN(outOfCountersStep)

    31 - D      :JMPN(SHRarith_32)
    D           :JMPZ(SHRarith_0)

    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

    32 - D => C :SAVE(B,C,D,E,RCX,RR)
    A => B
    0 => A
    $ => A      :MEM_ALIGN_RD
                :RESTORE, RETURN

SHRarith_32:
    0 => A      :RETURN
SHRarith_0:
                :RETURN

; @info Shift left D bytes to A
; @in A
; @in D -> WARNING: expect D to be less than 32 bits
; @out A - A << (8*D) => A
SHLarith:
    %MAX_CNT_STEPS - STEP - 6               :JMPN(outOfCountersStep)

    31 - D      :JMPN(SHLarith_32)

    D => C      :SAVE(B,C,D,E,RCX,RR),JMPZ(SHLarith_0)

    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)
    0 => B
    $ => A      :MEM_ALIGN_RD
                :RESTORE, RETURN

SHLarith_32:
    0 => A      :RETURN
SHLarith_0:
                :RESTORE, RETURN

; @info Shift right D bits to A
; @in A
; @in D -> WARNING: expect D to be less than 32 bits
; @out A - (A >> D) => A

SHRarithBit:
    %MAX_CNT_STEPS - STEP - 9   :JMPN(outOfCountersStep)
    255 - D                     :JMPN(SHRarithBit_A0)

    D => RR                     :SAVE(B,C,D,E,RCX,RR),JMPZ(SHRarithBit_D0)
    0 => C,B                    :JMP(@SHRarithBit_table + RR)

SHRarithBit_arith:
    %MAX_CNT_ARITH - CNT_ARITH - 1  :JMPN(outOfCountersArith)

    ${(A >> RR) & const.MAX_UINT_256} => D
    ${(A << (256 - RR)) & const.MAX_UINT_256} :ARITH
    D => A                      :RESTORE, RETURN

SHRarithBit_memalign:
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)
    A => B
    0 => A
    $ => A                      :MEM_ALIGN_RD
SHRarithBit_D0:
                                :RESTORE, RETURN
SHRarithBit_A0:
    0 => A                      :RETURN

INCLUDE "tables/shr_bits_table.zkasm"


; @info Shift left D bits to A
; @in A
; @in D -> WARNING: expect D to be less than 32 bits
; @out A - (A << D) => A

SHLarithBit:
    %MAX_CNT_STEPS - STEP - 8   :JMPN(outOfCountersStep)
    255 - D                     :JMPN(SHLarithBit_A0)

    D => RR                     :SAVE(B,C,D,E,RCX,RR),JMPZ(SHLarithBit_D0)
    0 => C,B                    :JMP(@SHLarithBit_table + RR)

SHLarithBit_arith:
    %MAX_CNT_ARITH - CNT_ARITH - 1  :JMPN(outOfCountersArith)

    ${(A >> (256 - RR)) & const.MAX_UINT_256} => D
    ${(A << RR) & const.MAX_UINT_256} => A             :ARITH
                                                       :RESTORE, RETURN
SHLarithBit_memalign:
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)
    $ => A                                  :MEM_ALIGN_RD

SHLarithBit_D0:
                                :RESTORE, RETURN
SHLarithBit_A0:
    0 => A                      :RETURN

INCLUDE "tables/shl_bits_table.zkasm"

; out of counters full tracer event trigger
outOfCountersStep:
    $${eventLog(onError, OOCS)}                     :JMP(handleBatchError)
outOfCountersKeccak:
    $${eventLog(onError, OOCK)}                     :JMP(handleBatchError)
outOfCountersBinary:
    $${eventLog(onError, OOCB)}                     :JMP(handleBatchError)
outOfCountersMemalign:
    $${eventLog(onError, OOCM)}                     :JMP(handleBatchError)
outOfCountersArith:
    $${eventLog(onError, OOCA)}                     :JMP(handleBatchError)
outOfCountersPadding:
    $${eventLog(onError, OOCPA)}                    :JMP(handleBatchError)
outOfCountersPoseidon:
    $${eventLog(onError, OOCPO)}                    :JMP(handleBatchError)
outOfCountersSha256:
    $${eventLog(onError, OOCSH)}                    :JMP(handleBatchError)
invalidChangeL2BlockMinTimestamp:
    $${eventLog(onError, invalid_change_l2_block_min_timestamp)}    :JMP(handleBatchError)
invalidL1InfoTreeIndex:
    $${eventLog(onError, invalid_l1_info_tree_index)}    :JMP(handleBatchError)
outOfGas:
    $${eventLog(onError, OOG)}                      :JMP(handleError)
invalidJump:
    $${eventLog(onError, invalidJump)}              :JMP(handleError)
invalidOpcode:
    $${eventLog(onError, invalidOpcode)}            :JMP(handleError)
stackUnderflow:
    $${eventLog(onError, underflow)}                :JMP(handleError)
stackOverflow:
    $${eventLog(onError, overflow)}                 :JMP(handleError)
deployAddressCollision:
    $${eventLog(onError, invalidAddressCollision)}  :JMP(handleError)
invalidStaticTx:
    $${eventLog(onError, invalidStaticTx)}          :JMP(handleError)
invalidCodeSize:
    $${eventLog(onError, invalidCodeSize)}          :JMP(handleError)
invalidCodeStartsEF:
    $${eventLog(onError, invalidCodeStartsEF)}      :JMP(handleError)

handleError:
    %MAX_CNT_STEPS - STEP - 500         :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2    :JMPN(outOfCountersBinary)
    ;revert all state changes
    $ => SR         :MLOAD(initSR), CALL(revertTouched)
                    :CALL(revertBlockInfoTree)

    $ => A          :MLOAD(originCTX), JMPZ(errorAtFirstContext)
    A => CTX
    ; Add return data context value to origin context
    ; Clear return data context
    0               :MSTORE(retDataCTX)
    CTX             :MSTORE(currentCTX)
    $ => GAS        :MLOAD(gasCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++), JMP(readCode)

handleBatchError:
    ; restore init state root and finish batch
    $ => SR                     :MLOAD(batchSR)
    $${eventLog(onFinishTx)}    :JMP(finalizeBatch)

errorAtFirstContext:
    ; Set tx status to failure
    0               :MSTORE(txStatus)
    ;save Root and jump to send gas to sequencer
    0               :MSTORE(gasRefund)
    ;remaining gas = 0
    0 => GAS        :JMP(sendGasSeq)

;Get offset/32 & offset%32
;@in A offset (offset is assumed to be less than %MAX_MEM_EXPANSION_BYTES)
;@out E offset/32
;@out C offset%32
offsetUtil:
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)

    ; E = [e7, e6, ..., e0]
    ; JMPN instruction assures e0 is within the range [0, 2**32 - 1]
    ${A >> 5} => E                      :JMPN(failAssert)
    $0{A & 0x1F} => C                   :JMP_GT(0x1F, failAssert); C is 32 bits, If C is greater than 31 (remainder), it is an error

    ; since C is assured to be less than 0x20
    ; it is enforced that [e7, e6, ..., e1] are 0 since there is no value multiplied by 32
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, e0 * 32 + c0 could not overflow the field
    E * 32 + C                          :ASSERT, RETURN

;@info: move balances between two accounts
;@in: txSrcAddr: source address
;@in: storageAddr: destination address
;@in: txValue: transaction value
moveBalances:
;;;;;;;;
; evmCALL (Move Balances)
;;;;;;;;
    %MAX_CNT_STEPS - STEP - 50                                              :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 5                                        :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - %MAX_CNT_POSEIDON_SLOAD_SSTORE*4 :JMPN(outOfCountersPoseidon)
    ;Check if is a delegate call
    $ => A                          :MLOAD(isDelegateCall), JMPNZ(endMoveBalances)
    ; Decrement source balance
    $ => A                          :MLOAD(txSrcAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE => B
    0 => C
    ; Balance in A
    $ => A                          :SLOAD
    ; value in B
    $ => B                          :MLOAD(txValue)
    ; Check has enough balance to pay the value. In case not, means we are in a CALL/CALLCODE
    $                               :LT,JMPC(invalidCall)
    ; sourceBalance - value in D
    $ => D                          :SUB
    ; update source balance
    $ => A                          :MLOAD(txSrcAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE => B
    $ => SR                         :SSTORE
    ; Increment destination balance
    $ => A                          :MLOAD(storageAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE  => B
    ; Balance in A
    $ => A                          :SLOAD
    $ => B                          :MLOAD(txValue)
    $ => D                          :ADD
    $ => A                          :MLOAD(storageAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE  => B
    0 => C
    $ => SR                         :SSTORE
endMoveBalances:
                                    :RETURN

invalidCall:
    ; return to origin context
    $ => SR                         :MLOAD(initSR)
    ; if last context, finish tx
    $ => A                          :MLOAD(originCTX),JMPZ(handleGas)
    A => CTX
    0                               :MSTORE(retDataCTX)
    CTX                             :MSTORE(currentCTX)
    $ => A                          :MLOAD(gasCTX)
    GAS + A => GAS
    $ => SP                         :MLOAD(lastSP)
    $ => PC                         :MLOAD(lastPC)
    0                               :MSTORE(SP++), JMP(readCode)

VAR GLOBAL startsWithEF
; @info check bytecode first byte != 0xEF as defined in EIP-3541 (https://eips.ethereum.org/EIPS/eip-3541)
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {startsWithEF} flag to indicate if first deployed byte on the bytecode is 0xEF
checkBytecodeStartsEF:
    %MAX_CNT_STEPS - STEP - 50      :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)

    ; save temporary registers
    A                               :SAVE(B,C,D,E,RCX,RR)

    ; set flag to 0
    0                               :MSTORE(startsWithEF)

    ; check length
    $                               :MLOAD(memSizeLinearPoseidon),JMPZ(checkBytecodeStartsEFend)

    ; load memOffset
    $ => E                          :MLOAD(memOffsetLinearPoseidon)

    ; get 1 byte from memory
    1 => C                          :CALL(MLOADX) ; in: [E: offset, C: length] out: [A: value , E: new offset]

    ; mask first byte
    0xFF00000000000000000000000000000000000000000000000000000000000000n => B
    $ => A                          :AND
    ; check if byte read is equal to 0xEF
    0xEF00000000000000000000000000000000000000000000000000000000000000n => B
    $                               :EQ, JMPNC(checkBytecodeStartsEFend)
    1                               :MSTORE(startsWithEF)

checkBytecodeStartsEFend:
    ; set back tmp registers
    $ => A                          :RESTORE, RETURN

VAR GLOBAL memOffsetLinearPoseidon
VAR GLOBAL memSizeLinearPoseidon
VAR GLOBAL linearPoseidonOutD
; @info Computes hash bytecode from memory bytes
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {memSize} memory size to read bytes from
; @out D => resulting linear poseidon
hashPoseidonLinearFromMemory:
    %MAX_CNT_STEPS - STEP - 50          :JMPN(outOfCountersStep)
    A                               :SAVE(B,C,D,E,RCX,RR)
    $ => E                          :MLOAD(memOffsetLinearPoseidon)
    $ => C                          :MLOAD(memSizeLinearPoseidon)
    0 => D
    C                               :JMPZ(hashPoseidonReturn)
    ; check poseidon counters
    ; 56 is the value used by the prover to increment poseidon counters depending on the hash length
    C                                                       :MSTORE(arithA)
    56                                                      :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => B                                                  :MLOAD(arithRes1)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 1 - B            :JMPN(outOfCountersPoseidon)
    %MAX_CNT_PADDING_PG - CNT_PADDING_PG - 1 - B            :JMPN(outOfCountersPadding)

    ; get a new hashPId
    $ => B                          :MLOAD(nextHashPId)
    B                               :MSTORE(tmpContractHashId)
    B + 1                           :MSTORE(nextHashPId)
    32 => D
    0 => HASHPOS

hashPoseidonLoop:
    %MAX_CNT_STEPS - STEP - 50 :JMPN(outOfCountersStep)

    C               :JMPZ(hashPoseidonEnd)
    C - 32          :JMPN(hashPoseidonFinal)
                    :CALL(MLOAD32)
    E => B
    $ => E          :MLOAD(tmpContractHashId)
    A               :HASHP(E)
    B => E
    C - 32 => C     :JMP(hashPoseidonLoop)


hashPoseidonFinal:
                    :CALL(MLOADX)
    32 - C => D     :CALL(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    $ => E          :MLOAD(tmpContractHashId)
    C => D
    A               :HASHP(E)

hashPoseidonEnd:
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    $ => E          :MLOAD(tmpContractHashId)
    HASHPOS         :HASHPLEN(E)
    $ => D          :HASHPDIGEST(E)

hashPoseidonReturn:
    D               :MSTORE(linearPoseidonOutD)
    $ => A          :RESTORE
    $ => D          :MLOAD(linearPoseidonOutD), RETURN

VAR GLOBAL tmpVarBmask
; @info Mask address to 20 bytes
; @in A => address not masked
; @out A => masked address
maskAddress:
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    B               :MSTORE(tmpVarBmask)
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn => B
    $ => A          :AND
    $ => B          :MLOAD(tmpVarBmask), RETURN

;@info exp(A,D) --> A^D
;@in A, D => A^D
;@out A => result
expAD:
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 20       :JMPN(outOfCountersStep), SAVE(B,C,D,E,RCX,RR)
    ;E base
    A => E
    ;B exp
    D => B
    0 => A
    ;if exp == 0 --> expAD0
    $               :EQ,JMPC(expAD0)
    ;A base
    E => A
    0 => B
    ;if base == 0 --> expA0D
    $               :EQ,JMPC(expA0D)
    1 => C

expADloop:
    %MAX_CNT_STEPS - STEP - 50        :JMPN(outOfCountersStep)
    ;A exp
    D => A
    0 => B
    ;if exp == 0 --> expADend
    $               :EQ,JMPC(expADend)
    A               :MSTORE(arithA)
    ;divARITH --> exp/2
    2               :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    ;D = exp/2
    $ => D          :MLOAD(arithRes1)
    ;A = exp%2 (0 or 1)
    $ => A          :MLOAD(arithRes2), JMPZ(expADloop0) ;if exp%2 == 0 --> expADloop0
    E               :MSTORE(arithA)
    ;mulARITH --> E*C
    C               :MSTORE(arithB), CALL(mulARITH)
     ;C = E*C (acc = bp*acc)
    $ => C          :MLOAD(arithRes1)

expADloop0:
    E               :MSTORE(arithA)
    ;mulARITH --> E*E
    E               :MSTORE(arithB), CALL(mulARITH)
    ;E = E*E (bp = bp*bp)
    $ => E          :MLOAD(arithRes1), JMP(expADloop)
;if base == 0, result0
expA0D:
    0 => C
    0 => D          :JMP(expADend)
 ;if exp == 0, result 1
expAD0:
    1 => C
    0 => D

expADend:
    C => A          :RESTORE, RETURN

;@info function to force a failed assert
failAssert:
    A - 1           :ASSERT

VAR GLOBAL readXFromCalldataOffset
VAR GLOBAL readXFromCalldataLength
VAR GLOBAL readXFromCalldataResult
; @info Reads {readXFromCalldataOffset} bytes (max 32) from a given offset in calldata memory. If offset or offset + length exceeds txCalldataLen, zeros are added
; @internalParam {readXFromCalldataOffset} offset to read from calldata
; @internalParam {readXFromCalldataLength} length to read from calldata
; @returns {readXFromCalldataResult} bytes read from calldata
readFromCalldataOffset:
    %MAX_CNT_STEPS - STEP - 100       :JMPN(outOfCountersStep)
    A               :SAVE(B,C,D,E,RCX,RR)
    $ => A          :MLOAD(txCalldataLen), JMPZ(return0FromCalldata)
    $ => B          :MLOAD(calldataOffset)
    $ => C          :MLOAD(readXFromCalldataLength)
    $ => E          :MLOAD(readXFromCalldataOffset)
    A - E - 1       :JMPN(return0FromCalldata) ; If offset >= txCalldataLen, return 0
    ; if readOffset + readLength > txCalldataLen, readLength = txCalldataLen - readOffset
    E + C - A       :JMPN(dontLimitLength)
    A - E => C

dontLimitLength:
    $ => CTX        :MLOAD(calldataCTX) ; get calldata context
    B + E => E      :CALL(MLOADX); in: [E: offset, C: length] out: [A: value, E: new offset]
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(readXFromCalldataResult), JMP(readFromCalldataOffsetEnd)

return0FromCalldata:
    0               :MSTORE(readXFromCalldataResult)

readFromCalldataOffsetEnd:
    $ => A          :RESTORE, RETURN

; @info store calldata pointer to read calldata
saveCalldataPointer:
    %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)
    ; load data: previous CTX & argsOffsetCall
    $ => A, CTX         :MLOAD(originCTX)
    $ => B              :MLOAD(argsOffsetCall)
    ; move to current CTX and store data
    $ => CTX            :MLOAD(currentCTX)
    A                   :MSTORE(calldataCTX)
    B                   :MSTORE(calldataOffset), RETURN

INCLUDE "./utils/get-len-bytes.zkasm"
INCLUDE "./utils/read-push.zkasm"
INCLUDE "./utils/compute-merkle-proof.zkasm"