; This file is WIP

VAR GLOBAL tmpVarA
VAR GLOBAL tmpVarB
VAR GLOBAL tmpVarC
VAR GLOBAL tmpVarD
VAR GLOBAL tmpVarE
VAR GLOBAL tmpVarA2
VAR GLOBAL tmpVarB2
VAR GLOBAL tmpVarC2
VAR GLOBAL tmpVarD2
VAR GLOBAL tmpVarE2
VAR GLOBAL arithA
VAR GLOBAL arithB
VAR GLOBAL arithRes1
VAR GLOBAL arithRes2
VAR GLOBAL tmpZkPC

; @info Get absolute value and sign
; @in A => number to convert
; @out A => Absolut value of A
; @out B => Sign of A [1 if negative, 0 positive]
abs:
    0 => B
    ;TODO: fix `$ => B          :SLT,JMPC(absIsNeg)`
    ;when zkproverjs has been updated
    $ => B          :SLT,JMPC(absIsNeg)
                    :RETURN

absIsNeg:
    A => B
    0 => A
    $ => A          :SUB
    1 => B
                    :RETURN

; @info copy MEM A to ctxB SP = 1024
; TODO: copy + 32 bytes
copySP:
    RR              :MSTORE(tmpZkPC)
    CTX             :MSTORE(currentCTX)
    1024 => SP                             ;destOffset = 0
    $ => CTX        :MLOAD(originCTX)
    $ => E          :MLOAD(argsOffsetCall)
    $ => C          :MLOAD(argsLengthCall) ;length
    0 - ${E%32}     :JMPN(copyInit2)

copyInit:
    C - 1           :JMPN(copyEnd)
    C - 32          :JMPN(copyFinal)
    $ => A          :MLOAD(MEM:E)
    E + 32 => E
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(SP++)
    $ => CTX        :MLOAD(originCTX)
    C - 32 => C
                    :JMP(copyInit)

copyFinal:
    $ => A          :MLOAD(MEM:E)
    32 - C => D
                    ;SHR/SHL could be optimized
    zkPC+1 => RR    :JMP(SHRarith)
    zkPC+1 => RR    :JMP(SHLarith)
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(SP++)
                    :JMP(copyEnd)

copyInit2:
    C - 1           :JMPN(copyEnd)
    C - 32          :JMPN(copyFinal2)
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A          :MLOAD(MEM:E)
                    :CALL(SHLarith)
    A => B
    32 - D => D
    E + 32 => E
    $ => A          :MLOAD(MEM:E)
    zkPC+1 => RR    :JMP(SHRarith)
    $ => CTX        :MLOAD(currentCTX)
    A + B           :MSTORE(SP++)
    $ => CTX        :MLOAD(originCTX)
    C - 32 => C
                    :JMP(copyInit2)

copyFinal2:
    32 - ${E%32} - C => D       :JMPN(copyFinal22)
    ${E%32} => B
    ${(E/32)*32} => E
    $ => A                      :MLOAD(MEM:E)
    32 - C => D
    zkPC+1 => RR                :JMP(SHRarith)
    zkPC+1 => RR                :JMP(SHLarith)
    $ => CTX                    :MLOAD(currentCTX)
    A                           :MSTORE(SP++)
                                :JMP(copyEnd)

copyFinal22:
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A                  :MLOAD(MEM:E)
    zkPC+1 => RR            :JMP(SHLarith)
    A => B
    E + 32 => E
    $ => A                  :MLOAD(MEM:E)
    C - 32 + D => D
    32 - D => D
    zkPC+1 => RR            :JMP(SHRarith)
    32 - C => D
    zkPC+1 => RR            :JMP(SHLarith)
    $ => CTX                :MLOAD(currentCTX)
    A + B                   :MSTORE(SP++)

copyEnd:
    $ => CTX        :MLOAD(currentCTX)
    $ => RR         :MLOAD(tmpZkPC)
                    :RETURN

; @info byte length of B
; @in B => number
; @out A => bytes length
getLenBytes:
    RR              :MSTORE(tmpZkPC)
    B               :MSTORE(tmpVarB)
    C               :MSTORE(tmpVarC)
    0 => C
    B => A

getLenBytesLoop:
    0 => B
    $               :EQ,JMPC(getLenEnd)
    1 => D
    zkPC+1 => RR    :JMP(SHRarith)
    C + 1 => C
                    :JMP(getLenBytesLoop)

getLenEnd:
    C => A
    $ => B          :MLOAD(tmpVarB)
    $ => C          :MLOAD(tmpVarC)
    $ => RR         :MLOAD(tmpZkPC)
                    :RETURN

; @info save value to memory 32 bytes with offset
; REQUIRE: set bytesToStore with value to use in MSTORE
; @in E => offset
; @out E => new offset

VAR GLOBAL bytesToStore

MSTORE32:
    RR              :MSTORE(tmpZkPC)
    A               :MSTORE(tmpVarA)
    B               :MSTORE(tmpVarB)
    C               :MSTORE(tmpVarC)
    D               :MSTORE(tmpVarD)
    E               :MSTORE(tmpVarE)
    ${E%32} - 1     :JMPN(MSTORE322)
    ${E%32} => C
    ${(E/32)*32} => E
    $ => A          :MLOAD(MEM:E)
    32 - C => D
                    ;SHR/SHL could be optimized
    zkPC+1 => RR    :JMP(SHRarith)
    zkPC+1 => RR    :JMP(SHLarith)
    A => B
    $ => A          :MLOAD(bytesToStore)
    C => D
    zkPC+1 => RR    :JMP(SHRarith)
    A + B           :MSTORE(MEM:E)
    E + 32 => E                                    ;new offset
    $ => A          :MLOAD(MEM:E)
    C => D
                    ;SHR/SHL could be optimized
    zkPC+1 => RR    :JMP(SHLarith)
    zkPC+1 => RR    :JMP(SHRarith)
    A => B
    $ => A          :MLOAD(bytesToStore)
    32 - C => D
    zkPC+1 => RR    :JMP(SHLarith)
    A + B           :MSTORE(MEM:E)
    $ => E          :MLOAD(tmpVarE)
    E + 32 => E
                    :JMP(MSTOREend)

MSTORE322:
    $ => A          :MLOAD(bytesToStore)
    A               :MSTORE(MEM:E)
    E + 32 => E
                    :JMP(MSTOREend)

; @info save value to memory < 32 bytes with offset
; REQUIRE: set bytesToStore with value to use in MSTORE
; @in E => offset
; @in C => length
; @out E => new offset

MSTOREX:
    RR                          :MSTORE(tmpZkPC)
    A                           :MSTORE(tmpVarA)
    B                           :MSTORE(tmpVarB)
    C                           :MSTORE(tmpVarC)
    D                           :MSTORE(tmpVarD)
    E                           :MSTORE(tmpVarE)
    32 - ${E%32} - C            :JMPN(MSTOREX2)
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A                      :MLOAD(bytesToStore)
                                :CALL(SHRarith)
    A => B
    $ => A                      :MLOAD(MEM:E)
    32 - D => D
                                ;SHR/SHL could be optimized
    zkPC+1 => RR                :JMP(SHRarith)
    zkPC+1 => RR                :JMP(SHLarith)
    A + B                       :MSTORE(MEM:E)
    $ => E                      :MLOAD(tmpVarE)
    E + C => E                                    ;new offset
                                :JMP(MSTOREend)

MSTOREX2:
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A                      :MLOAD(bytesToStore)
    zkPC+1 => RR                :JMP(SHRarith)
    A => B
    $ => A                      :MLOAD(MEM:E)
    32 - D => D
                                ;SHR/SHL could be optimized
    zkPC+1 => RR                :JMP(SHRarith)
    zkPC+1 => RR                :JMP(SHLarith)
    A + B                       :MSTORE(MEM:E)
    E + 32 => E
    $ => A                      :MLOAD(bytesToStore)
    zkPC+1 => RR                :JMP(SHLarith)
    A => B
    $ => A                      :MLOAD(MEM:E)
    C - D => D
    zkPC+1 => RR                :JMP(SHRarith)
    A + B                       :MSTORE(MEM:E)
    $ => E                      :MLOAD(tmpVarE)
    E + C => E                                    ;new offset

MSTOREend:
    $ => A                      :MLOAD(tmpVarA)
    $ => B                      :MLOAD(tmpVarB)
    $ => C                      :MLOAD(tmpVarC)
    $ => D                      :MLOAD(tmpVarD)
    $ => RR                     :MLOAD(tmpZkPC)
                                :RETURN


; @info get value from memory (32 bytes)
; @in E => offset
; @out A => value
; @out E => new offset

MLOAD32:
    RR              :MSTORE(tmpZkPC)
    B               :MSTORE(tmpVarB)
    C               :MSTORE(tmpVarC)
    D               :MSTORE(tmpVarD)
    32 => A
    ${E%A} => C
    ${E/A} => B
    0 => D
    E               :ARITH 

    C - 1           :JMPN(MLOAD322)
    ; ${(E/32)*32} => E - floor E
    ${E%A} => C
    ${E/A} => B
    0 => D
    E               :ARITH
    C               :MSTORE(tmpVarA)
    0 => C
    ${A*B} => E     :ARITH
    $ => C          :MLOAD(tmpVarA)

;TODO: Add --> LT(Residu < numToDiv)

    $ => A          :MLOAD(MEM:E)
    C => D
    zkPC+1 => RR    :JMP(SHLarith)
    A => B
    32 - C => D
    E + 32 => E
    $ => A          :MLOAD(MEM:E)
    zkPC+1 => RR    :JMP(SHRarith)
    A + B => A
    E + C => E                                      ;new offset
                    :JMP(MLOADend)

MLOAD322:
    $ => A          :MLOAD(MEM:E)
    E + 32 => E                                     ;new offset
                    :JMP(MLOADend)

; @info get value from memory (32 bytes)
; @in E => offset
; @in C => length
; @out A => value
; @out E => new offset

MLOADX:
    RR                      :MSTORE(tmpZkPC)
    B                       :MSTORE(tmpVarB)
    C                       :MSTORE(tmpVarC)
    D                       :MSTORE(tmpVarD)
    E                       :MSTORE(tmpVarE)
    32 - ${E%32} - C => D   :JMPN(MLOADX2)
    ${E%32} => B
    ${(E/32)*32} => E
    $ => A                  :MLOAD(MEM:E)
    B => D
    zkPC+1 => RR            :JMP(SHLarith)
    32 - C => D
    zkPC+1 => RR            :JMP(SHRarith)
    zkPC+1 => RR            :JMP(SHLarith)
    E + B + C => E                                    ;new offset
                            :JMP(MLOADend)

MLOADX2:
    ${E%32} => D
    ${(E/32)*32} => E
    $ => A                  :MLOAD(MEM:E)
    zkPC+1 => RR            :JMP(SHLarith)
    A => B
    E + 32 => E
    $ => A                  :MLOAD(MEM:E)
    C - 32 + D => D
    32 - D => D
    zkPC+1 => RR            :JMP(SHRarith)
    32 - C => D
    zkPC+1 => RR            :JMP(SHLarith)
    A + B => A
    E                       :MLOAD(tmpVarE)
    E + C => E                                    ;new offset

MLOADend:
    $ => B                  :MLOAD(tmpVarB)
    $ => C                  :MLOAD(tmpVarC)
    $ => D                  :MLOAD(tmpVarD)
    $ => RR                 :MLOAD(tmpZkPC)
                            :RETURN

; @info check account is empty ( balance == nonce == code == 0x )
; @in E => address
; @out E => isEmpty

ISEMPTY:
    A                           :MSTORE(tmpVarA)
    B                           :MSTORE(tmpVarB)
    C                           :MSTORE(tmpVarC)
    D                           :MSTORE(tmpVarD)
    ; read balance
    E => A
    0 => B,C                    ; balance key smt
    $ => A                      :SLOAD
    $ => A                      :EQ
    A - 1                       :JMPN(ISEMPTYSet0)

    ; read nonce
    E => A
    %SMT_KEY_NONCE => B
    $ => A                      :SLOAD
    0 => B
    $ => A                      :EQ
    A - 1                       :JMPN(ISEMPTYSet0)

    ; read bytecode
    E => A
    %SMT_KEY_SC_CODE => B
    $ => A                      :SLOAD
    0 => B
    $ => A                      :EQ
    A - 1                       :JMPN(ISEMPTYSet0)

ISEMPTYSet1:
    1 => E
                                :JMP(ISEMPTYEnd)

ISEMPTYSet0:
    0 => E
                                :JMP(ISEMPTYEnd)

ISEMPTYEnd:
    $ => A                      :MLOAD(tmpVarA)
    $ => B                      :MLOAD(tmpVarB)
    $ => C                      :MLOAD(tmpVarC)
    $ => D                      :MLOAD(tmpVarD)
                                :RETURN

; @out A => min( requested_gas , all_but_one_64th(63/64) )
computeGasSendCall:
    ; save tmp vars
    B                       :MSTORE(tmpVarB)
    C                       :MSTORE(tmpVarC)
    D                       :MSTORE(tmpVarD)
    E                       :MSTORE(tmpVarE)

    ; compute all_but_one_64th gas
    GAS - ${GAS/64} => A
    $ => B                  :MLOAD(gasCall)
    ; gas_sent_with_call = min(requested_gas, all_but_one_64th)
    $                       :LT,JMPC(computeGasSendCallEnd)
    ; gas to substract
    B => A

computeGasSendCallEnd:
    $ => B                  :MLOAD(tmpVarB)
    $ => C                  :MLOAD(tmpVarC)
    $ => D                  :MLOAD(tmpVarD)
    $ => E                  :MLOAD(tmpVarE)
                            :RETURN

;@in E --> new mem length
saveMem:
    A                           :MSTORE(tmpVarA)
    B                           :MSTORE(tmpVarB)
    E                           :MSTORE(memLength)
    ${(E+31)/32} => A
    ${(B+31)/32} => B
    GAS - 3*A - ${A*A/512} => GAS   :JMPN(outOfGas)
    GAS + 3*B + ${B*B/512} => GAS   :JMPN(outOfGas)
    $ => A                      :MLOAD(tmpVarA)
    $ => B                      :MLOAD(tmpVarB)
                                :RETURN
addARITH:

    RR              :MSTORE(tmpZkPC)
    zkPC+1 => RR    :JMP(storeTmp)

    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => E          :ADD

    E              :MSTORE(arithRes1)

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPC)
                    :JMP(RR)

subARITH:

    RR              :MSTORE(tmpZkPC)
    zkPC+1 => RR    :JMP(storeTmp)

    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => A          :SUB

    A                :MSTORE(arithRes1)

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPC)
                    :JMP(RR)

mulARITH:

    RR              :MSTORE(tmpZkPC)
    zkPC+1 => RR    :JMP(storeTmp)

    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    0 => C
    0 => D
    ${A*B} => E     :ARITH

    E              :MSTORE(arithRes1)

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPC)
                    :JMP(RR)

divARITH:

    RR              :MSTORE(tmpZkPC)
    zkPC+1 => RR    :JMP(storeTmp)

    $ => E          :MLOAD(arithA)
    $ => A          :MLOAD(arithB)
    ${E%A} => C
    ${E/A} => B
    0 => D
    E               :ARITH ;TODO: Add --> LT(Residu < numToDiv)

    B               :MSTORE(arithRes1)
    C               :MSTORE(arithRes2)

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPC)
                    :JMP(RR)

loadTmp:
    $ => A                  :MLOAD(tmpVarA)
    $ => B                  :MLOAD(tmpVarB)
    $ => C                  :MLOAD(tmpVarC)
    $ => D                  :MLOAD(tmpVarD)
    $ => E                  :MLOAD(tmpVarE)
                            :JMP(RR)
storeTmp:
    A                   :MSTORE(tmpVarA)
    B                   :MSTORE(tmpVarB)
    C                   :MSTORE(tmpVarC)
    D                   :MSTORE(tmpVarD)
    E                   :MSTORE(tmpVarE)
                        :JMP(RR)

;@in A - (A >> D)
;@in D - (A >> D) D bytes
;@out A -  A >> D => A
SHRarith:
    B                       :MSTORE(tmpVarB2)
    C                       :MSTORE(tmpVarC2)
    D                       :MSTORE(tmpVarD2)
    E                       :MSTORE(tmpVarE2)
    A => E
    D => A
    8 => B
    0 => C
    0 => D
    ${A*B} => D             :ARITH
    E => A
                            :JMP(SHRarithinit)

;@in A - (A >> D)
;@in D - (A >> D) D bits
;@out A -  A >> D => A
SHRarithBit:
    B                       :MSTORE(tmpVarB2)
    C                       :MSTORE(tmpVarC2)
    D                       :MSTORE(tmpVarD2)
    E                       :MSTORE(tmpVarE2)

SHRarithinit:
    0 => B
    $                       :EQ,JMPC(SHRarithfinal)
    A => E
    D => B
    255 => A
    $                       :LT,JMPC(SHRarith0)
    E => A
    ${exp(2,D)} => B
    ${B-1} => B
    $ => C                  :AND
    ${exp(2,D)} => B
    ${E/B} => A
    0 => D
    E                       :ARITH
                            :JMP(SHRarithfinal)

SHRarith0:
    0 => A

SHRarithfinal:
    $ => B                      :MLOAD(tmpVarB2)
    $ => C                      :MLOAD(tmpVarC2)
    $ => D                      :MLOAD(tmpVarD2)
    $ => E                      :MLOAD(tmpVarE2)
                                :JMP(RR)

;@in A - (A << D)
;@in D - (A << D) D bytes
;@out A -  A << D => A
SHLarith:
    B                       :MSTORE(tmpVarB2)
    C                       :MSTORE(tmpVarC2)
    D                       :MSTORE(tmpVarD2)
    E                       :MSTORE(tmpVarE2)
    A => E
    D => A
    8 => B
    0 => C
    0 => D
    ${A*B} => D             :ARITH
    E => A
                            :JMP(SHLarithinit)
;@in A - (A << D)
;@in D - (A << D) D bits
;@out A -  A << D => A
SHLarithBit:
    B                       :MSTORE(tmpVarB2)
    C                       :MSTORE(tmpVarC2)
    D                       :MSTORE(tmpVarD2)
    E                       :MSTORE(tmpVarE2)

SHLarithinit:
    A => E
    0 => A
    D => B
    $                       :EQ,JMPC(SHLarithfinal) ; if D == 0 --> no shift
    E => A
    ${exp(2,D)} => B
    ${A*B} => E
    256 - D => D            :JMPN(SHLarith0) ; if D > 256 --> return 0
    ${exp(2,D)} => B
    ${B-1} => B
    A => C
    B => A
    C => B
    $ => C                  :LT
    B => A
    256 - D => D
    ${exp(2,D)} => B
    0 - C                   :JMPN(SHLarithBig)
    0 => D,C
    E                       :ARITH
                            :JMP(SHLarithfinal)

SHLarith0:
    0 => E
                            :JMP(SHLarithfinal)

SHLarithBig:
    256 - D => D
    ${exp(2,D)} => D
    ${A/D} => D
    0 => C
    E                       :ARITH

SHLarithfinal:
    E => A
    $ => B                  :MLOAD(tmpVarB2)
    $ => C                  :MLOAD(tmpVarC2)
    $ => D                  :MLOAD(tmpVarD2)
    $ => E                  :MLOAD(tmpVarE2)
                            :JMP(RR)

;//TODO: check if outOfGas error === stack error --> same code

outOfGas:
    ;revert all state changes, decrease gas spent to caller
    ;initSR --> balance = balance - gas, nonce + 1
    $ => SR         :MLOAD(initSR)
    ;remaining gas = 0
    $ => A          :MLOAD(originCTX)
    0 => B
    $               :EQ,JMPC(outOfGasEnd)
    A => CTX
    $ => GAS        :MLOAD(gasCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++)
                    :JMP(readCode)


outOfGasEnd:
    ;save Root and jump to send gas to sequencer
    0 => GAS
                    :JMP(sendGasSeq)

stackUnderflow:
stackOverflow:
    ;revert all state changes
    ;initSR --> balance = balance - gas, nonce + 1
    $ => SR         :MLOAD(initSR)
    ;remaining gas = 0
    $ => A          :MLOAD(originCTX)
    0 => B
    $               :EQ,JMPC(stackErrorEnd)
    A => CTX
    $ => GAS        :MLOAD(gasCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++)
                    :JMP(readCode)

stackErrorEnd:
    ;save Root and jump to send gas to sequencer
    0 => GAS
                    :JMP(sendGasSeq)
