; This file is WIP

VAR GLOBAL tmpVarA
VAR GLOBAL tmpVarB
VAR GLOBAL tmpVarC
VAR GLOBAL tmpVarD
VAR GLOBAL tmpVarE
VAR GLOBAL tmpVarA2
VAR GLOBAL tmpVarB2
VAR GLOBAL tmpVarC2
VAR GLOBAL tmpVarD2
VAR GLOBAL tmpVarE2
VAR GLOBAL tmpVarA3
VAR GLOBAL tmpVarB3
VAR GLOBAL tmpVarC3
VAR GLOBAL tmpVarD3
VAR GLOBAL tmpVarE3
VAR GLOBAL tmpZkPC
VAR GLOBAL tmpZkPC2
VAR GLOBAL tmpZkPC3
VAR GLOBAL tmpZkPC4
VAR GLOBAL result

; @info Get absolute value and sign
; @in A => number to convert
; @out A => Absolut value of A
; @out B => Sign of A [1 if negative, 0 positive]
abs:
    0 => B
    $ => B          :SLT, JMPC(absIsNeg)
                    :RETURN

absIsNeg:
    A => B
    0 => A
    $ => A          :SUB
    1 => B
                    :RETURN

; @info copy calldata A to ctxB SP = %CALLDATA_OFFSET
copySP:
    RR              :MSTORE(tmpZkPC2)
    CTX             :MSTORE(currentCTX)
    %CALLDATA_OFFSET => SP                             ;destOffset = 0
    $ => CTX        :MLOAD(originCTX)
    $ => E          :MLOAD(argsOffsetCall)
    $ => C          :MLOAD(argsLengthCall) ;length

copyInit:
    %MAX_CNT_BINARY - CNT_BINARY - 10   :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    C - 1           :JMPN(copyEnd)
    C - 32          :JMPN(copyFinal)
    zkPC+1 => RR    :JMP(MLOAD32)
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(SP++)
    $ => CTX        :MLOAD(originCTX)
    C - 32 => C     :JMP(copyInit)

copyFinal:
    zkPC+1 => RR    :JMP(MLOADX)
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(SP++)
    $ => CTX        :MLOAD(originCTX)

copyEnd:
    $ => CTX        :MLOAD(currentCTX)
    $ => RR         :MLOAD(tmpZkPC2)
                    :RETURN

; @info byte length of B
; @in B => number
; @out A => bytes length
getLenBytes:
    RR              :MSTORE(tmpZkPC)
    B               :MSTORE(tmpVarB)
    C               :MSTORE(tmpVarC)
    D               :MSTORE(tmpVarD)
    0 => C
    B => A

getLenBytesLoop:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 8 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 4 :JMPN(outOfCountersArith)
    0 => B
    $               :EQ,JMPC(getLenEnd)
    1 => D
    zkPC+1 => RR    :JMP(SHRarith)
    C + 1 => C      :JMP(getLenBytesLoop)

getLenEnd:
    C => A
    $ => B          :MLOAD(tmpVarB)
    $ => C          :MLOAD(tmpVarC)
    $ => D          :MLOAD(tmpVarD)
    $ => RR         :MLOAD(tmpZkPC)
                    :RETURN

; @info bits length of B
; @in B => number
; @out A => bits length
getLenBits:
    RR              :MSTORE(tmpZkPC)
    B               :MSTORE(tmpVarB)
    C               :MSTORE(tmpVarC)
    D               :MSTORE(tmpVarD)
    0 => C
    B => A

getLenBitsLoop:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1 :JMPN(outOfCountersArith)

    0 => B
    $               :EQ,JMPC(getLenBitsEnd)
    A               :MSTORE(arithA)
    2               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH)
    $ => A          :MLOAD(arithRes1)
    C + 1 => C      :JMP(getLenBitsLoop)

getLenBitsEnd:
    C => A
    $ => B          :MLOAD(tmpVarB)
    $ => C          :MLOAD(tmpVarC)
    $ => D          :MLOAD(tmpVarD)
    $ => RR         :MLOAD(tmpZkPC)
                    :RETURN

VAR GLOBAL bytesToStore
VAR GLOBAL isMSTOREX
; @info save value to memory < 32 bytes with offset
; REQUIRE: set bytesToStore with value to use in MSTORE
; @in E => offset
; @in C => length
; @out E => new offset
MSTOREX:
    32 - C          :JMPN(errorMLOADMSTORE)
    32 - C - 1      :JMPN(MSTORE32)
    1               :MSTORE(isMSTOREX)

; @info save value to memory 32 bytes with offset
; REQUIRE: set bytesToStore with value to use in MSTORE
; @in E => offset
; @out E => new offset
MSTORE32:
    RR              :MSTORE(tmpZkPC)
    A               :MSTORE(tmpVarA)
    B               :MSTORE(tmpVarB)
    C               :MSTORE(tmpVarC)
    D               :MSTORE(tmpVarD)
    E               :MSTORE(tmpVarE)
    E => A
    0x400000 => B
    $               :LT,JMPC(initMSTORE, errorMLOADMSTORE)

initMSTORE:
    zkPC+1 => RR    :JMP(offsetUtil)
    $ => B          :MLOAD(isMSTOREX)
    B - 1           :JMPN(finalMSTORE)
    -C              :JMPN(MSTOREX2)
    $ => C          :MLOAD(tmpVarC)
    $ => A          :MLOAD(bytesToStore)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    zkPC+1 => RR    :JMP(SHLarith)
    A => B
    $ => A          :MLOAD(MEM:E)
    32 - D => D
    zkPC+1 => RR    :JMP(SHLarith)
    zkPC+1 => RR    :JMP(SHRarith)
    A + B           :MSTORE(bytesToStore)
    A + B => A
    0 => C
    0               :MSTORE(isMSTOREX), JMP(finalMSTORE)

MSTOREX2:
    $ => D          :MLOAD(tmpVarC)
    C + D => D
    $ => A          :MLOAD(MEM:E)
    zkPC+1 => RR    :JMP(SHLarith)
    $ => D          :MLOAD(tmpVarC)
    zkPC+1 => RR    :JMP(SHRarith)
    A => B
    $ => A          :MLOAD(MEM:E+1)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    A + B => B
    $ => A          :MLOAD(bytesToStore)
    $ => D          :MLOAD(tmpVarC)
    32 - D => D
    zkPC+1 => RR    :JMP(SHRarith)
    zkPC+1 => RR    :JMP(SHLarith)
    A + B           :MSTORE(bytesToStore)
    A + B => A

finalMSTORE:
    -C              :JMPN(memAlignOptionMSTORE)

; (*) NOTE: only using E0 on address indirection, ignores E1..E7
    $ => A          :MLOAD(bytesToStore)
    A               :MSTORE(MEM:E)
    E*32 => E       :JMP(offsetMSTORE32)

memAlignOptionMSTORE:
    E               :MSTORE(tmpVarE)

    $ => A          :MLOAD(MEM:E) ; read M0
    $ => B          :MLOAD(MEM:E+1) ; read M1

    ${memAlignWR_W0(A,mem.bytesToStore,C)} => D                    ; no trust calculate W0
    ${memAlignWR_W1(B,mem.bytesToStore,C)} => E                    ; no trust calculate W1
    $               :MEM_ALIGN_WR,MLOAD(bytesToStore)
    E => A
    $ => E          :MLOAD(tmpVarE)
    D               :MSTORE(MEM:E)          ; write W0
    A               :MSTORE(MEM:E+1)        ; write W1
    E*32 + C => E
    $ => A          :MLOAD(isMSTOREX)
    A - 1           :JMPN(offsetMSTORE32)
    $ => C          :MLOAD(tmpVarC)
    E*32 + C => E
    0               :MSTORE(isMSTOREX), JMP(endMSTORE)

offsetMSTORE32:
    E + 32 => E

endMSTORE:
    $ => A          :MLOAD(tmpVarA)
    $ => B          :MLOAD(tmpVarB)
    $ => C          :MLOAD(tmpVarC)
    $ => D          :MLOAD(tmpVarD)
    $ => RR         :MLOAD(tmpZkPC)
                    :RETURN


VAR GLOBAL isMLOADX
; @info get value from memory (< 32 bytes)
; @in E => offset
; @in C => length
; @out A => value
; @out E => new offset
MLOADX:
    32 - C          :JMPN(errorMLOADMSTORE) ; TDDO Should be unreachable! check it
    32 - C - 1      :JMPN(MLOAD32)
    1               :MSTORE(isMLOADX)

; @info get value from memory (32 bytes)
; @in E => offset
; @out A => value
; @out E => new offset
MLOAD32:
    RR              :MSTORE(tmpZkPC)
    B               :MSTORE(tmpVarB)
    C               :MSTORE(tmpVarC)
    D               :MSTORE(tmpVarD)
    E => A
    0x400000 => B
    $               :LT,JMPC(initMLOAD, errorMLOADMSTORE)

initMLOAD:
    zkPC+1 => RR    :JMP(offsetUtil)
    -C              :JMPN(memAlignOptionMLOAD)
    $ => A          :MLOAD(MEM:E)
    $ => B          :MLOAD(isMLOADX)
    E*32 => E
    B - 1           :JMPN(offsetMLOAD32, sliceA)

memAlignOptionMLOAD:
    $ => A          :MLOAD(MEM:E)
    $ => B          :MLOAD(MEM:E+1)
    $ => A          :MEM_ALIGN_RD
    E*32 + C => E
    $ => B          :MLOAD(isMLOADX)
    B - 1           :JMPN(offsetMLOAD32)

sliceA:
    $ => C          :MLOAD(tmpVarC)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    zkPC+1 => RR    :JMP(SHLarith)
    0               :MSTORE(isMLOADX)
    E + C => E      :JMP(endMLOAD)

offsetMLOAD32:
    E + 32 => E

endMLOAD:
    $ => B          :MLOAD(tmpVarB)
    $ => C          :MLOAD(tmpVarC)
    $ => D          :MLOAD(tmpVarD)
    $ => RR         :MLOAD(tmpZkPC)
                    :RETURN

errorMLOADMSTORE:
                    :JMP(handleError)

; @info check account is empty ( balance == nonce == code == 0x )
; @in E => address
; @out E => isEmpty => 1 = true, 0 = false

isEmptyAccount:
    A                           :MSTORE(tmpVarA)
    B                           :MSTORE(tmpVarB)
    C                           :MSTORE(tmpVarC)
    D                           :MSTORE(tmpVarD)

    E => A
    ; read balance
    0 => B,C                    ; balance key smt
    $ => B                      :SLOAD
    0 => A
    $                           :LT,JMPC(isNotEmptyAccount)

    ; read nonce
    E => A
    %SMT_KEY_NONCE => B
    $ => B                      :SLOAD
    0 => A
    $                           :LT,JMPC(isNotEmptyAccount)

    ; read bytecode
    E => A
    %SMT_KEY_SC_CODE => B
    $ => B                      :SLOAD
    0 => A
    $                           :LT,JMPC(isNotEmptyAccount)
    1 => E                      :JMP(ISEMPTYEnd)

isNotEmptyAccount:
    0 => E                      :JMP(ISEMPTYEnd)

ISEMPTYEnd:
    $ => A                      :MLOAD(tmpVarA)
    $ => B                      :MLOAD(tmpVarB)
    $ => C                      :MLOAD(tmpVarC)
    $ => D                      :MLOAD(tmpVarD)
                                :RETURN

; @out A => min( requested_gas , all_but_one_64th(63/64) )
computeGasSendCall:
    ; save tmp vars
    B                       :MSTORE(tmpVarB)
    C                       :MSTORE(tmpVarC)
    D                       :MSTORE(tmpVarD)
    E                       :MSTORE(tmpVarE)

    ; compute all_but_one_64th gas
    GAS - ${GAS/64} => A
    $ => B                  :MLOAD(gasCall)
    ; gas_sent_with_call = min(requested_gas, all_but_one_64th)
    $                       :LT,JMPC(computeGasSendCallEnd)
    ; gas to substract
    B => A

computeGasSendCallEnd:
    $ => B                  :MLOAD(tmpVarB)
    $ => C                  :MLOAD(tmpVarC)
    $ => D                  :MLOAD(tmpVarD)
    $ => E                  :MLOAD(tmpVarE)
                            :RETURN
; lastMemOffset: offset to copy bytes
; lastMemLength: size of the bytes to copy
saveMem:
    A                           :MSTORE(tmpVarA)
    B                           :MSTORE(tmpVarB)
    C                           :MSTORE(tmpVarC)
    E                           :MSTORE(tmpVarE)
    $ => E                      :MLOAD(lastMemOffset)
    $ => A                      :MLOAD(lastMemLength)
    0 => B
    ; If no len, no memory expansion
    $                           :EQ, JMPC(saveMemEnd)
    ; If the binary has a carry, means the mem expansion is very big. We can jump to oog directly
    E => B
    $ => B                      :ADD, JMPC(outOfGas)
    $ => A                      :MLOAD(memLength)
    $                           :LT, JMPC(saveMemGAS, saveMemEnd)

saveMemGAS:
    B                           :MSTORE(memLength)
    ${(B+31)/32} => E
    ${(A+31)/32} => C
    GAS + 3*C + ${C*C/512} => GAS
    GAS => A
    3*E => B
    $                           :LT,JMPC(outOfGas)
    A - B => A
    ${E*E/512} => B
    $                           :LT,JMPC(outOfGas)
    A - B => GAS

saveMemEnd:
    $ => A                      :MLOAD(tmpVarA)
    $ => B                      :MLOAD(tmpVarB)
    $ => C                      :MLOAD(tmpVarC)
    $ => E                      :MLOAD(tmpVarE)
                                :RETURN

VAR GLOBAL tmpVarAArith
VAR GLOBAL tmpVarBArith
VAR GLOBAL tmpVarCArith
VAR GLOBAL tmpVarDArith
VAR GLOBAL tmpVarEArith
VAR GLOBAL tmpZkPCArith
VAR GLOBAL arithA
VAR GLOBAL arithB
VAR GLOBAL arithRes1
VAR GLOBAL arithRes2
VAR GLOBAL arithOverflow

addARITH:

    RR              :MSTORE(tmpZkPCArith), CALL(storeTmp)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => E          :ADD, MSTORE(arithRes1)

    $ => RR         :MLOAD(tmpZkPCArith), JMP(loadTmp)

subARITH:

    RR              :MSTORE(tmpZkPCArith)
    zkPC+1 => RR    :JMP(storeTmp)

    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => A          :SUB

    A               :MSTORE(arithRes1)

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :JMP(RR)

mulARITH:

    RR              :MSTORE(tmpZkPCArith)
    zkPC+1 => RR    :JMP(storeTmp)

    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    0 => C
    $${var _mulArith = A * B}
    ${_mulArith >> 256} => D
    ${_mulArith} => E :ARITH

    E               :MSTORE(arithRes1)
    D               :MSTORE(arithOverflow)

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :JMP(RR)

divARITH:
    RR              :MSTORE(tmpZkPCArith)
    zkPC+1 => RR    :JMP(storeTmp)

    $ => E          :MLOAD(arithA)
    $ => A          :MLOAD(arithB)
    ; Check denominator(A) is not zero
    0 => B
    $               :EQ, JMPC(zeroDiv)

    ; Check if divisor (E) is smaller than denominator E < A
    A => C ; store temporally A in C
    E => A ; divisor
    C => B ; denominator
    $               :LT, JMPC(divisorSmallerDiv)
    C => A

    ${E%A} => C ; reminder
    ${E/A} => B
    0 => D
    E               :ARITH

    B               :MSTORE(arithRes1)
    C               :MSTORE(arithRes2)

    ; check divisor > reminder
    C => A ; reminder
    E => B ; divisor
    $ => A          :LT
    1               :ASSERT

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :JMP(RR)

zeroDiv:
    0               :MSTORE(arithRes1)
    0               :MSTORE(arithRes2)

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :JMP(RR)

divisorSmallerDiv:
    0               :MSTORE(arithRes1)
    E               :MSTORE(arithRes2)

    zkPC+1 => RR    :JMP(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :JMP(RR)

loadTmp:
    $ => A                  :MLOAD(tmpVarAArith)
    $ => B                  :MLOAD(tmpVarBArith)
    $ => C                  :MLOAD(tmpVarCArith)
    $ => D                  :MLOAD(tmpVarDArith)
    $ => E                  :MLOAD(tmpVarEArith)
                            :JMP(RR)
storeTmp:
    A                   :MSTORE(tmpVarAArith)
    B                   :MSTORE(tmpVarBArith)
    C                   :MSTORE(tmpVarCArith)
    D                   :MSTORE(tmpVarDArith)
    E                   :MSTORE(tmpVarEArith)
                        :JMP(RR)

VAR GLOBAL tmpSHXZkPC
VAR GLOBAL tmpSHXZkPC2

;@info Shift right D bytes to A
;@in A - (A >> D)
;@in D - (A >> D) D bytes
;@out A - A >> D => A
SHRarith:
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarB2)
    C                       :MSTORE(tmpVarC2)
    D                       :MSTORE(tmpVarD2)
    E                       :MSTORE(tmpVarE2)
    A => E                                      ; E init number
    D => A                                      ; A bytes
    8 => B                                      ; B = 8 (1 byte = 8 bits)
    0 => C
    0 => D
    ${A*B} => D             :ARITH              ; A * B = op --> D = op (D bits)
    E => A                                      ; A init number
                            :JMP(SHRarithinit)

;@in A - (A >> D)
;@in D - (A >> D) D bits
;@out A -  A >> D => A
SHRarithBit:
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarB2)
    C                       :MSTORE(tmpVarC2)
    D                       :MSTORE(tmpVarD2)
    E                       :MSTORE(tmpVarE2)

SHRarithinit:
    0 => B
    $                       :EQ,JMPC(SHRarithfinal) ; if A == 0 --> no shift
    A => E                                          ; E init number
    D => B                                          ; B bits
    255 => A
    $                       :LT,JMPC(SHRarith0)     ; A < B, 255 < bits
    D => RR
    E => A                  :MSTORE(arithA)
                            :CALL(@exp_num + RR)     ; B = 2**D
    B                       :MSTORE(arithB),CALL(divARITH)
    $ => A                  :MLOAD(arithRes1),JMP(SHRarithfinal)

SHRarith0:
    0 => A

SHRarithfinal:
    $ => B                  :MLOAD(tmpVarB2)
    $ => C                  :MLOAD(tmpVarC2)
    $ => D                  :MLOAD(tmpVarD2)
    $ => E                  :MLOAD(tmpVarE2)
    $ => RR                 :MLOAD(tmpSHXZkPC2)
                            :JMP(RR)

;@in A - (A << D)
;@in D - (A << D) D bytes
;@out A -  A << D => A
SHLarith:
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarB2)
    C                       :MSTORE(tmpVarC2)
    D                       :MSTORE(tmpVarD2)
    E                       :MSTORE(tmpVarE2)
    A => E                                      ; E init number
    D => A                                      ; A bytes
    8 => B
    0 => C
    0 => D
    ${A*B} => D             :ARITH              ; D = A * 8, D bits
    E => A                                      ; A init number
                            :JMP(SHLarithinit)
;@in A - (A << D)
;@in D - (A << D) D bits
;@out A -  A << D => A
SHLarithBit:
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarB2)
    C                       :MSTORE(tmpVarC2)
    D                       :MSTORE(tmpVarD2)
    E                       :MSTORE(tmpVarE2)

SHLarithinit:
    A => E                                          ; E init number
    0 => A
    D => B                                          ; D --> B bits
    $                       :EQ,JMPC(SHLarithfinal) ; if D == 0 --> no shift
    255 => A
    $                       :LT,JMPC(SHLarith0)     ; A < B, 255 < bits

    D => RR
    E => A                  :CALL(@exp_num + RR)   ; A init number and calculate B = 2**D
    ${A*B} => E                                     ; E = init number * 2**D (result)
    E                       :MSTORE(result)
    256 - D => D, RR                                    ; D = 256 - D
                            :CALL(@exp_num + RR)     ; B = 2**(256-D)
    A => E
    B => A
    1 => B
    $ => A                  :SUB
    E => B
    $ => C                  :LT                     ; A < B, 2**(256-D) - 1 < init number
    E => A                                          ; A init number
    $ => E                  :MLOAD(result)          ; E result
    256 - D => D, RR                                ; D = 256 - D
                            :CALL(@exp_num + RR)     ; B = 2**D
    0 - C                   :JMPN(SHLarithBig)      ; if 2**D-1 < init number --> SHLarithBig
    0 => D,C
    E                       :ARITH, JMP(SHLarithfinal) ; init number * 2**D = init

SHLarith0:
    0 => E
                            :JMP(SHLarithfinal)

SHLarithBig:
    256 - D => D, RR
    B => C                  :CALL(@exp_num + RR)
    ${A/B} => D
    C => B
    0 => C
    E                       :ARITH

SHLarithfinal:
    E => A
    $ => B                  :MLOAD(tmpVarB2)
    $ => C                  :MLOAD(tmpVarC2)
    $ => D                  :MLOAD(tmpVarD2)
    $ => E                  :MLOAD(tmpVarE2)
    $ => RR                 :MLOAD(tmpSHXZkPC2)
                            :JMP(RR)

outOfCountersStep:
    $${eventLog(onError, OOCS)}
                    :JMP(handleBatchError)
outOfCountersKeccak:
    $${eventLog(onError, OOCK)}
                    :JMP(handleBatchError)
outOfCountersBinary:
    $${eventLog(onError, OOCB)}
                    :JMP(handleBatchError)
outOfCountersMemalign:
    $${eventLog(onError, OOCM)}
                    :JMP(handleBatchError)
outOfCountersArith:
    $${eventLog(onError, OOCA)}
                    :JMP(handleBatchError)
outOfCountersPadding:
    $${eventLog(onError, OOCPA)}
                    :JMP(handleBatchError)
outOfCountersPoseidon:
    $${eventLog(onError, OOCPO)}
                    :JMP(handleBatchError)
outOfGas:
    $${eventLog(onError, OOG)}
                    :JMP(handleError)
invalidJump:
    $${eventLog(onError, invalid)}
                    :JMP(handleError)
invalidProcess:
    $${eventLog(onError, invalid)}
                    :JMP(handleError)
stackUnderflow:
    $${eventLog(onError, underflow)}
                    :JMP(handleError)
stackOverflow:
    $${eventLog(onError, overflow)}
                    :JMP(handleError)
deployAddressCollision:
    $${eventLog(onError, invalid)}
                    :JMP(handleError)
invalidStaticTx:
    $${eventLog(onError, invalid)}
                    :JMP(handleError)
invalidCodeSize:
    $${eventLog(onError, invalid)}
                    :JMP(handleError)
handleError:
    ;revert all state changes
    $ => SR         :MLOAD(initSR)
                    :CALL(revertTouched)
    ;remaining gas = 0
    $ => A          :MLOAD(originCTX)
    0 => B
    $               :EQ,JMPC(firstContextInvalid)
    A => CTX
    ; Add return data context value to origin context
    ; Clear return data context
    0               :MSTORE(retDataCTX)
    CTX             :MSTORE(currentCTX)
    $ => GAS        :MLOAD(gasCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++)
    $ => A          :MLOAD(depth)
    A - 1           :MSTORE(depth)
                    :JMP(readCode)

handleBatchError:
    $ => SR         :MLOAD(batchSR)
    $${eventLog(onFinishTx)}
    $${eventLog(onFinishBatch)}
                    :JMP(processTxsEnd)

firstContextInvalid:
    ;save Root and jump to send gas to sequencer
    0               :MSTORE(gasRefund)
    0 => GAS
                    :JMP(sendGasSeq)

;Get offset/32 & offset%32
;@in A offset
;@out E offset/32
;@out C offset%32
offsetUtil:
    ${A >> 5} => E          ; ${A >> 5} -> E (*)
    ${A & 0x1F} => C        ; ${A & 0x1F} -> C
    0x0FFFF - E     :JMPN(stackUnderflow)
    31-C            :JMPN(stackUnderflow)
    E*32+C          :ASSERT
                    :RETURN

moveBalances:

;;;;;;;;
; evmCALL (Move Balances)
;;;;;;;;
        ;Check if is a delegate call
        $ => A                           :MLOAD(isDelegateCall)
        -A                               :JMPN(endMoveBalances)
        ; Decrement original balance
        $ => A                          :MLOAD(txSrcAddr)
        0 => B,C                                                                                ; balance key smt
        $ => A                          :SLOAD                                                  ; Original Balance in E
        $ => B                          :MLOAD(txValue)                                         ; A = E - C
        ; Check has enough balance to pay the value. In case not, means we are in a CALL/CALLCODE
        $                               :LT,JMPC(invalidCall)
        $ => D                          :SUB                                                    ; originalBalance -value in D
        $ => A                          :MLOAD(txSrcAddr)
        0 => B                                                                                  ; balance key smt
        $ => SR                         :SSTORE

        ; Increment destination balance
        $ => A                          :MLOAD(storageAddr)
        0 => B                                                                                  ; balance key smt
        $ => A                          :SLOAD                                                  ; Original Balance in E
        $ => B                          :MLOAD(txValue)                                         ; E = A + C
        $ => D                          :ADD
        $ => A                          :MLOAD(storageAddr)
        0 => B,C                        ; balance key smt
        $ => SR                         :SSTORE
endMoveBalances:
                                        :RETURN

invalidCall:
        $ => SR                         :MLOAD(initSR)
        $ => A                          :MLOAD(originCTX)
        0 => B
        $                               :EQ,JMPC(handleGas)
        A => CTX
        0                               :MSTORE(retDataCTX)
        CTX                             :MSTORE(currentCTX)
        $ => A                          :MLOAD(gasCTX)
        GAS + A => GAS
        $ => SP                         :MLOAD(lastSP)
        $ => PC                         :MLOAD(lastPC)
        0                               :MSTORE(SP++)
                                        :JMP(readCode)

; @info Read bytes opcode PUSHX
; @internalParam {numBlocks} 4 bytes blocks to read
; @internalParam {leftBytes} remaining bytes
; @in D => bytes to read
; @out E => value read
VAR GLOBAL pushBytes
VAR GLOBAL numBlocks
VAR GLOBAL leftBytes
VAR GLOBAL accumulator
readPush:
    D                           :MSTORE(pushBytes)
    D => A
    0                           :MSTORE(accumulator)
    PC + D - 1 => HASHPOS
    ${A >> 2} => B
    B                           :MSTORE(numBlocks)
    ${A & 0x03} => D
    D                           :MSTORE(leftBytes)
    B*4 + D                     :ASSERT
    D => A
    0x04 => B
    $ => A                      :LT
    1                           :ASSERT
    0 => B
                                :JMP(readPushBlock)

readPushBlock:
    $ => A                      :MLOAD(numBlocks)
    $                           :EQ, JMPC(endPushInit)

    E                           :MLOAD(contractHashId) ; load hash contract identifier

    ; read bytes
    $ => C                      :HASHP1(E)
    HASHPOS - 2 => HASHPOS

    $ => A                      :HASHP1(E)
    HASHPOS - 2 => HASHPOS
    A*256 + C => C

    $ => A                      :HASHP1(E)
    HASHPOS - 2 => HASHPOS
    A*65536 + C => C

    $ => A                      :HASHP1(E)
    HASHPOS - 2 => HASHPOS
    A*16777216 + C => C

                                :JMP(doRotate)

doRotate:
    B - 1 => A

                                :JMP(doRotateLoop)

doRotateLoop:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    A                           :JMPN(endRotate)
    ROTL_C => C
    A - 1 => A
                                :JMP(doRotateLoop)

endRotate:
    $ => D                      :MLOAD(accumulator)
    C + D => D
    D                           :MSTORE(accumulator)
    B + 1 => B
                                :JMP(readPushBlock)

endPushInit:
    $ => A                          :MLOAD(leftBytes)
    A - 1                           :JMPN(finalPush)
    0 => C
    0 => B
                                    :JMP(endPushLoop)


endPushLoop:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCountersBinary)

    $ => A                          :MLOAD(leftBytes)
    $                               :EQ, JMPC(endPushFinal)

    $ => D                          :HASHP1(E)
    HASHPOS - 2 => HASHPOS
    B - 1 => A
                                    :JMP(computeFactorLoop)

computeFactorLoop:
    A                               :JMPN(computeFactorEnd)
    256*D => D
    A - 1 => A
                                    :JMP(computeFactorLoop)

computeFactorEnd:
    B + 1 => B
    D + C => C
                                    :JMP(endPushLoop)

endPushFinal:
    $ => B                          :MLOAD(numBlocks)
                                    :JMP(doRotate2)

doRotate2:
    B - 1 => A
                                :JMP(doRotateLoop2)

doRotateLoop2:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    A                           :JMPN(endRotate2)
    ROTL_C => C
    A - 1 => A
                                :JMP(doRotateLoop2)

endRotate2:
    $ => D                      :MLOAD(accumulator)
    C + D => D
    D                           :MSTORE(accumulator)
                                :JMP(finalPush)

finalPush:
    $ => E                      :MLOAD(accumulator)
    $ => D                      :MLOAD(pushBytes)
                                :RETURN

VAR GLOBAL auxBytes
addBatchHashByteByByte:
        %MAX_CNT_BINARY - CNT_BINARY - 200   :JMPN(handleOOCBatRLP)
        RR                              :MSTORE(tmpZkPC)
        A                               :MSTORE(auxBytes)
        D => B
        B                               :MSTORE(tmpVarB)
        1 => D

utilsAddBatchHashBytebyByte:
        32 - D => D
        $ => A                          :MLOAD(auxBytes)
        zkPC+1 => RR                    :JMP(SHRarith)
        ; get last byte
        0xFFn => B
        $ => A                          :AND
        D => B
        1 => D
        zkPC+1 => RR                    :JMP(addBatchHashData)
        B => D
        32 - D => D
        D + 1 => D
        $ => B                          :MLOAD(tmpVarB)
        D - B - 1                       :JMPN(utilsAddBatchHashBytebyByte)
        $ => RR                         :MLOAD(tmpZkPC)
                                        :RETURN


; @info Computes hash bytecode from memory bytes
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {memSize} memory size to read bytes from
; @out D => resulting linear poseidon
VAR GLOBAL memOffsetLinearPoseidon
VAR GLOBAL memSizeLinearPoseidon
hashPoseidonLinearFromMemory:
    A                               :MSTORE(tmpVarA)
    B                               :MSTORE(tmpVarB)
    C                               :MSTORE(tmpVarC)
    E                               :MSTORE(tmpVarE)
    RR                              :MSTORE(tmpZkPC2)
    $ => E                          :MLOAD(memOffsetLinearPoseidon)
    $ => C                          :MLOAD(memSizeLinearPoseidon)
    0 => D
    C - 1                           :JMPN(hashPoseidonReturn)
    ; check poseidon counters
    ; 56 is the value used by the prover to increment poseidon counters depending on the hash length
    C               :MSTORE(arithA)
    56              :MSTORE(arithB)
                    :CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => B          :MLOAD(arithRes1)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 1 => A
    $               :LT, JMPC(outOfCountersPoseidon)

    ; get a new hashPId
    $ => B                          :MLOAD(nextHashPId)
    B                               :MSTORE(tmpContractHashId)
    B + 1                           :MSTORE(nextHashPId)
    32 => D
    0 => HASHPOS

hashPoseidonLoop:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)

    C - 1           :JMPN(hashPoseidonEnd)
    C - 32          :JMPN(hashPoseidonFinal)
    zkPC+1 => RR    :JMP(MLOAD32)
    E => B
    $ => E          :MLOAD(tmpContractHashId)
    A               :HASHP(E)
    B => E
    C - 32 => C
                    :JMP(hashPoseidonLoop)

hashPoseidonFinal:
    zkPC+1 => RR    :JMP(MLOADX)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith)
    $ => E          :MLOAD(tmpContractHashId)
    C => D
    A               :HASHP(E)

hashPoseidonEnd:
    $ => E          :MLOAD(tmpContractHashId)
    HASHPOS         :HASHPLEN(E)
    $ => D          :HASHPDIGEST(E)
    $${saveContractBytecode(E)}

hashPoseidonReturn:
    $ => RR         :MLOAD(tmpZkPC2)
    $ => A          :MLOAD(tmpVarA)
    $ => B          :MLOAD(tmpVarB)
    $ => C          :MLOAD(tmpVarC)
    $ => E          :MLOAD(tmpVarE)
                    :RETURN


; @info Mask address to 20 bytes
; @in A => address not masked
; @out A => masked address
maskAddress:
    B               :MSTORE(tmpVarB)
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn => B
    $ => A          :AND
    $ => B          :MLOAD(tmpVarB)
                    :RETURN

updateSystemData:
    ; check keccak counters
    $ => A                              :MLOAD(cntKeccakPreProcess)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - A - 1:JMPN(outOfCountersKeccak)

    ; Get last tx count
    %LAST_TX_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => D                              :MLOAD(txCount)
    ;Update last tx Count at system storage
    D + 1 => D                          :MSTORE(txCount)
    $ => SR                             :SSTORE

    ;Update state root mapping
    D => A
    32 => D
    0 => HASHPOS ; A new hash with position 0 is started
    $ => E                              :MLOAD(lastHashKIdUsed)
    E + 1 => E                          :MSTORE(lastHashKIdUsed)
    A                                   :HASHK(E)
    %STATE_ROOT_STORAGE_POS             :HASHK(E)
    HASHPOS                             :HASHKLEN(E)
    $ => C                              :HASHKDIGEST(E)
    %ADDRESS_SYSTEM => A
    SR => D
    $ => SR                             :SSTORE
                                        :RETURN


; @info (A*B)%C => C
; @in A
; @in B
; @in C
; @out C
utilMULMOD:
    ; checks zk-counters
    %MAX_CNT_ARITH - CNT_ARITH - 3      :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 3    :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)

    RR              :MSTORE(tmpZkPC4)
    A               :MSTORE(tmpVarA)
    B               :MSTORE(tmpVarB)
    D               :MSTORE(tmpVarD)
    E               :MSTORE(tmpVarE)

    ; The following approach will be followed in order to verify the mulmod operation
    ; A * B + 0 = D*2^256 + E
    ; K * N + mulModResult = D*2^256 + E

    ; Since the k can be bigger than 2²⁵⁶ and therefore does not fit in a register we divedit in the
    ; most significan and less significant part:

    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E
    ; And divide this operation in 2 which fits in 2²⁵⁶ digits

    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2

    ; Mul operation with Arith
    $${var _mulMod = A * B}
    A               :MSTORE(arithA)
    B               :MSTORE(arithB)
    ; here we perform the: A * B + 0 = D*2^256 + E
    ; result is stored in: arithRes1(E) and arithOverflow(D)
                    :CALL(mulARITH)
    C => A
    ; Check if modulus is 0 or 1
    2 => B
    $               :LT, JMPC(zeroOneMod)
    ; Now we will try to perform the following equation:
    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E

    ${(_mulMod / C) >> 256} => B     ; k.h
    ; We can jump with Js, because later it's all verified by the ARITH
    ${cond(B == 0)}  :JMPN(mulModNoKH)

    ; Since there's k.h we will split the equation in those 2
    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2

    ; k.h  * N  = D2
    ; B * A + 0 = 0 * 2²⁵⁶ + E
    ; D2 must be less than 2²⁵⁶
    C => A ; Modulus
    0 => C, D
    ${B * A} => E   :MSTORE(tmpVarD), ARITH ; D2

    ; k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ; B * A + C = D*2^256 + E
    ; remember that:
    ; result of mul is stored in: arithRes1(E) and arithOverflow(D)

    ${(_mulMod / A) % (1 << 256)} => B   ; k.l
    ${_mulMod % A} => C        ; mulModResult
    ${(B * A + C) >> 256} => D ; D1
    $               :MLOAD(arithRes1), ARITH

    ; Finally we need to assert the following:
    ; N>resultModulus
    ; D1 + D2 = D
    ; N>resultModulus   ; LT; ASSERT
    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT

    ; Assert D1 + D2 = D ; ADD ;ASSERT
    D => A ; D1
    $ => B          :MLOAD(tmpVarD) ;D2
    $ => A          :ADD
    $               :MLOAD(arithOverflow), ASSERT
                    :JMP(utilMULMODend)

mulModNoKH:
    ; if theres no K.h the equation is simplified as:
    ; K * N + mulModResult = D*2^256 + E
    ; B * A + C = D*2^256 + E

    C => A ; Modulus on A
    ${(_mulMod / A)} => B   ; k
    ${_mulMod % A} => C     ; mulModResult
    $ => D         :MLOAD(arithOverflow)
    $              :MLOAD(arithRes1), ARITH ; Can this be on the same line of MLOAD?

    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT
                    :JMP(utilMULMODend)

zeroOneMod:
    0 => C

utilMULMODend:
    $ => A          :MLOAD(tmpVarA)
    $ => B          :MLOAD(tmpVarB)
    $ => D          :MLOAD(tmpVarD)
    $ => E          :MLOAD(tmpVarE)
    $ => RR         :MLOAD(tmpZkPC4)
                    :JMP(RR)

;@info exp(A,D) --> A^D
;@in A, D => A^D
;@out A => result
expAD:
    RR              :MSTORE(tmpZkPC3)
    B               :MSTORE(tmpVarB3)
    C               :MSTORE(tmpVarC3)
    E               :MSTORE(tmpVarE3)
    A => E                              ;E base
    D => B                              ;B exp
    0 => A
    $               :EQ,JMPC(expAD0)    ;if exp == 0 --> expAD0
    E => A                              ;A base
    0 => B
    $               :EQ,JMPC(expA0D)    ;if base == 0 --> expA0D
    1 => C

expADloop:

    %MAX_CNT_ARITH - CNT_ARITH - 3 :JMPN(outOfCountersArith)

    D => A                              ;A exp
    0 => B
    $               :EQ,JMPC(expADend)  ;if exp == 0 --> expADend
    A               :MSTORE(arithA)
    2               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH)      ;divARITH --> exp/2
    $ => D          :MLOAD(arithRes1)   ;D = exp/2
    $ => A          :MLOAD(arithRes2)   ;A = exp%2 (0 or 1)
    0 => B
    $               :EQ,JMPC(expADloop0);if exp%2 == 0 --> expADloop0
    E               :MSTORE(arithA)
    C               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(mulARITH)      ;mulARITH --> E*C
    $ => C          :MLOAD(arithRes1)   ;C = E*C (acc = bp*acc)

expADloop0:
    E               :MSTORE(arithA)
    E               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(mulARITH)      ;mulARITH --> E*E
    $ => E          :MLOAD(arithRes1)   ;E = E*E (bp = bp*bp)
                    :JMP(expADloop)

expA0D:                                 ;if base == 0, result0
    0 => C
    0 => D
                    :JMP(expADend)

expAD0:                                 ;if exp == 0, result 1
    1 => C
    0 => D

expADend:
    C => A
    $ => B          :MLOAD(tmpVarB3)
    $ => C          :MLOAD(tmpVarC3)
    $ => E          :MLOAD(tmpVarE3)
    $ => RR         :MLOAD(tmpZkPC3)
                    :JMP(RR)
