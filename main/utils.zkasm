; @info Get absolute value and sign
; @in A => number to convert
; @out A => Absolute value of A
; @out B => Sign of A [1 if negative, 0 positive]
abs:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 20       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    0 => B
    ; if is negative, change sign
    $ => B          :SLT, JMPC(absIsNeg)
                    :RETURN

absIsNeg:
    A => B
    0 => A
    ; 0 - (-A) = A
    $ => A          :SUB
    1 => B          :RETURN

; @info byte length of B
; @in B => number
; @out A => bytes length
getLenBytes:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    ; store current registries
                               :SAVE(B,C,D,E,RR,RCX)
    ; set C as counter to 0
    0 => C
    B => A

getLenBytesLoop:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)

    0 => B
    ; if A is zero, finish counter
    $               :EQ,JMPC(getLenEnd)
    ; right shift one byte
    1 => D          :CALL(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    ; increase counter
    C + 1 => C      :JMP(getLenBytesLoop)

getLenEnd:
    ; counter to A
    C => A
    ; recover registries
                    :RESTORE, RETURN

; @info bits length of B
; @in B => number
; @out A => bits length
getLenBits:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    ; store current registries
                               :SAVE(B,C,D,E,RR,RCX)
    ; set C as counter to 0
    0 => C
    B => A

getLenBitsLoop:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    0 => B
    ; if B is zero, finish counter
    $               :EQ,JMPC(getLenBitsEnd)
    ; divide value by 2
    A               :MSTORE(arithA)
    2               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A          :MLOAD(arithRes1)
    ; increase counter
    C + 1 => C      :JMP(getLenBitsLoop)

getLenBitsEnd:
    ; counter to A
    C => A
    ; recover registries
                    :RESTORE, RETURN

VAR GLOBAL __MSTOREX_len
VAR GLOBAL bytesToStore

        ; store C with length (bytes), if length == 0 then nothing to do, go to __MSTOREX_end
        C                   :MSTORE(tmpVarLength_mstore),JMPZ(__MSTOREX_end)

        ; check step counters
        %MAX_CNT_STEPS - STEP - 40 :JMPN(outOfCountersStep)

        ; if length > 32 then ERROR
        32 - C              :JMPN(errorMLOADMSTORE)

        ; saving registers used
        A                   :MSTORE(tmpVarA_mstore)
        B                   :MSTORE(tmpVarB_mstore)
        D                   :MSTORE(tmpVarD_mstore)
        RR                  :MSTORE(tmpVarRR_mstore)

        ; A = offset in bytes of byte-address, no trust, if offset = 0 then go __MSTOREX_offset0
        ; on __MSTOREX_offset0 must be verified value of A.
        $0{E % 32} => A     :MSTORE(tmpVarOffset_mstore), JMPZ(__MSTOREX_offset0)

        ; check MemAlign counters
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 3  :JMPN(outOfCountersMemalign)

        A => C              :JMPN(failAssert)    ; check A,C is positive 32 bits (A7..A1 = 0 because use $0)
        31 - C              :JMPN(failAssert)    ; check C < 32, if not MAP

        $0{E / 32} => RR    :JMPN(failAssert)    ; address (ASSERT RR is 32-bit value) 4G x 32 bytes = 128GB
        RR * 32 + C => A                         ; rebuild address to check that is same.
        E                   :ASSERT

        ;
        ; [STEP 1]: Obtain a copy of memory (as a backup) of a 32-byte word that will be partially overwritten.
        ;
        ; =========================== A (M0_addr) ========================######################### B (M0_addr+1) ########################
        ;                           :                                                              :
        ; |<-------- offset ------->======================================##########################  => B,oldvalue
        ;                           |<--------------------------- 32 bytes ----------------------->|
        ;

        $ => A      :MLOAD(MEM:RR)          ; M0
        $ => B      :MLOAD(MEM:RR+1)        ; M1
        ; C = offset,
        ; B = 32 current bytes of memory
        $ => B      :MEM_ALIGN_RD ; read this 32 bytes with offset

        ;
        ; [STEP 2]: clear not used bytes of bytesToStore and oldvalue at same time.
        ; A short-example with 3 bytes instead of 32.
        ;
        ;   bytesToStore = ABCDEF
        ;   B (memory backup) = 123456
        ;   length = 2
        ;
        ; In this operation is cleared two things:
        ;  - bytes of bytesToStore out of length: ABCDEF => AB0000
        ;  - on bytes read from memory, clean where we put bytesToStore: 123456 => 003456
        ;
        ;   bytesToStore =      AB0000
        ;   B (memory backup) = 003456
        ;
        ; Now we put bytesToStore and B side-by-side
        ;
        ;   bytesToStore  | B  =  ABCDEF123456
        ;                              ↓  write 0, with offset = 2
        ;   bytesToStore' | B' =  AB0000003456
        ;
        ; This operation is like a MEM_ALIGN_WR where M0 = bytesToStore, M1 = B, V = 0, offset = bytes = 2, W0 = bytesToStore', W1 = B'
        ;
        ;
        ; Graphical example:
        ;
        ; ******************* A (bytesToStore) ***************************======================================##########################
        ;                                     :                                                              :
        ; |<----------- length  ------------->0000000000000000000000000000000000000000000000000000000000000000
        ;                                     |<--------------------------- 32 bytes ----------------------->|
        ; ************************************0000000000000000000000000000                                   :                             => D
        ;                                                                 000000000000000000000000000000000000==########################## => E
        ;

        $ => A  :MLOAD(bytesToStore)
        ; B contains bytes of memory before write
        $ => C  :MLOAD(tmpVarLength_mstore)
        ${memAlignWR_W0(A,0,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,0,C)} => E ; no trust calculate W1
        0       :MEM_ALIGN_WR

        ; D    ************************************0000000000000000000000000000
        ; E    000000000000000000000000000000000000==##########################
        ; D+E  ************************************==########################## => tmpVar32BytesToStore_mstore
        ; D and E are  bit-disjoint, addition as logical-or

        D + E   :MSTORE(tmpVar32BytesToStore_mstore)

        ;
        ; [STEP 3]: store 32 bytes of this mix of bytes, first "length" bytes comes from bytesToStore, and others bytes comes current value
        ;           in memory, before write.
        ;
        ; =========================== A (M0_addr) ========================######################### B (M0_addr+1) ########################
        ;                           :                                                              :
        ; |<-------- offset ------->************************************==##########################
        ;                           |<--------------------------- 32 bytes ----------------------->|
        ;
        ; ==========================************************************==################################################################

        $ => A          :MLOAD(MEM:RR)       ;M0
        $ => B          :MLOAD(MEM:RR+1)     ;M1
        $ => C          :MLOAD(tmpVarOffset_mstore)

        ${memAlignWR_W0(A,mem.tmpVar32BytesToStore_mstore,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,mem.tmpVar32BytesToStore_mstore,C)} => E ; no trust calculate W1
        $               :MEM_ALIGN_WR,MLOAD(tmpVar32BytesToStore_mstore)

        ; write values on memory
        D               :MSTORE(MEM:RR)
        E               :MSTORE(MEM:RR+1)

        ; recalculate result on E as address + length. At this point E = 256-bit address * 32 + offset (C)
        ; pending add length
        RR * 32 + C => E

        ; restore C with length and add it to E
        $ => C          :MLOAD(tmpVarLength_mstore)
        E + C => E

        ; restore used registers and return
        $ => RR         :MLOAD(tmpVarRR_mstore)
        $ => A          :MLOAD(tmpVarA_mstore)
        $ => B          :MLOAD(tmpVarB_mstore)
        $ => D          :MLOAD(tmpVarD_mstore),RETURN

__MSTOREX_end:
        ; trivial case if length(C) == 0
        :RETURN

__MSTOREX_offset0:
        ; short path, offset == 0 (no trust)

        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        ; in this branch assume offset == 0, if offset != 0 ==> RR * 32 != E
        $0{E / 32} => RR    :JMPN(failAssert)       ; address (ASSERT E is 32-bit value) 4G x 32 bytes = 128GB
        RR * 32 - E         :JMPNZ(failAssert)      ; 32 bits * 32 (5 bits) = 37 bits is secure for FF

        ; [STEP 1]: offset == 0, aligned read, memalign no needed.
        $ => B              :MLOAD(MEM:RR)          ; M0

        ; [STEP 2]: (see previous explanation)
        $ => A              :MLOAD(bytesToStore)
        ; B = current 32 bytes of memory
        ; C = length
        ${memAlignWR_W0(A,0,C)} => D ; no trust calculate W0
        ${memAlignWR_W1(B,0,C)} => E ; no trust calculate W1
        0                   :MEM_ALIGN_WR

        ; [STEP 3]: trivial step, offset == 0 ==> aligned write,
        ;           memalign no needed, directly store the logical-or of D and E
        D + E               :MSTORE(MEM:RR)

        ; Calculate output E = 256-bit address * 32 + length (C), offset = 0
        RR * 32 + C => E

        ; restore used registers, C contains original value (length)
        $ => RR             :MLOAD(tmpVarRR_mstore)
        $ => A              :MLOAD(tmpVarA_mstore)
        $ => B              :MLOAD(tmpVarB_mstore)
        $ => D              :MLOAD(tmpVarD_mstore),RETURN

; @info save value to memory 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @out E => new offset

MSTORE32:
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        A                           :SAVE(B,C,D,E,RR,RCX)
        32 => C                     :MSTORE(__MSTOREX_len), JMP(__MSTOREX_afterSave)
        
; @info save value to memory < 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset 
; @in C => length
; @out E => new offset
        
MSTOREX:  
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        C           :MSTORE(__MSTOREX_len), JMPZ(__MSTOREX_end)

        A           :SAVE(B,C,D,E,RR,RCX)
        C           :JMP_GT(32, errorMLOADMSTORE)

__MSTOREX_afterSave:

        ; verification without binary, required in non trust if E > 2**32, after that will verify two paths
        ; path E < 2**32: 
        ;   A0 < 2**32 => JMPN fails (if A0 < 0 then path __errorEmore32bits)
        ;   A7..A1 == 0 because use $0
        ;   A < 2**32
        ;   E == A if not ASSERT fails => E < 2**32
        ;   E >= MAX_MEM_EXPANSION_BYTES ==> errorMLOADMSTORE

        $0{E > 0xFFFFFFFF ? -1:E} => A  :JMPN(__errorEmore32bits)
        E                               :ASSERT,JMP_GE(%MAX_MEM_EXPANSION_BYTES, errorMLOADMSTORE)

        $0{E / 32} => RR                :JMPN(failAssert)
        ; RR = 32 bits positive value

        $BYTE{E%32} => RCX,A          
        RCX                             :JMP_GT(31, failAssert)

        ; E === 32 * RR + A (RCX)
        ; E - 32 * RR === A
        ; secure: E < MAX_MEM_EXPASION_BYTES < 32 bits, RR < 32 bits, 32*RR < 37 bits, all < 38 bits
        E - 32 * RR                 :ASSERT
        
        RCX + %MEM_ALIGN_LEN * C + %MEM_ALIGN_LEFT_ALIGNMENT => C     :JMP_EQ(%MEM_ALIGN_LEN * 32 + %MEM_ALIGN_LEFT_ALIGNMENT, __MSTORE32_offset0_len32)

        $ => A                  :MLOAD(MEM:RR)
        $ => B                  :MLOAD(MEM:RR+1)

        ${memAlignWR_W0(A,mem.bytesToStore,C)} => D    :MSTORE(MEM:RR)      ; no trust calculate W0
        ${memAlignWR_W1(B,mem.bytesToStore,C)} => E    :MSTORE(MEM:RR + 1)  ; no trust calculate W1

        $                       :MEM_ALIGN_WR,MLOAD(bytesToStore),JMP(__MSTORE32_restore)

__MSTORE32_offset0_len32:
        $ => C                  :MLOAD(bytesToStore)
        C                       :MSTORE(MEM:RR)

__MSTORE32_restore:
        $ => A                  :RESTORE
        __MSTOREX_len + E => E  :RETURN

        
__MSTOREX_end:
                                :RETURN

; @info get value from memory (32 bytes)
; @in E => offset
; @out A => value
; @out E => new offset

MLOAD32:
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        32 => C                         :SAVE(B,C,D,E,RR,RCX), JMP(__MLOADX_afterSave)

; @info get value from memory (< 32 bytes)
; @in E => offset
; @in C => length
; @out A => value
; @out E => new offset
        
MLOADX:  
        ; check step counters
        %MAX_CNT_STEPS - STEP - 20              :JMPN(outOfCountersStep)
        %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

        C                                       :JMP_GT(32, errorMLOADMSTORE)
        C                                       :SAVE(B,C,D,E,RR,RCX), JMPZ(__MLOADX_len0)

__MLOADX_afterSave:

        ; verification without binary, required in non trust if E > 2**32, after that will verify two paths
        ; path E < 2**32: 
        ;   A0 < 2**32 => JMPN fails (if A0 < 0 then path __errorEmore32bits)
        ;   A7..A1 == 0 because use $0
        ;   A < 2**32
        ;   E == A if not ASSERT fails => E < 2**32
        ;   E >= MAX_MEM_EXPANSION_BYTES ==> errorMLOADMSTORE

        $0{E > 0xFFFFFFFF ? -1:E} => A  :JMPN(__errorEmore32bits)
        E                               :ASSERT,JMP_GE(%MAX_MEM_EXPANSION_BYTES, errorMLOADMSTORE)

        $0{E / 32} => RR                :JMPN(failAssert)
        ; RR = 32 bits positive value

        $BYTE{E%32} => RCX,A          
        RCX                             :JMP_GT(31, failAssert)

        ; E === 32 * RR + A (RCX)
        ; E - 32 * RR === A
        ; secure: E < MAX_MEM_EXPASION_BYTES < 32 bits, RR < 32 bits, 32*RR < 37 bits, all < 38 bits
        E - 32 * RR                 :ASSERT
        
        RCX + %MEM_ALIGN_LEN * C + %MEM_ALIGN_LEFT_ALIGNMENT => C     :JMP_EQ(%MEM_ALIGN_LEN * 32 + %MEM_ALIGN_LEFT_ALIGNMENT, __MLOAD32_offset0_len32)

        $ => A                  :MLOAD(MEM:RR)
        $ => B                  :MLOAD(MEM:RR+1)

        $ => A                  :MEM_ALIGN_RD,JMP(__MLOAD32_restore)

__MLOAD32_offset0_len32:
        $ => A                  :MLOAD(MEM:RR)

__MLOAD32_restore:
        $                       :RESTORE,MSTORE(__MSTOREX_len)
        __MSTOREX_len + E => E  :RETURN
        
__MLOADX_len0:
        0 => A                  :RETURN

__errorEmore32bits:
        ; path E >= 2**32 must be verified (dual path protection)
        ; E >= 2**32 === !(E < 2**32)
        E => A 
        2n**32n => B
        ; don't check binary counter, because here was a problem of dual path, if check
        ; before this path was a performance problem. It's only one binary and it's outOfGas
        0   :LT,JMP(errorMLOADMSTORE)

errorMLOADMSTORE:
                    :JMP(outOfGas)

; @info check account is empty ( balance == nonce == code == 0x )
; @in A => address
; @out A => isEmpty => 1 = true, 0 = false
isEmptyAccount:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50                                              :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3                                        :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - %MAX_CNT_POSEIDON_SLOAD_SSTORE*3 :JMPN(outOfCountersPoseidon)

    ; store current registries
                                :SAVE(B,C,D,E,RR,RCX)
    A => E
    ; read balance
    ; set key for smt balance query.
    %SMT_KEY_BALANCE => B
    0 => C
    $ => B                      :SLOAD
    ; balance in A
    0 => A
    ; if balance is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    ; check nonce
    E => A
    ; set key for smt nonce query
    %SMT_KEY_NONCE => B
    ; nonce in B
    $ => B                      :SLOAD
    0 => A
    ; if nonce is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    ; read bytecode
    E => A
    ; set key for smt smart contract query
    %SMT_KEY_SC_CODE => B
    ; sc in B
    $ => B                      :SLOAD
    0 => A
    ; if code is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    1 => A                      :JMP(IsEmptyEnd)

isNotEmptyAccount:
    0 => A                      :JMP(IsEmptyEnd)

IsEmptyEnd:
    ; recover registries
                                :RESTORE,RETURN

; @info Compute gas to send to call following EIP 150
; @in gasCall: gas sent to call
; @out A => min( requested_gas , all_but_one_64th(63/64) )
computeGasSendCall:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 30       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    ; save tmp vars
                            :SAVE(B,C,D,E,RR,RCX)
    ; compute all_but_one_64th gas
    GAS => A

    ; C = [c7, c6, ..., c0]
    ; JMPN instruction assures c0 is within the range [0, 2**32 - 1]
    ${GAS >> 6} => C        :JMPN(failAssert)
    ; We secure D to be less than 32 bits with $0{}
    $0{GAS & 0x3f} => D

    ; since D is assured to be less than 0x40
    ; it is enforced that [c7, c6, ..., c1] are 0 since there is no value multiplied by 64
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, c0 * 64 + d0 could not overflow the field
    C * 64 + D              :ASSERT
    0x3f - D                :JMPN(failAssert) ; D is less than 32 bits, we can use JMPN

    GAS - C => A
    ; gasCall can be more than 32 bits, obtained from stack
    $ => B                  :MLOAD(gasCall)
    ; gas_sent_with_call = min(requested_gas, all_but_one_64th)
    $                       :LT,JMPC(computeGasSendCallEnd)
    ; gas to substract
    B => A

computeGasSendCallEnd:
    ; restore stored values
                            :RESTORE, RETURN

; @info compute memory expansion gas cost
; @in: lastMemOffset: offset to copy bytes
; @in: lastMemLength: size of the bytes to copy
saveMem:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100      :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 5 :JMPN(outOfCountersBinary)
    A                           :SAVE(B,C,D,E,RR,RCX)
    $ => A                      :MLOAD(lastMemLength)
    ; If no len, no memory expansion
    0 => B
    $                           :EQ, JMPC(saveMemEnd)
    $ => B                      :MLOAD(lastMemOffset)
    ; If the binary has a carry, means the mem expansion is very big. We can jump to oog directly
    ; offset + length in B
    $ => B                      :ADD, JMPC(outOfGas)
    ; check new memory length is lower than 2**22 - 31 - 1 (max supported memory expansion for %TX_GAS_LIMIT of gas)
    %MAX_MEM_EXPANSION_BYTES => A
    $                           :LT,JMPC(outOfGas)


    ; load old memory length, if is greater than new memory length, no expansion cost
    $ => A                      :MLOAD(memLength)
    ; Both A and B are LT than MAX_MEM_EXPANSION_BYTES, this means they are lower thatn 32 bits, we don't need to use a binary to operate
    A - B                       :JMPN(saveMemGAS, saveMemEnd)

saveMemGAS:
    ; store new memory length
    B => E                          :MSTORE(memLength)
    ; memory_size_word = (memory_byte_size + 31) / 32 in E
    ; ${(B+31)/32} => E
    E + 31 => A

    ; E = [e7, e6, ..., e0]
    ; JMPN instruction assures e0 is within the range [0, 2**32 - 1]
    ${A >> 5} => E              :JMPN(failAssert)
    $0{A & 0x1f} => D

    ; since D is assured to be less than 0x20
    ; it is enforced that [e7, e6, ..., e1] are 0 since there is no value multiplied by 32
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, e0 * 32 + d0 could not overflow the field
    E * 32 + D                  :ASSERT
    0x1f - D                    :JMPN(failAssert) ; D is less than 32 bits, we can use JMPN

    ; memory_cost = (memory_size_word ** 2) / 512 + (3 * memory_size_word) in A
    ; ${E*E/512} + 3*E=> A
    E                           :MSTORE(arithA)
    E                           :MSTORE(arithB), CALL(mulARITH); in: [arithA, arithB] out: [arithRes1: arithA*arithB, mulFlagOverflow: value overflow, mulArithOverflowFlag: set to 1 if operation causes overflow]
    $ => C                      :MLOAD(arithRes1)
    $                           :MLOAD(mulArithOverflowFlag), JMPNZ(outOfGas)
    C                           :MSTORE(arithA)
    512                         :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A                      :MLOAD(arithRes1)
    A + 3*E => A
    $ => B                      :MLOAD(lastMemoryExpansionCost)
    A                           :MSTORE(lastMemoryExpansionCost)
    ; memory_expansion_cost = new_memory_cost - last_memory_cost
    A - B => A
    ; update new gas
    GAS - A => GAS               :JMPN(outOfGas)

saveMemEnd:
    ; restore stored values
                                 :RESTORE, RETURN

VAR GLOBAL arithA
VAR GLOBAL arithB
VAR GLOBAL arithRes1
VAR GLOBAL arithRes2

VAR GLOBAL addArithOverflow
; @info binary addition
; @in: arithA: addend value
; @in: arithB: addend value
; @out: arithRes1: arithA + arithB
addARITH:

    A               :SAVE(B,C,D,E,RR,RCX)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => E          :ADD, MSTORE(arithRes1), JMPC(setAddArithOverflow)
    0               :MSTORE(addArithOverflow), JMP(finishAddArith)

setAddArithOverflow:
    1               :MSTORE(addArithOverflow)

finishAddArith:
    $ => A          :RESTORE, RETURN

; @info binary subtraction
; @in: arithA: minuend value
; @in: arithB: subtrahend value
; @out: arithRes1: arithA - arithB
subARITH:
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 10       :JMPN(outOfCountersStep)
    A               :SAVE(B,C,D,E,RR,RCX)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => A          :SUB,MSTORE(arithRes1)
    $ => A          :RESTORE, RETURN

VAR GLOBAL mulArithOverflowValue
VAR GLOBAL mulArithOverflowFlag
; @info arithmetic multiplication
; @in: arithA: multiplier value
; @in: arithB: multiplicand value
; @out: arithRes1: product of multiplication arithA * arithB
; @out: mulArithOverflowValue: overflow value
; @out: mulArithOverflowFlag: set to 1 if operation causes overflow
mulARITH:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)

    A               :SAVE(B,C,D,E,RR,RCX)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    0 => C
    $${var _mulArith = A * B}
    ${_mulArith >> 256} => D
    ${_mulArith} => E :ARITH

    E               :MSTORE(arithRes1)
    D               :MSTORE(mulArithOverflowValue)
    D => A
    0 => B
    $               :EQ,JMPNC(setMulArithOverflow)
    0               :MSTORE(mulArithOverflowFlag), JMP(finishMulArith)

setMulArithOverflow:
    1               :MSTORE(mulArithOverflowFlag)

finishMulArith:
    $ => A          :RESTORE, RETURN

; @info arithmetic division
; @in: arithA: dividend value
; @in: arithB: divisor value
; @out: arithRes1: quotient of division arithA / arithB
; @out: arithRes2: remainder of division arithA % arithB
divARITH:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 30       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)
    A               :SAVE(B,C,D,E,RR,RCX)
    $ => E          :MLOAD(arithA)
    $ => A          :MLOAD(arithB)
    ; Check denominator(A) is not zero
    0 => B
    $               :EQ, JMPC(zeroDiv)
    ; Check if dividend (E) is lower or equal than divisor E < A
    E => B ; dividend
    $               :LT, JMPNC(divisorSmallerDiv)
    ; A*B + C = D * 2**256 + op(E)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)
    ${E%A} => C     :MSTORE(arithRes2); remainder
    ${E/A} => B     :MSTORE(arithRes1); quotient
    ; D = 0 here
    E               :ARITH
    A => B
    C => A
    ; check divisor > remadinder
    1               :LT
    ; Recover used regs
    $ => A          :MLOAD(tmpVarAArith)
    $ => B          :MLOAD(tmpVarBArith)
    $ => C          :MLOAD(tmpVarCArith)
    $ => D          :MLOAD(tmpVarDArith)
    $ => E          :MLOAD(tmpVarEArith), RETURN

    ${E%A} => C ; remainder
    ${E/A} => B
    0 => D
    E               :ARITH

    B               :MSTORE(arithRes1)
    C               :MSTORE(arithRes2)

    ; check divisor > remainder
    A => B ; divisor
    C => A ; remainder
    $ => A          :LT
    1               :ASSERT
    $ => A          :RESTORE, RETURN

zeroDiv:
    ; divisor is zero, return zero for both quotient and remainder
    0               :MSTORE(arithRes1)
    0               :MSTORE(arithRes2)
    $ => A          :RESTORE, RETURN

divisorSmallerDiv:
    ; check if divisor is eq than dividend
    $               :EQ, JMPC(divisorEqDividenDiv)
    ; dividend is smaller than divisor, quotion is zero and remainder is dividend
    0               :MSTORE(arithRes1)
    E               :MSTORE(arithRes2)
    $ => A          :RESTORE, RETURN

; @info Shift right D bytes to A
; @in A
; @in D -> WARNING: expect D to be less than 32 bits
; @out A - A >> (8*D) => A
SHRarith:
    %MAX_CNT_STEPS - STEP - 8               :JMPN(outOfCountersStep)

    31 - D      :JMPN(SHRarith_32)
    D           :JMPZ(SHRarith_0)

    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)

    32 - D => C :SAVE(B,C,D,E,RCX,RR)
    A => B
    0 => A
    $ => A      :MEM_ALIGN_RD
                :RESTORE, RETURN

SHRarith_32:
    0 => A      :RETURN
SHRarith_0:
                :RETURN

; @info Shift left D bytes to A
; @in A
; @in D -> WARNING: expect D to be less than 32 bits
; @out A - A << (8*D) => A
SHLarith:
    %MAX_CNT_STEPS - STEP - 6               :JMPN(outOfCountersStep)

    31 - D      :JMPN(SHLarith_32)

    D => C      :SAVE(B,C,D,E,RCX,RR),JMPZ(SHLarith_0)

    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)
    0 => B
    $ => A      :MEM_ALIGN_RD
                :RESTORE, RETURN

SHLarith_32:
    0 => A      :RETURN
SHLarith_0:
                :RESTORE, RETURN

; @info Shift right D bits to A
; @in A
; @in D -> WARNING: expect D to be less than 32 bits
; @out A - (A >> D) => A

SHRarithBit:
    %MAX_CNT_STEPS - STEP - 9   :JMPN(outOfCountersStep)
    255 - D                     :JMPN(SHRarithBit_A0)

    D => RR                     :SAVE(B,C,D,E,RCX,RR),JMPZ(SHRarithBit_D0)
    0 => C,B                    :JMP(@SHRarithBit_table + RR)

SHRarithBit_arith:
    %MAX_CNT_ARITH - CNT_ARITH - 1  :JMPN(outOfCountersArith)

    ${(A >> RR) & const.MAX_UINT_256} => D
    ${(A << (256 - RR)) & const.MAX_UINT_256} :ARITH
    D => A                      :RESTORE, RETURN

SHRarithBit_memalign:
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)
    A => B
    0 => A
    $ => A                      :MEM_ALIGN_RD
SHRarithBit_D0:
                                :RESTORE, RETURN
SHRarithBit_A0:
    0 => A                      :RETURN

INCLUDE "tables/shr_bits_table.zkasm"


; @info Shift left D bits to A
; @in A
; @in D -> WARNING: expect D to be less than 32 bits
; @out A - (A << D) => A

SHLarithBit:
    %MAX_CNT_STEPS - STEP - 8   :JMPN(outOfCountersStep)
    255 - D                     :JMPN(SHLarithBit_A0)

    D => RR                     :SAVE(B,C,D,E,RCX,RR),JMPZ(SHLarithBit_D0)
    0 => C,B                    :JMP(@SHLarithBit_table + RR)

SHLarithBit_arith:
    %MAX_CNT_ARITH - CNT_ARITH - 1  :JMPN(outOfCountersArith)

    ${(A >> (256 - RR)) & const.MAX_UINT_256} => D
    ${(A << RR) & const.MAX_UINT_256} => A             :ARITH
                                                       :RESTORE, RETURN
SHLarithBit_memalign:
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1  :JMPN(outOfCountersMemalign)
    $ => A                                  :MEM_ALIGN_RD

SHLarithBit_D0:
                                :RESTORE, RETURN
SHLarithBit_A0:
    0 => A                      :RETURN

INCLUDE "tables/shl_bits_table.zkasm"

; out of counters full tracer event trigger
outOfCountersStep:
    $${eventLog(onError, OOCS)}                     :JMP(handleBatchError)
outOfCountersKeccak:
    $${eventLog(onError, OOCK)}                     :JMP(handleBatchError)
outOfCountersBinary:
    $${eventLog(onError, OOCB)}                     :JMP(handleBatchError)
outOfCountersMemalign:
    $${eventLog(onError, OOCM)}                     :JMP(handleBatchError)
outOfCountersArith:
    $${eventLog(onError, OOCA)}                     :JMP(handleBatchError)
outOfCountersPadding:
    $${eventLog(onError, OOCPA)}                    :JMP(handleBatchError)
outOfCountersPoseidon:
    $${eventLog(onError, OOCPO)}                    :JMP(handleBatchError)
outOfCountersSha256:
    $${eventLog(onError, OOCSH)}                    :JMP(handleBatchError)
invalidChangeL2BlockMinTimestamp:
    $${eventLog(onError, invalid_change_l2_block_min_timestamp)}    :JMP(handleBatchError)
invalidL1InfoTreeIndex:
    $${eventLog(onError, invalid_L1_info_tree_index)}    :JMP(handleBatchError)
outOfGas:
    $${eventLog(onError, OOG)}                      :JMP(handleError)
invalidJump:
    $${eventLog(onError, invalidJump)}              :JMP(handleError)
invalidOpcode:
    $${eventLog(onError, invalidOpcode)}            :JMP(handleError)
stackUnderflow:
    $${eventLog(onError, underflow)}                :JMP(handleError)
stackOverflow:
    $${eventLog(onError, overflow)}                 :JMP(handleError)
deployAddressCollision:
    $${eventLog(onError, invalidAddressCollision)}  :JMP(handleError)
invalidStaticTx:
    $${eventLog(onError, invalidStaticTx)}          :JMP(handleError)
invalidCodeSize:
    $${eventLog(onError, invalidCodeSize)}          :JMP(handleError)
invalidCodeStartsEF:
    $${eventLog(onError, invalidCodeStartsEF)}      :JMP(handleError)

handleError:
    %MAX_CNT_STEPS - STEP - 500         :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2    :JMPN(outOfCountersBinary)
    ;revert all state changes
    $ => SR         :MLOAD(initSR), CALL(revertTouched)
                    :CALL(revertBlockInfoTree)

    $ => A          :MLOAD(originCTX), JMPZ(errorAtFirstContext)
    A => CTX
    ; Add return data context value to origin context
    ; Clear return data context
    0               :MSTORE(retDataCTX)
    CTX             :MSTORE(currentCTX)
    $ => GAS        :MLOAD(gasCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++), JMP(readCode)

handleBatchError:
    ; restore init state root and finish batch
    $ => SR                     :MLOAD(batchSR)
    $${eventLog(onFinishTx)}    :JMP(finalizeBatch)

errorAtFirstContext:
    ; Set tx status to failure
    0               :MSTORE(txStatus)
    ;save Root and jump to send gas to sequencer
    0               :MSTORE(gasRefund)
    ;remaining gas = 0
    0 => GAS        :JMP(sendGasSeq)

;Get offset/32 & offset%32
;@in A offset (offset is assumed to be less than %MAX_MEM_EXPANSION_BYTES)
;@out E offset/32
;@out C offset%32
offsetUtil:
    %MAX_CNT_STEPS - STEP - 20          :JMPN(outOfCountersStep)

    ; E = [e7, e6, ..., e0]
    ; JMPN instruction assures e0 is within the range [0, 2**32 - 1]
    ${A >> 5} => E                      :JMPN(failAssert)
    $0{A & 0x1F} => C                   ; C is 32 bits

    ; since C is assured to be less than 0x20
    ; it is enforced that [e7, e6, ..., e1] are 0 since there is no value multiplied by 32
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, e0 * 32 + c0 could not overflow the field
    E * 32 + C                          :ASSERT
    0x1F - C                            :JMPN(failAssert); If C is greater than 31, it is an error
                                        :RETURN

;@info: move balances between two accounts
;@in: txSrcAddr: source address
;@in: storageAddr: destination address
;@in: txValue: transaction value
moveBalances:
;;;;;;;;
; evmCALL (Move Balances)
;;;;;;;;
    %MAX_CNT_STEPS - STEP - 50                                              :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 5                                        :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - %MAX_CNT_POSEIDON_SLOAD_SSTORE*4 :JMPN(outOfCountersPoseidon)
    ;Check if is a delegate call
    $ => A                          :MLOAD(isDelegateCall), JMPNZ(endMoveBalances)
    ; Decrement source balance
    $ => A                          :MLOAD(txSrcAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE => B
    0 => C
    ; Balance in A
    $ => A                          :SLOAD
    ; value in B
    $ => B                          :MLOAD(txValue)
    ; Check has enough balance to pay the value. In case not, means we are in a CALL/CALLCODE
    $                               :LT,JMPC(invalidCall)
    ; sourceBalance - value in D
    $ => D                          :SUB
    ; update source balance
    $ => A                          :MLOAD(txSrcAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE => B
    $ => SR                         :SSTORE
    ; Increment destination balance
    $ => A                          :MLOAD(storageAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE  => B
    ; Balance in A
    $ => A                          :SLOAD
    $ => B                          :MLOAD(txValue)
    $ => D                          :ADD
    $ => A                          :MLOAD(storageAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE  => B
    0 => C
    $ => SR                         :SSTORE
endMoveBalances:
                                    :RETURN

invalidCall:
    ; return to origin context
    $ => SR                         :MLOAD(initSR)
    ; if last context, finish tx
    $ => A                          :MLOAD(originCTX),JMPZ(handleGas)
    A => CTX
    0                               :MSTORE(retDataCTX)
    CTX                             :MSTORE(currentCTX)
    $ => A                          :MLOAD(gasCTX)
    GAS + A => GAS
    $ => SP                         :MLOAD(lastSP)
    $ => PC                         :MLOAD(lastPC)
    0                               :MSTORE(SP++), JMP(readCode)

VAR GLOBAL pushBytes
VAR GLOBAL pushBytes_RR
; @info Read bytes opcode PUSHX
; @internalParam {numBlocks} 4 bytes blocks to read
; @internalParam {leftBytes} remaining bytes
; @in D,E => bytes to read (1..32)
; @out E => value read

readPush:
                            :JMP(@readPush+E)    ;0
readPush1:
    PC => HASHPOS           :JMP(_readPush1)     ;1
readPush2:
    PC => HASHPOS           :JMP(_readPush2)     ;2
readPush3:
    PC => HASHPOS           :JMP(_readPush3)     ;3
readPush4:
    PC => HASHPOS           :JMP(_readPush4)     ;4
readPush5:
    PC => HASHPOS           :JMP(_readPushX)     ;5
readPush6:
    PC => HASHPOS           :JMP(_readPushX)     ;6
readPush7:
    PC => HASHPOS           :JMP(_readPushX)     ;7
readPush8:
    PC => HASHPOS           :JMP(_readPushX)     ;8
readPush9:
    PC => HASHPOS           :JMP(_readPushX)     ;9
readPush10:
    PC => HASHPOS           :JMP(_readPushX)     ;10
readPush11:
    PC => HASHPOS           :JMP(_readPushX)     ;11
readPush12:
    PC => HASHPOS           :JMP(_readPushX)     ;12
readPush13:
    PC => HASHPOS           :JMP(_readPushX)     ;13
readPush14:
    PC => HASHPOS           :JMP(_readPushX)     ;14
readPush15:
    PC => HASHPOS           :JMP(_readPushX)     ;15
readPush16:
    PC => HASHPOS           :JMP(_readPushX)     ;16
readPush17:
    PC => HASHPOS           :JMP(_readPushX)     ;17
readPush18:
    PC => HASHPOS           :JMP(_readPushX)     ;18
readPush19:
    PC => HASHPOS           :JMP(_readPushX)     ;19
readPush20:
    PC => HASHPOS           :JMP(_readPushX)     ;20
readPush21:
    PC => HASHPOS           :JMP(_readPushX)     ;21
readPush22:
    PC => HASHPOS           :JMP(_readPushX)     ;22
readPush23:
    PC => HASHPOS           :JMP(_readPushX)     ;23
readPush24:
    PC => HASHPOS           :JMP(_readPushX)     ;24
readPush25:
    PC => HASHPOS           :JMP(_readPushX)     ;25
readPush26:
    PC => HASHPOS           :JMP(_readPushX)     ;26
readPush27:
    PC => HASHPOS           :JMP(_readPushX)     ;27
readPush28:
    PC => HASHPOS           :JMP(_readPushX)     ;28
readPush29:
    PC => HASHPOS           :JMP(_readPushX)     ;29
readPush30:
    PC => HASHPOS           :JMP(_readPushX)     ;30
readPush31:
    PC => HASHPOS           :JMP(_readPushX)     ;31
readPush32:
    PC => HASHPOS           :JMP(_readPush32)    ;32

_readPush1:
    $ => E                      :MLOAD(contractHashId)
    $ => E                      :HASHP1(E),RETURN

_readPush2:
    $ => E                      :MLOAD(contractHashId)
    $ => C                      :HASHP1(E)
    C * 256 + $ => E            :F_HASHP1(E), RETURN

_readPush3:
    $ => E                      :MLOAD(contractHashId)
    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => E            :F_HASHP1(E), RETURN

_readPush4:
    $ => E                      :MLOAD(contractHashId)
    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => E            :F_HASHP1(E), RETURN

_readPush32:
    $ => E                      :MLOAD(contractHashId)

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => C            :F_HASHP1(E)

    ; 28 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 24 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 20 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 16 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 12 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 8 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => C   :F_HASHP1(E)

    ; 4 bytes

    $ => A                      :HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    A * 256 + $ => A            :F_HASHP1(E)
    ROTL_C + A * 256 + $ => E   :F_HASHP1(E),RETURN

_readPushBaseTable:

_readPushX:
    $ => B                      :MLOAD(contractHashId)

readPushBytes:
    0 => A, C
    B => E                     :JMP(@_readPushBaseTable - E)

VAR GLOBAL startsWithEF
; @info check bytecode first byte != 0xEF as defined in EIP-3541 (https://eips.ethereum.org/EIPS/eip-3541)
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {startsWithEF} flag to indicate if first deployed byte on the bytecode is 0xEF
checkBytecodeStartsEF:
    %MAX_CNT_STEPS - STEP - 50      :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)

    ; save temporary registers
    A                               :SAVE(B,C,D,E,RCX,RR)

    ; set flag to 0
    0                               :MSTORE(startsWithEF)

    ; check length
    $                               :MLOAD(memSizeLinearPoseidon),JMPZ(checkBytecodeStartsEFend)

    ; load memOffset
    $ => E                          :MLOAD(memOffsetLinearPoseidon)

    ; get 1 byte from memory
    1 => C                          :CALL(MLOADX) ; in: [E: offset, C: length] out: [A: value , E: new offset]

    ; mask first byte
    0xFF00000000000000000000000000000000000000000000000000000000000000n => B
    $ => A                          :AND
    ; check if byte read is equal to 0xEF
    0xEF00000000000000000000000000000000000000000000000000000000000000n => B
    $                               :EQ, JMPNC(checkBytecodeStartsEFend)
    1                               :MSTORE(startsWithEF)

checkBytecodeStartsEFend:
    ; set back tmp registers
    $ => A                          :RESTORE, RETURN

VAR GLOBAL memOffsetLinearPoseidon
VAR GLOBAL memSizeLinearPoseidon
VAR GLOBAL linearPoseidonOutD
; @info Computes hash bytecode from memory bytes
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {memSize} memory size to read bytes from
; @out D => resulting linear poseidon
hashPoseidonLinearFromMemory:
    %MAX_CNT_STEPS - STEP - 50          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    A                               :SAVE(B,C,D,E,RCX,RR)
    $ => E                          :MLOAD(memOffsetLinearPoseidon)
    $ => C                          :MLOAD(memSizeLinearPoseidon)
    0 => D
    C                               :JMPZ(hashPoseidonReturn)
    ; check poseidon counters
    ; 56 is the value used by the prover to increment poseidon counters depending on the hash length
    C                                                       :MSTORE(arithA)
    56                                                      :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => B                                                  :MLOAD(arithRes1)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 1 - B            :JMPN(outOfCountersPoseidon)
    %MAX_CNT_PADDING_PG - CNT_PADDING_PG - 1 - B            :JMPN(outOfCountersPadding)

    ; get a new hashPId
    $ => B                          :MLOAD(nextHashPId)
    B                               :MSTORE(tmpContractHashId)
    B + 1                           :MSTORE(nextHashPId)
    32 => D
    0 => HASHPOS

hashPoseidonLoop:
    %MAX_CNT_STEPS - STEP - 50 :JMPN(outOfCountersStep)

    C               :JMPZ(hashPoseidonEnd)
    C - 32          :JMPN(hashPoseidonFinal)
                    :CALL(MLOAD32)
    E => B
    $ => E          :MLOAD(tmpContractHashId)
    A               :HASHP(E)
    B => E
    C - 32 => C     :JMP(hashPoseidonLoop)


hashPoseidonFinal:
                    :CALL(MLOADX)
    32 - C => D     :CALL(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    $ => E          :MLOAD(tmpContractHashId)
    C => D
    A               :HASHP(E)

hashPoseidonEnd:
    $ => E          :MLOAD(tmpContractHashId)
    HASHPOS         :HASHPLEN(E)
    $ => D          :HASHPDIGEST(E)

hashPoseidonReturn:
    D               :MSTORE(linearPoseidonOutD)
    $ => A          :RESTORE
    $ => D          :MLOAD(linearPoseidonOutD), RETURN

VAR GLOBAL tmpVarBmask
; @info Mask address to 20 bytes
; @in A => address not masked
; @out A => masked address
maskAddress:
    %MAX_CNT_STEPS - STEP - 10          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    B               :MSTORE(tmpVarBmask)
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn => B
    $ => A          :AND
    $ => B          :MLOAD(tmpVarBmask), RETURN

VAR GLOBAL mulModOutC
VAR GLOBAL tmpVarMulMod1

; @info (A*B)%C => C
; @in A
; @in B
; @in C
; @out C
utilMULMOD:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 100         :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 4    :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 2      :JMPN(outOfCountersArith)

    A                                   :SAVE(B,C,D,E,RCX,RR)

    ; The following approach will be followed in order to verify the mulmod operation
    ; A * B + 0 = D*2^256 + E
    ; K * N + mulModResult = D*2^256 + E

    ; Since the k can be bigger than 2²⁵⁶ and therefore does not fit in a register, we split it in the
    ; most significant and less significant part:

    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E
    ; And divide this operation in 2 which fits in 2²⁵⁶ digits

    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2

    ; Mul operation with Arith
    $${var _mulMod = A * B}
    A               :MSTORE(arithA)
    ; here we perform the: A * B + 0 = D*2^256 + E
    ; result is stored in: arithRes1(E) and mulArithOverflowValue(D)
    B               :MSTORE(arithB), CALL(mulARITH)
    C => A
    ; Check if modulus is 0 or 1
    2 => B
    $               :LT, JMPC(zeroOneMod)
    ; Now we will try to perform the following equation:
    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E

    ${(_mulMod / C) >> 256} => B     ; k.h
    ; We can jump with Js, because later it's all verified by the ARITH
    ; the two paths must be mutually exclusive.
    ; mulModNoKH: if kh is non zero, not found a solution only with kl
    ${cond(B == 0)}  :JMPN(mulModNoKH)

    ; in case of malicious prover, check that B was different of zero to
    ; avoid dual path.
    0 => A
    0       :EQ ; assert B != 0

    ; Since there's k.h we will split the equation in those 2
    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2

    ; k.h  * N  = D2
    ; B * A + 0 = 0 * 2²⁵⁶ + E
    ; D2 must be less than 2²⁵⁶
    C => A ; Modulus
    0 => C, D
    ${B * A} => E   :MSTORE(tmpVarMulMod1), ARITH ; D2

    ; k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ; B * A + C = D*2^256 + E
    ; remember that:
    ; result of mul is stored in: arithRes1(E) and mulArithOverflowValue(D)

    ${(_mulMod / A) % (1 << 256)} => B   ; k.l
    ${_mulMod % A} => C        ; mulModResult
    ${(B * A + C) >> 256} => D ; D1
    $               :MLOAD(arithRes1), ARITH

    ; Finally we need to assert the following:
    ; N>resultModulus
    ; D1 + D2 = D
    ; N>resultModulus   ; LT; ASSERT
    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT

    ; Assert D1 + D2 = D ; ADD ;ASSERT
    D => A ; D1
    $ => B          :MLOAD(tmpVarMulMod1) ;D2

    ; verify no carry, because D = D1 + D2 must be less than 2**256
    ; to pass arithmetic equation A * B + C = D * 2**256 + op
    $ => A          :ADD,JMPC(failAssert)
    $               :MLOAD(mulArithOverflowValue), ASSERT, JMP(utilMULMODend)

mulModNoKH:
    ; if theres no K.h the equation is simplified as:
    ; K * N + mulModResult = D*2^256 + E
    ; B * A + C = D*2^256 + E

    C => A ; Modulus on A
    ${(_mulMod / A)} => B   ; k
    ${_mulMod % A} => C     ; mulModResult
    $ => D         :MLOAD(mulArithOverflowValue)
    $              :MLOAD(arithRes1), ARITH

    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT, JMP(utilMULMODend)

zeroOneMod:
    0 => C

utilMULMODend:
    C               :MSTORE(mulModOutC)
    $ => A          :RESTORE
    $ => C          :MLOAD(mulModOutC), RETURN

;@info exp(A,D) --> A^D
;@in A, D => A^D
;@out A => result
expAD:
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 20       :JMPN(outOfCountersStep)
                    :SAVE(B,C,D,E,RCX,RR)
    ;E base
    A => E
    ;B exp
    D => B
    0 => A
    ;if exp == 0 --> expAD0
    $               :EQ,JMPC(expAD0)
    ;A base
    E => A
    0 => B
    ;if base == 0 --> expA0D
    $               :EQ,JMPC(expA0D)
    1 => C

expADloop:
    %MAX_CNT_STEPS - STEP - 50        :JMPN(outOfCountersStep)
    ;A exp
    D => A
    0 => B
    ;if exp == 0 --> expADend
    $               :EQ,JMPC(expADend)
    A               :MSTORE(arithA)
    ;divARITH --> exp/2
    2               :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    ;D = exp/2
    $ => D          :MLOAD(arithRes1)
    ;A = exp%2 (0 or 1)
    $ => A          :MLOAD(arithRes2), JMPZ(expADloop0) ;if exp%2 == 0 --> expADloop0
    E               :MSTORE(arithA)
    ;mulARITH --> E*C
    C               :MSTORE(arithB), CALL(mulARITH)
     ;C = E*C (acc = bp*acc)
    $ => C          :MLOAD(arithRes1)

expADloop0:
    E               :MSTORE(arithA)
    ;mulARITH --> E*E
    E               :MSTORE(arithB), CALL(mulARITH)
    ;E = E*E (bp = bp*bp)
    $ => E          :MLOAD(arithRes1), JMP(expADloop)
;if base == 0, result0
expA0D:
    0 => C
    0 => D          :JMP(expADend)
 ;if exp == 0, result 1
expAD0:
    1 => C
    0 => D

expADend:
    C => A
                    :RESTORE, RETURN

;@info function to force a failed assert
failAssert:
    A - 1           :ASSERT

VAR GLOBAL tmpZkPCComputeMerkleProof
;@info Computes merkle root with from currentL1InfoTreeRoot, currentL1InfoTreeIndex and sibilings
;@out C: merkle tree root
computeMerkleProof:
    ; check zk-counters
    ; 1 keccak for the leaf and 32 for the L1InfoTree
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - 33       :JMPN(outOfCountersKeccak)
    ; 7 steps at most per bit + 21 statics
    %MAX_CNT_STEPS - STEP - 7 * 32 - 21         :JMPN(outOfCountersStep)

    RR                                          :MSTORE(tmpZkPCComputeMerkleProof)
    ; initialization registers for smt verify
    0 => D, A

    $ => B                                  :MLOAD(currentL1InfoTreeIndex)
    $ => C                                  :MLOAD(currentL1InfoTreeRoot)
    ; prepare new hash
    $ => E                                  :MLOAD(nextHashKId)
    E + 1                                   :MSTORE(nextHashKId)
    32 => D

    ; - Start loop 32 levels:
    ;    - provide each 'indexL1InfoTree' bit to either hash left/right the merkle tree nodes
    ;    - compute linear combination of 'indexL1InfoTree' bits to match the 'indexL1InfoTree' itself at the end of the loop

    ; BIT 0
    0 => HASHPOS
    ${B & 0x00000001}                           :JMPZ(hashLeft0)

hashRight0:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 0)}      :HASHK(E+0)
    C                                           :HASHK(E+0)
    A + 0x00000001 => A                         :JMP(hashBranchEnd0)

hashLeft0:
    C                                           :HASHK(E+0)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 0)}      :HASHK(E+0)

hashBranchEnd0:
    HASHPOS                                     :HASHKLEN(E+0)
    $ => C                                      :HASHKDIGEST(E+0)

    ; BIT 1
    0 => HASHPOS
    ${B & 0x00000002}                           :JMPZ(hashLeft1)

hashRight1:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 1)}      :HASHK(E+1)
    C                                           :HASHK(E+1)
    A + 0x00000002 => A                         :JMP(hashBranchEnd1)

hashLeft1:
    C                                           :HASHK(E+1)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 1)}      :HASHK(E+1)

hashBranchEnd1:
    HASHPOS                                     :HASHKLEN(E+1)
    $ => C                                      :HASHKDIGEST(E+1)

    ; BIT 2
    0 => HASHPOS
    ${B & 0x00000004}                           :JMPZ(hashLeft2)

hashRight2:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 2)}      :HASHK(E+2)
    C                                           :HASHK(E+2)
    A + 0x00000004 => A                         :JMP(hashBranchEnd2)

hashLeft2:
    C                                           :HASHK(E+2)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 2)}      :HASHK(E+2)

hashBranchEnd2:
    HASHPOS                                     :HASHKLEN(E+2)
    $ => C                                      :HASHKDIGEST(E+2)

    ; BIT 3
    0 => HASHPOS
    ${B & 0x00000008}                           :JMPZ(hashLeft3)

hashRight3:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 3)}      :HASHK(E+3)
    C                                           :HASHK(E+3)
    A + 0x00000008 => A                         :JMP(hashBranchEnd3)

hashLeft3:
    C                                           :HASHK(E+3)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 3)}      :HASHK(E+3)

hashBranchEnd3:
    HASHPOS                                     :HASHKLEN(E+3)
    $ => C                                      :HASHKDIGEST(E+3)

    ; BIT 4
    0 => HASHPOS
    ${B & 0x00000010}                           :JMPZ(hashLeft4)

hashRight4:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 4)}      :HASHK(E+4)
    C                                           :HASHK(E+4)
    A + 0x00000010 => A                         :JMP(hashBranchEnd4)

hashLeft4:
    C                                           :HASHK(E+4)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 4)}      :HASHK(E+4)

hashBranchEnd4:
    HASHPOS                                     :HASHKLEN(E+4)
    $ => C                                      :HASHKDIGEST(E+4)

    ; BIT 5
    0 => HASHPOS
    ${B & 0x00000020}                           :JMPZ(hashLeft5)

hashRight5:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 5)}      :HASHK(E+5)
    C                                           :HASHK(E+5)
    A + 0x00000020 => A                         :JMP(hashBranchEnd5)

hashLeft5:
    C                                           :HASHK(E+5)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 5)}      :HASHK(E+5)

hashBranchEnd5:
    HASHPOS                                     :HASHKLEN(E+5)
    $ => C                                      :HASHKDIGEST(E+5)

    ; BIT 6
    0 => HASHPOS
    ${B & 0x00000040}                           :JMPZ(hashLeft6)

hashRight6:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 6)}      :HASHK(E+6)
    C                                           :HASHK(E+6)
    A + 0x00000040 => A                         :JMP(hashBranchEnd6)

hashLeft6:
    C                                           :HASHK(E+6)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 6)}      :HASHK(E+6)

hashBranchEnd6:
    HASHPOS                                     :HASHKLEN(E+6)
    $ => C                                      :HASHKDIGEST(E+6)

    ; BIT 7
    0 => HASHPOS
    ${B & 0x00000080}   :JMPZ(hashLeft7)

hashRight7:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 7)}      :HASHK(E+7)
    C                                           :HASHK(E+7)
    A + 0x00000080 => A                         :JMP(hashBranchEnd7)

hashLeft7:
    C                                           :HASHK(E+7)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 7)}      :HASHK(E+7)

hashBranchEnd7:
    HASHPOS                                     :HASHKLEN(E+7)
    $ => C                                      :HASHKDIGEST(E+7)

    ; BIT 8
    0 => HASHPOS
    ${B & 0x00000100}                           :JMPZ(hashLeft8)

hashRight8:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 8)}      :HASHK(E+8)
    C                                           :HASHK(E+8)
    A + 0x00000100 => A                         :JMP(hashBranchEnd8)

hashLeft8:
    C                                           :HASHK(E+8)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 8)}      :HASHK(E+8)

hashBranchEnd8:
    HASHPOS                                     :HASHKLEN(E+8)
    $ => C                                      :HASHKDIGEST(E+8)

    ; BIT 9
    0 => HASHPOS
    ${B & 0x00000200}                           :JMPZ(hashLeft9)

hashRight9:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 9)}      :HASHK(E+9)
    C                                           :HASHK(E+9)
    A + 0x00000200 => A                         :JMP(hashBranchEnd9)

hashLeft9:
    C                                           :HASHK(E+9)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 9)}      :HASHK(E+9)

hashBranchEnd9:
    HASHPOS                                     :HASHKLEN(E+9)
    $ => C                                      :HASHKDIGEST(E+9)

    ; BIT 10
    0 => HASHPOS
    ${B & 0x00000400}                           :JMPZ(hashLeft10)

hashRight10:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 10)}     :HASHK(E+10)
    C                                           :HASHK(E+10)
    A + 0x00000400 => A                         :JMP(hashBranchEnd10)

hashLeft10:
    C                                           :HASHK(E+10)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 10)}     :HASHK(E+10)

hashBranchEnd10:
    HASHPOS                                     :HASHKLEN(E+10)
    $ => C                                      :HASHKDIGEST(E+10)

    ; BIT 11
    0 => HASHPOS
    ${B & 0x00000800}                           :JMPZ(hashLeft11)

hashRight11:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 11)}     :HASHK(E+11)
    C                                           :HASHK(E+11)
    A + 0x00000800 => A                         :JMP(hashBranchEnd11)

hashLeft11:
    C                                           :HASHK(E+11)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 11)}     :HASHK(E+11)

hashBranchEnd11:
    HASHPOS                                     :HASHKLEN(E+11)
    $ => C                                      :HASHKDIGEST(E+11)


    ; BIT 12
    0 => HASHPOS
    ${B & 0x00001000}                           :JMPZ(hashLeft12)

hashRight12:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 12)}     :HASHK(E+12)
    C                                           :HASHK(E+12)
    A + 0x00001000 => A                         :JMP(hashBranchEnd12)

hashLeft12:
    C                                           :HASHK(E+12)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 12)}     :HASHK(E+12)

hashBranchEnd12:
    HASHPOS                                     :HASHKLEN(E+12)
    $ => C                                      :HASHKDIGEST(E+12)

    ; BIT 13
    0 => HASHPOS
    ${B & 0x00002000}                           :JMPZ(hashLeft13)

hashRight13:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 13)}     :HASHK(E+13)
    C                                           :HASHK(E+13)
    A + 0x00002000 => A                         :JMP(hashBranchEnd13)

hashLeft13:
    C                                           :HASHK(E+13)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 13)}     :HASHK(E+13)

hashBranchEnd13:
    HASHPOS                                     :HASHKLEN(E+13)
    $ => C                                      :HASHKDIGEST(E+13)

    ; BIT 14
    0 => HASHPOS
    ${B & 0x00004000}                           :JMPZ(hashLeft14)

hashRight14:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 14)}     :HASHK(E+14)
    C                                           :HASHK(E+14)
    A + 0x00004000 => A                         :JMP(hashBranchEnd14)

hashLeft14:
    C                                           :HASHK(E+14)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 14)}     :HASHK(E+14)

hashBranchEnd14:
    HASHPOS                                     :HASHKLEN(E+14)
    $ => C                                      :HASHKDIGEST(E+14)

    ; BIT 15
    0 => HASHPOS
    ${B & 0x00008000}                           :JMPZ(hashLeft15)

hashRight15:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 15)}     :HASHK(E+15)
    C                                           :HASHK(E+15)
    A + 0x00008000 => A                         :JMP(hashBranchEnd15)

hashLeft15:
    C                                           :HASHK(E+15)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 15)}     :HASHK(E+15)

hashBranchEnd15:
    HASHPOS                                     :HASHKLEN(E+15)
    $ => C                                      :HASHKDIGEST(E+15)

    ; BIT 16
    0 => HASHPOS
    ${B & 0x00010000}                           :JMPZ(hashLeft16)

hashRight16:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 16)}     :HASHK(E+16)
    C                                           :HASHK(E+16)
    A + 0x00010000 => A                         :JMP(hashBranchEnd16)

hashLeft16:
    C                                           :HASHK(E+16)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 16)}     :HASHK(E+16)

hashBranchEnd16:
    HASHPOS                                     :HASHKLEN(E+16)
    $ => C                                      :HASHKDIGEST(E+16)

    ; BIT 17
    0 => HASHPOS
    ${B & 0x00020000}                           :JMPZ(hashLeft17)

hashRight17:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 17)}     :HASHK(E+17)
    C                                           :HASHK(E+17)
    A + 0x00020000 => A                         :JMP(hashBranchEnd17)

hashLeft17:
    C                                           :HASHK(E+17)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 17)}     :HASHK(E+17)

hashBranchEnd17:
    HASHPOS                                     :HASHKLEN(E+17)
    $ => C                                      :HASHKDIGEST(E+17)

    ; BIT 18
    0 => HASHPOS
    ${B & 0x00040000}                           :JMPZ(hashLeft18)

hashRight18:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 18)}     :HASHK(E+18)
    C                                           :HASHK(E+18)
    A + 0x00040000 => A                         :JMP(hashBranchEnd18)

hashLeft18:
    C                                           :HASHK(E+18)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 18)}     :HASHK(E+18)

hashBranchEnd18:
    HASHPOS                                     :HASHKLEN(E+18)
    $ => C                                      :HASHKDIGEST(E+18)

    ; BIT 19
    0 => HASHPOS
    ${B & 0x00080000}                           :JMPZ(hashLeft19)

hashRight19:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 19)}     :HASHK(E+19)
    C                                           :HASHK(E+19)
    A + 0x00080000 => A                         :JMP(hashBranchEnd19)

hashLeft19:
    C                                           :HASHK(E+19)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 19)}     :HASHK(E+19)

hashBranchEnd19:
    HASHPOS                                     :HASHKLEN(E+19)
    $ => C                                      :HASHKDIGEST(E+19)

    ; BIT 20
    0 => HASHPOS
    ${B & 0x00100000}                           :JMPZ(hashLeft20)

hashRight20:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 20)}     :HASHK(E+20)
    C                                           :HASHK(E+20)
    A + 0x00100000 => A                         :JMP(hashBranchEnd20)

hashLeft20:
    C                                           :HASHK(E+20)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 20)}     :HASHK(E+20)

hashBranchEnd20:
    HASHPOS                                     :HASHKLEN(E+20)
    $ => C                                      :HASHKDIGEST(E+20)

    ; BIT 21
    0 => HASHPOS
    ${B & 0x00200000}                           :JMPZ(hashLeft21)

hashRight21:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 21)}     :HASHK(E+21)
    C                                           :HASHK(E+21)
    A + 0x00200000 => A                         :JMP(hashBranchEnd21)

hashLeft21:
    C                                           :HASHK(E+21)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 21)}     :HASHK(E+21)

hashBranchEnd21:
    HASHPOS                                     :HASHKLEN(E+21)
    $ => C                                      :HASHKDIGEST(E+21)

    ; BIT 22
    0 => HASHPOS
    ${B & 0x00400000}                           :JMPZ(hashLeft22)

hashRight22:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 22)}     :HASHK(E+22)
    C                                           :HASHK(E+22)
    A + 0x00400000 => A                         :JMP(hashBranchEnd22)

hashLeft22:
    C                                           :HASHK(E+22)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 22)}     :HASHK(E+22)

hashBranchEnd22:
    HASHPOS                                     :HASHKLEN(E+22)
    $ => C                                      :HASHKDIGEST(E+22)

    ; BIT 23
    0 => HASHPOS
    ${B & 0x00800000}                           :JMPZ(hashLeft23)

hashRight23:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 23)}     :HASHK(E+23)
    C                                           :HASHK(E+23)
    A + 0x00800000 => A                         :JMP(hashBranchEnd23)

hashLeft23:
    C                                           :HASHK(E+23)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 23)}     :HASHK(E+23)

hashBranchEnd23:
    HASHPOS                                     :HASHKLEN(E+23)
    $ => C                                      :HASHKDIGEST(E+23)

    ; BIT 24
    0 => HASHPOS
    ${B & 0x01000000}                           :JMPZ(hashLeft24)

hashRight24:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 24)}     :HASHK(E+24)
    C                                           :HASHK(E+24)
    A + 0x01000000 => A                         :JMP(hashBranchEnd24)

hashLeft24:
    C                                           :HASHK(E+24)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 24)}     :HASHK(E+24)

hashBranchEnd24:
    HASHPOS                                     :HASHKLEN(E+24)
    $ => C                                      :HASHKDIGEST(E+24)

    ; BIT 25
    0 => HASHPOS
    ${B & 0x02000000}                           :JMPZ(hashLeft25)

hashRight25:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 25)}     :HASHK(E+25)
    C                                           :HASHK(E+25)
    A + 0x02000000 => A                         :JMP(hashBranchEnd25)

hashLeft25:
    C                                           :HASHK(E+25)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 25)}     :HASHK(E+25)

hashBranchEnd25:
    HASHPOS                                     :HASHKLEN(E+25)
    $ => C                                      :HASHKDIGEST(E+25)

    ; BIT 26
    0 => HASHPOS
    ${B & 0x04000000}                           :JMPZ(hashLeft26)

hashRight26:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 26)}     :HASHK(E+26)
    C                                           :HASHK(E+26)
    A + 0x04000000 => A                         :JMP(hashBranchEnd26)

hashLeft26:
    C                                           :HASHK(E+26)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 26)}     :HASHK(E+26)

hashBranchEnd26:
    HASHPOS                                     :HASHKLEN(E+26)
    $ => C                                      :HASHKDIGEST(E+26)

    ; BIT 27
    0 => HASHPOS
    ${B & 0x08000000}                           :JMPZ(hashLeft27)

hashRight27:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 27)}     :HASHK(E+27)
    C                                           :HASHK(E+27)
    A + 0x08000000 => A                         :JMP(hashBranchEnd27)

hashLeft27:
    C                                           :HASHK(E+27)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 27)}     :HASHK(E+27)

hashBranchEnd27:
    HASHPOS                                     :HASHKLEN(E+27)
    $ => C                                      :HASHKDIGEST(E+27)

    ; BIT 28
    0 => HASHPOS
    ${B & 0x10000000}                           :JMPZ(hashLeft28)

hashRight28:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 28)}     :HASHK(E+28)
    C                                           :HASHK(E+28)
    A + 0x10000000 => A                         :JMP(hashBranchEnd28)

hashLeft28:
    C                                           :HASHK(E+28)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 28)}     :HASHK(E+28)

hashBranchEnd28:
    HASHPOS                                     :HASHKLEN(E+28)
    $ => C                                      :HASHKDIGEST(E+28)

    ; BIT 29
    0 => HASHPOS
    ${B & 0x20000000}                           :JMPZ(hashLeft29)

hashRight29:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 29)}     :HASHK(E+29)
    C                                           :HASHK(E+29)
    A + 0x20000000 => A                         :JMP(hashBranchEnd29)

hashLeft29:
    C                                           :HASHK(E+29)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 29)}     :HASHK(E+29)

hashBranchEnd29:
    HASHPOS                                     :HASHKLEN(E+29)
    $ => C                                      :HASHKDIGEST(E+29)

    ; BIT 30
    0 => HASHPOS
    ${B & 0x40000000}                           :JMPZ(hashLeft30)

hashRight30:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 30)}     :HASHK(E+30)
    C                                           :HASHK(E+30)
    A + 0x40000000 => A                         :JMP(hashBranchEnd30)

hashLeft30:
    C                                           :HASHK(E+30)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 30)}     :HASHK(E+30)

hashBranchEnd30:
    HASHPOS                                     :HASHKLEN(E+30)
    $ => C                                      :HASHKDIGEST(E+30)

    ; BIT 31
    0 => HASHPOS
    ${B & 0x80000000}                           :JMPZ(hashLeft31)

hashRight31:
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 31)}     :HASHK(E+31)
    C                                           :HASHK(E+31)
    A + 0x80000000 => A                         :JMP(hashBranchEnd31)

hashLeft31:
    C                                           :HASHK(E+31)
    ${getSmtProofPreviousIndex(mem.indexL1InfoTree, 31)}     :HASHK(E+31)

hashBranchEnd31:
    HASHPOS                                     :HASHKLEN(E+31)
    ; Merkle root at C
    $ => C                                      :HASHKDIGEST(E+31)

    ; verify linear combination of 'indexL1InfoTree'
    B                                           :ASSERT
    E + 32 => E                                 :MSTORE(nextHashKId)

computeMerkleProofReturn:
    $ => RR                                     :MLOAD(tmpZkPCComputeMerkleProof)
                                                :RETURN

VAR GLOBAL readXFromCalldataOffset
VAR GLOBAL readXFromCalldataLength
VAR GLOBAL readXFromCalldataResult
; @info Reads {readXFromCalldataOffset} bytes (max 32) from a given offset in calldata memory. If offset or offset + length exceeds txCalldataLen, zeros are added
; @internalParam {readXFromCalldataOffset} offset to read from calldata
; @internalParam {readXFromCalldataLength} length to read from calldata
; @returns {readXFromCalldataResult} bytes read from calldata
readFromCalldataOffset:
    %MAX_CNT_STEPS - STEP - 100       :JMPN(outOfCountersStep)
    A               :SAVE(B,C,D,E,RCX,RR)
    $ => A          :MLOAD(txCalldataLen), JMPZ(return0FromCalldata)
    $ => B          :MLOAD(calldataOffset)
    $ => C          :MLOAD(readXFromCalldataLength)
    $ => E          :MLOAD(readXFromCalldataOffset)
    A - E - 1       :JMPN(return0FromCalldata) ; If offset >= txCalldataLen, return 0
    ; if readOffset + readLength > txCalldataLen, readLength = txCalldataLen - readOffset
    E + C - A       :JMPN(dontLimitLength)
    A - E => C

dontLimitLength:
    $ => CTX        :MLOAD(calldataCTX) ; get calldata context
    B + E => E      :CALL(MLOADX); in: [E: offset, C: length] out: [A: value, E: new offset]
    $ => CTX        :MLOAD(currentCTX)
    A               :MSTORE(readXFromCalldataResult), JMP(readFromCalldataOffsetEnd)

return0FromCalldata:
    0               :MSTORE(readXFromCalldataResult)

readFromCalldataOffsetEnd:
    $ => A          :RESTORE, RETURN

; @info store calldata pointer to read calldata
saveCalldataPointer:
    %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)
    ; load data: previous CTX & argsOffsetCall
    $ => A, CTX         :MLOAD(originCTX)
    $ => B              :MLOAD(argsOffsetCall)
    ; move to current CTX and store data
    $ => CTX            :MLOAD(currentCTX)
    A                   :MSTORE(calldataCTX)
    B                   :MSTORE(calldataOffset), RETURN