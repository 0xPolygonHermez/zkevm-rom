; @info Get absolute value and sign
; @in A => number to convert
; @out A => Absolut value of A
; @out B => Sign of A [1 if negative, 0 positive]
abs:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 20       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    0 => B
    ; if is negative, change sign
    $ => B          :SLT, JMPC(absIsNeg)
                    :RETURN

absIsNeg:
    A => B
    0 => A
    ; 0 - (-A) = A
    $ => A          :SUB
    1 => B          :RETURN

VAR GLOBAL tmpZkPCcopy
; @info copy calldata from previous context to current context
; @in argsOffsetCall: offset to copy from te calldata
; @in argsLengthCall: length to copy from the calldata
copySP:
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    RR              :MSTORE(tmpZkPCcopy)
    ; store current ctx
    CTX             :MSTORE(currentCTX)
    ; set SP at the begginning of calldata memory allocation
    %CALLDATA_OFFSET => SP
    ; retrieve previous context
    $ => CTX        :MLOAD(originCTX)
    $ => E          :MLOAD(argsOffsetCall)
    $ => C          :MLOAD(argsLengthCall)

copySPloop:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)
    C               :JMPZ(copySPEnd)
    C - 32          :JMPN(copySPFinal)
    ; load 32 bytes from previous context
    zkPC+1 => RR    :JMP(MLOAD32); in: [E: offset] out: [A: value, E: new offset]
    ; restore current context
    $ => CTX        :MLOAD(currentCTX)
    ; insert 32 bytes from previous context's calldata to current context's calldata
    A               :MSTORE(SP++)
    ; load previous context for next iteration
    $ => CTX        :MLOAD(originCTX)
    C - 32 => C     :JMP(copySPloop)

copySPFinal:
    ; update RR to call a function from a call and load X bytes from previous context
    zkPC+1 => RR    :JMP(MLOADX); in: [E: offset, C: length] out: [A: value, E: new offset]
    ; restore current context
    $ => CTX        :MLOAD(currentCTX)
    ; insert X bytes from previous context's calldata to current context's calldata
    A               :MSTORE(SP++)
    ; load previous context
    $ => CTX        :MLOAD(originCTX)

copySPEnd:
    ; restore RR to return to initial call correctly
    $ => RR         :MLOAD(tmpZkPCcopy)
    $ => CTX        :MLOAD(currentCTX), RETURN

VAR GLOBAL tmpVarBgetLen
VAR GLOBAL tmpVarCgetLen
VAR GLOBAL tmpVarDgetLen
VAR GLOBAL tmpZkPCgetLen
; @info byte length of B
; @in B => number
; @out A => bytes length
getLenBytes:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    ; store current registries
    RR              :MSTORE(tmpZkPCgetLen)
    B               :MSTORE(tmpVarBgetLen)
    C               :MSTORE(tmpVarCgetLen)
    D               :MSTORE(tmpVarDgetLen)
    ; set C as counter to 0
    0 => C
    B => A

getLenBytesLoop:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)

    0 => B
    ; if A is zero, finish counter
    $               :EQ,JMPC(getLenEnd)
    ; right shift one byte
    1 => D
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    ; increase counter
    C + 1 => C      :JMP(getLenBytesLoop)

getLenEnd:
    ; counter to A
    C => A
    ; recover registries
    $ => B          :MLOAD(tmpVarBgetLen)
    $ => C          :MLOAD(tmpVarCgetLen)
    $ => RR         :MLOAD(tmpZkPCgetLen)
    $ => D          :MLOAD(tmpVarDgetLen), RETURN

; @info bits length of B
; @in B => number
; @out A => bits length
getLenBits:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    ; store current registries
    RR              :MSTORE(tmpZkPCgetLen)
    B               :MSTORE(tmpVarBgetLen)
    C               :MSTORE(tmpVarCgetLen)
    D               :MSTORE(tmpVarDgetLen)
    ; set C as counter to 0
    0 => C
    B => A

getLenBitsLoop:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    0 => B
    ; if B is zero, finish counter
    $               :EQ,JMPC(getLenBitsEnd)
    ; divide value by 2
    A               :MSTORE(arithA)
    2               :MSTORE(arithB)
    zkPC+1 => RR    :JMP(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A          :MLOAD(arithRes1)
    ; increase counter
    C + 1 => C      :JMP(getLenBitsLoop)

getLenBitsEnd:
    ; counter to A
    C => A
    ; recover registries
    $ => B          :MLOAD(tmpVarBgetLen)
    $ => C          :MLOAD(tmpVarCgetLen)
    $ => RR         :MLOAD(tmpZkPCgetLen)
    $ => D          :MLOAD(tmpVarDgetLen), RETURN

VAR GLOBAL tmpVarAmstore
VAR GLOBAL tmpVarBmstore
VAR GLOBAL tmpVarCmstore
VAR GLOBAL tmpVarDmstore
VAR GLOBAL tmpVarEmstore
VAR GLOBAL tmpZkPCmstore

VAR GLOBAL bytesToStore
VAR GLOBAL isMSTOREX
; @info save value to memory < 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @in C => length
; @out E => new offset
MSTOREX:
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    C               :JMPZ(endMSTOREX)
    32 - C          :JMPN(errorMLOADMSTORE)
    32 - C - 1      :JMPN(MSTORE32); in: [bytesToStore, E: offset] out: [E: new offset]
    1               :MSTORE(isMSTOREX)

; @info save value to memory 32 bytes with offset
; @in bytesToStore => bytes to store in memory
; @in E => offset
; @out E => new offset
MSTORE32:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 50 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1   :JMPN(outOfCountersMemalign)
    ; store current registries
    RR              :MSTORE(tmpZkPCmstore)
    A               :MSTORE(tmpVarAmstore)
    B               :MSTORE(tmpVarBmstore)
    C               :MSTORE(tmpVarCmstore)
    D               :MSTORE(tmpVarDmstore)
    ; check offset is lower than max memory
    E => A
    %MAX_MEM_EXPANSION_BYTES => B
    $               :LT,JMPC(initMSTORE, errorMLOADMSTORE)

initMSTORE:
    zkPC+1 => RR    :JMP(offsetUtil); in: [A: offset] out: [E: offset/32, C: offset%32]
    ; is storing <32 bytes, jump to store last bytes or finish if 0 bytes left
    $ => B          :MLOAD(isMSTOREX), JMPZ(finalMSTORE)
    ; if C has value, offset != 0
    C               :JMPNZ(MSTOREX2)
    $ => C          :MLOAD(tmpVarCmstore)
    ; load bytes to store
    $ => A          :MLOAD(bytesToStore)
    32 - C => D
    ; shift bytes to store
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    A => B
    ; load from memoty
    $ => A          :MLOAD(MEM:E)
    32 - D => D
    ; shift loaded bytes
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    A + B           :MSTORE(bytesToStore)
    A + B => A
    0 => C
    0               :MSTORE(isMSTOREX), JMP(finalMSTORE)

; used if bytesToStore.length < 32 && offset != 0
MSTOREX2:
    $ => D          :MLOAD(tmpVarCmstore)
    C + D => D
    32 - D          :JMPN(MSTOREX3)
    ; if bytesToStore.length < 32 && memory to load is allocated in two different slots
    ; load memory from slot E
    $ => A          :MLOAD(MEM:E)
    ; shift loaded memory from slot E
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    $ => D          :MLOAD(tmpVarCmstore)
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    A => B
    ; load memory from slot E+1
    $ => A          :MLOAD(MEM:E+1)
    32 - C => D
    ; right shift loaded memory from slot E+1
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    ; join both results
    A + B => B
    $ => A          :MLOAD(bytesToStore)
    $ => D          :MLOAD(tmpVarCmstore)
    32 - D => D
    ; shift bytes to store
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    ; append loaded bytes from concurrent slots
    A + B => A      :MSTORE(bytesToStore)
                    :JMP(finalMSTORE)

; used if bytesToStore.length < 32 && memory to load is allocated in one slot
MSTOREX3:
    D - 32 => D
    ; load memory from slot E+1
    $ => A          :MLOAD(MEM:E+1)
    ; shift bytes to store
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    $ => D          :MLOAD(tmpVarCmstore)
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    ; join both results
    A => B
    $ => A          :MLOAD(bytesToStore)
    $ => D          :MLOAD(tmpVarCmstore)
    32 - D => D
    ; shift bytes to store
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    ; append loaded bytes from concurrent slots
    A + B => A      :MSTORE(bytesToStore)

finalMSTORE:
    C               :JMPNZ(memAlignOptionMSTORE)
    $ => A          :MLOAD(bytesToStore)
    A               :MSTORE(MEM:E)
    E*32 => E       :JMP(offsetMSTORE32)

memAlignOptionMSTORE:
    E               :MSTORE(tmpVarEmstore)

    $ => A          :MLOAD(MEM:E)
    $ => B          :MLOAD(MEM:E+1)

    ${memAlignWR_W0(A,mem.bytesToStore,C)} => D                    ; no trust calculate W0
    ${memAlignWR_W1(B,mem.bytesToStore,C)} => E                    ; no trust calculate W1
    $               :MEM_ALIGN_WR,MLOAD(bytesToStore)
    E => A
    $ => E          :MLOAD(tmpVarEmstore)
    D               :MSTORE(MEM:E)          ; write W0
    A               :MSTORE(MEM:E+1)        ; write W1
    E*32 + C => E
    $ => A          :MLOAD(isMSTOREX), JMPZ(offsetMSTORE32)
    $ => C          :MLOAD(tmpVarCmstore)
    E*32 + C => E
    0               :MSTORE(isMSTOREX), JMP(endMSTORE)

offsetMSTORE32:
    E + 32 => E

endMSTORE:
    $ => A          :MLOAD(tmpVarAmstore)
    $ => B          :MLOAD(tmpVarBmstore)
    $ => C          :MLOAD(tmpVarCmstore)
    $ => RR         :MLOAD(tmpZkPCmstore)
    $ => D          :MLOAD(tmpVarDmstore), RETURN
endMSTOREX:
                    :RETURN

VAR GLOBAL tmpVarAmload
VAR GLOBAL tmpVarBmload
VAR GLOBAL tmpVarCmload
VAR GLOBAL tmpVarDmload
VAR GLOBAL tmpVarEmload
VAR GLOBAL tmpZkPCmload

VAR GLOBAL isMLOADX
; @info get value from memory (< 32 bytes)
; @in E => offset
; @in C => length
; @out A => value
; @out E => new offset
MLOADX:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1   :JMPN(outOfCountersMemalign)

    32 - C          :JMPN(errorMLOADMSTORE) ; TDDO Should be unreachable! check it
    32 - C - 1      :JMPN(MLOAD32)
    1               :MSTORE(isMLOADX)

; @info get value from memory (32 bytes)
; @in E => offset
; @out A => value
; @out E => new offset
MLOAD32:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_MEM_ALIGN - CNT_MEM_ALIGN - 1   :JMPN(outOfCountersMemalign)
    ; store current registries
    RR              :MSTORE(tmpZkPCmload)
    B               :MSTORE(tmpVarBmload)
    C               :MSTORE(tmpVarCmload)
    D               :MSTORE(tmpVarDmload)
    ; check offset is lower than max memory
    E => A
    %MAX_MEM_EXPANSION_BYTES => B
    $               :LT,JMPC(initMLOAD, errorMLOADMSTORE)

initMLOAD:
                    :CALL(offsetUtil); in: [A: offset] out: [E: offset/32, C: offset%32]
    ; if C has value, bytes splitted in two memory slots
    C               :JMPNZ(memAlignOptionMLOAD)
    ; load memory from one slot
    $ => A          :MLOAD(MEM:E)
    $ => B          :MLOAD(isMLOADX)
    E*32 => E
    B               :JMPZ(offsetMLOAD32, sliceA)

memAlignOptionMLOAD:
    $ => A          :MLOAD(MEM:E)
    $ => B          :MLOAD(MEM:E+1)
    ; get memeory value
    $ => A          :MEM_ALIGN_RD
    E*32 + C => E
    $ => B          :MLOAD(isMLOADX)
    B               :JMPZ(offsetMLOAD32)

sliceA:
    ; if is mloadx, slice the result by the length
    $ => C          :MLOAD(tmpVarCmload)
    32 - C => D
    zkPC+1 => RR    :JMP(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    zkPC+1 => RR    :JMP(SHLarith); in: [A: value, D: #bytes to left shift] out: [A: shifted result]
    0               :MSTORE(isMLOADX)
    E + C => E      :JMP(endMLOAD)

offsetMLOAD32:
    E + 32 => E

endMLOAD:
    ; restore stored values
    $ => B          :MLOAD(tmpVarBmload)
    $ => C          :MLOAD(tmpVarCmload)
    $ => RR         :MLOAD(tmpZkPCmload)
    $ => D          :MLOAD(tmpVarDmload), RETURN

errorMLOADMSTORE:
                    :JMP(outOfGas)

VAR GLOBAL tmpVarAemptyAcc
VAR GLOBAL tmpVarBemptyAcc
VAR GLOBAL tmpVarCemptyAcc
VAR GLOBAL tmpVarDemptyAcc

; @info check account is empty ( balance == nonce == code == 0x )
; @in E => address
; @out E => isEmpty => 1 = true, 0 = false
isEmptyAccount:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255*3 :JMPN(outOfCountersPoseidon)

    ; store current registries
    A                           :MSTORE(tmpVarAemptyAcc)
    B                           :MSTORE(tmpVarBemptyAcc)
    C                           :MSTORE(tmpVarCemptyAcc)
    D                           :MSTORE(tmpVarDemptyAcc)

    E => A
    ; read balance
    ; set key for smt balance query.
    %SMT_KEY_BALANCE => B
    0 => C
    $ => B                      :SLOAD
    ; balance in A
    0 => A
    ; if balance is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    ; check nonce
    E => A
    ; set key for smt nonce query
    %SMT_KEY_NONCE => B
    ; nonce in B
    $ => B                      :SLOAD
    0 => A
    ; if nonce is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    ; read bytecode
    E => A
    ; set key for smt smart contract query
    %SMT_KEY_SC_CODE => B
    ; sc in B
    $ => B                      :SLOAD
    0 => A
    ; if code is not zero, is not empty
    $                           :LT,JMPC(isNotEmptyAccount)
    1 => E                      :JMP(ISEMPTYEnd)

isNotEmptyAccount:
    0 => E                      :JMP(ISEMPTYEnd)

ISEMPTYEnd:
    ; recover registries
    $ => A                      :MLOAD(tmpVarAemptyAcc)
    $ => B                      :MLOAD(tmpVarBemptyAcc)
    $ => C                      :MLOAD(tmpVarCemptyAcc)
    $ => D                      :MLOAD(tmpVarDemptyAcc), RETURN

VAR GLOBAL tmpVarBcompGas
VAR GLOBAL tmpVarCcompGas
VAR GLOBAL tmpVarDcompGas
VAR GLOBAL tmpVarEcompGas

; @info Compute gas to send to call following EIP 150
; @in gasCall: gas sent to call
; @out A => min( requested_gas , all_but_one_64th(63/64) )
computeGasSendCall:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 30       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    ; save tmp vars
    B                       :MSTORE(tmpVarBcompGas)
    C                       :MSTORE(tmpVarCcompGas)
    D                       :MSTORE(tmpVarDcompGas)
    E                       :MSTORE(tmpVarEcompGas)

    ; compute all_but_one_64th gas
    GAS => A

    ; C = [c7, c6, ..., c0]
    ; JMPN instruction assures c0 is within the range [0, 2**32 - 1]
    ${GAS >> 6} => C        :JMPN(failAssert)
    ${GAS & 0x3f} => D

    ; since D is assured to be less than 0x40
    ; it is enforced that [c7, c6, ..., c1] are 0 since there is no value multiplied by 64
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, c0 * 64 + d0 could not overflow the field
    C * 64 + D              :ASSERT
    D => A
    0x40 => B
    $                       :LT,JMPNC(failAssert)
    GAS - C => A
    $ => B                  :MLOAD(gasCall)
    ; gas_sent_with_call = min(requested_gas, all_but_one_64th)
    $                       :LT,JMPC(computeGasSendCallEnd)
    ; gas to substract
    B => A

computeGasSendCallEnd:
    ; restore stored values
    $ => B                  :MLOAD(tmpVarBcompGas)
    $ => C                  :MLOAD(tmpVarCcompGas)
    $ => D                  :MLOAD(tmpVarDcompGas)
    $ => E                  :MLOAD(tmpVarEcompGas), RETURN

VAR GLOBAL tmpVarAsaveMem
VAR GLOBAL tmpVarBsaveMem
VAR GLOBAL tmpVarCsaveMem
VAR GLOBAL tmpVarDsaveMem
VAR GLOBAL tmpVarEsaveMem
VAR GLOBAL tmpZkPCsaveMem
; @info compute memory expansion gas cost
; @in: lastMemOffset: offset to copy bytes
; @in: lastMemLength: size of the bytes to copy
saveMem:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 5 :JMPN(outOfCountersBinary)
    RR                          :MSTORE(tmpZkPCsaveMem)
    A                           :MSTORE(tmpVarAsaveMem)
    B                           :MSTORE(tmpVarBsaveMem)
    C                           :MSTORE(tmpVarCsaveMem)
    D                           :MSTORE(tmpVarDsaveMem)
    E                           :MSTORE(tmpVarEsaveMem)
    $ => A                      :MLOAD(lastMemLength)
    ; If no len, no memory expansion
    0 => B
    $                           :EQ, JMPC(saveMemEnd)
    $ => B                      :MLOAD(lastMemOffset)
    ; If the binary has a carry, means the mem expansion is very big. We can jump to oog directly
    ; offset + length in B
    $ => B                      :ADD, JMPC(outOfGas)
    ; check new memory length is lower than 2**22 - 31 - 1 (max supported memory expansion for %TX_GAS_LIMIT of gas)
    %MAX_MEM_EXPANSION_BYTES => A
    $                           :LT,JMPC(outOfGas)


    ; load old memory length, if is greater than new memory length, no expansion cost
    $ => A                      :MLOAD(memLength)
    $                           :LT, JMPC(saveMemGAS, saveMemEnd)

saveMemGAS:
    ; store new memory length
    B                           :MSTORE(memLength)
    B => E
    ; memory_size_word = (memory_byte_size + 31) / 32 in E
    ; ${(B+31)/32} => E
    E + 31 => A

    ; E = [e7, e6, ..., e0]
    ; JMPN instruction assures e0 is within the range [0, 2**32 - 1]
    ${A >> 5} => E              :JMPN(failAssert)
    ${A & 0x1f} => D

    ; since D is assured to be less than 0x20
    ; it is enforced that [e7, e6, ..., e1] are 0 since there is no value multiplied by 32
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, e0 * 32 + d0 could not overflow the field
    E * 32 + D                  :ASSERT
    D => A
    0x20 => B
    $                           :LT,JMPNC(failAssert)
    ; memory_cost = (memory_size_word ** 2) / 512 + (3 * memory_size_word) in A
    ; ${E*E/512} + 3*E=> A
    E                           :MSTORE(arithA)
    E                           :MSTORE(arithB), CALL(mulARITH); in: [arithA, arithB] out: [arithRes1: arithA*arithB, arithOverflow: set to 1 if operation causes overflow]
    $ => C                      :MLOAD(arithRes1)
    $                           :MLOAD(arithOverflow), JMPNZ(outOfGas)
    C                           :MSTORE(arithA)
    512                         :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A                      :MLOAD(arithRes1)
    A + 3*E => A
    $ => B                      :MLOAD(lastMemoryExpansionCost)
    A                           :MSTORE(lastMemoryExpansionCost)
    ; memory_expansion_cost = new_memory_cost - last_memory_cost
    A - B => A
    ; update new gas
    GAS - A => GAS               :JMPN(outOfGas)

saveMemEnd:
    ; restore stored values
    $ => A                      :MLOAD(tmpVarAsaveMem)
    $ => B                      :MLOAD(tmpVarBsaveMem)
    $ => C                      :MLOAD(tmpVarCsaveMem)
    $ => D                      :MLOAD(tmpVarDsaveMem)
    $ => RR                     :MLOAD(tmpZkPCsaveMem)
    $ => E                      :MLOAD(tmpVarEsaveMem), RETURN

VAR GLOBAL tmpVarAArith
VAR GLOBAL tmpVarBArith
VAR GLOBAL tmpVarCArith
VAR GLOBAL tmpVarDArith
VAR GLOBAL tmpVarEArith
VAR GLOBAL tmpZkPCArith
VAR GLOBAL arithA
VAR GLOBAL arithB
VAR GLOBAL arithRes1
VAR GLOBAL arithRes2
VAR GLOBAL arithOverflow

; @info binary addition
; @in: arithA: addend value
; @in: arithB: addend value
; @out: arithRes1: arithA + arithB
addARITH:

    RR              :MSTORE(tmpZkPCArith), CALL(storeTmp)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => E          :ADD, MSTORE(arithRes1)

    $ => RR         :MLOAD(tmpZkPCArith), JMP(loadTmp)

; @info binary substraction
; @in: arithA: minuend value
; @in: arithB: subtrahend value
; @out: arithRes1: arithA - arithB
subARITH:

    RR              :MSTORE(tmpZkPCArith),CALL(storeTmp)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    $ => A          :SUB,MSTORE(arithRes1)
    $ => RR         :MLOAD(tmpZkPCArith),JMP(loadTmp)

; @info arithmetic multiplication
; @in: arithA: multiplier value
; @in: arithB: multiplicand value
; @out: arithRes1: product of multiplication arithA * arithB
; @out: arithOverflow: set to 1 if operation causes overflow
mulARITH:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)

    RR              :MSTORE(tmpZkPCArith), CALL(storeTmp)
    $ => A          :MLOAD(arithA)
    $ => B          :MLOAD(arithB)
    0 => C
    $${var _mulArith = A * B}
    ${_mulArith >> 256} => D
    ${_mulArith} => E :ARITH

    E               :MSTORE(arithRes1)
    D               :MSTORE(arithOverflow), CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

; @info arithmetic division
; @in: arithA: dividend value
; @in: arithB: divisor value
; @out: arithRes1: quotien of division arithA / arithB
; @out: arithRes2: remainder of division arithA % arithB
divARITH:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)

    RR              :MSTORE(tmpZkPCArith), CALL(storeTmp)
    $ => E          :MLOAD(arithA)
    $ => A          :MLOAD(arithB)
    ; Check denominator(A) is not zero
    0 => B
    $               :EQ, JMPC(zeroDiv)

    ; Check if divisor (E) is smaller than denominator E < A
    A => C ; store temporally A in C
    E => A ; divisor
    C => B ; denominator
    $               :LT, JMPC(divisorSmallerDiv)
    C => A

    ${E%A} => C ; reminder
    ${E/A} => B
    0 => D
    E               :ARITH

    B               :MSTORE(arithRes1)
    C               :MSTORE(arithRes2)

    ; check divisor > reminder
    A => B ; divisor
    C => A ; reminder
    $ => A          :LT
    1               :ASSERT,CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

zeroDiv:
    0               :MSTORE(arithRes1)
    0               :MSTORE(arithRes2), CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

divisorSmallerDiv:
    0               :MSTORE(arithRes1)
    E               :MSTORE(arithRes2), CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

loadTmp:
    $ => A                  :MLOAD(tmpVarAArith)
    $ => B                  :MLOAD(tmpVarBArith)
    $ => C                  :MLOAD(tmpVarCArith)
    $ => D                  :MLOAD(tmpVarDArith)
    $ => E                  :MLOAD(tmpVarEArith), RETURN

storeTmp:
    A                   :MSTORE(tmpVarAArith)
    B                   :MSTORE(tmpVarBArith)
    C                   :MSTORE(tmpVarCArith)
    D                   :MSTORE(tmpVarDArith)
    E                   :MSTORE(tmpVarEArith), RETURN

VAR GLOBAL tmpSHXZkPC
VAR GLOBAL tmpSHXZkPC2

VAR GLOBAL tmpVarBSHX
VAR GLOBAL tmpVarCSHX
VAR GLOBAL tmpVarDSHX
VAR GLOBAL tmpVarESHX

VAR GLOBAL result
;@info Shift right D bytes to A
;@in A - (A >> D)
;@in D - (A >> D) D bytes
;@out A - A >> D => A
SHRarith:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)

    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarBSHX)
    C                       :MSTORE(tmpVarCSHX)
    D                       :MSTORE(tmpVarDSHX)
    E                       :MSTORE(tmpVarESHX)
    ; E init number
    A => E
    ; A bytes
    D => A
    ; B = 8 (1 byte = 8 bits)
    8 => B
    0 => C
    0 => D
    ; A * B = op --> D = op (D bits)
    ${A*B} => D             :ARITH
    ; A init number
    E => A                  :JMP(SHRarithinit)

;@in A - (A >> D)
;@in D - (A >> D) D bits
;@out A -  A >> D => A
SHRarithBit:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 30       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarBSHX)
    C                       :MSTORE(tmpVarCSHX)
    D                       :MSTORE(tmpVarDSHX)
    E                       :MSTORE(tmpVarESHX)

SHRarithinit:
    0 => B
    ; if A == 0 --> no shift
    $                       :EQ,JMPC(SHRarithfinal)
    ; E init number
    A => E
    ; B bits
    D => B
    255 => A
    ; A < B, 255 < bits
    $                       :LT,JMPC(SHRarith0)
    D => RR
    E => A                  :MSTORE(arithA)
                            :CALL(@exp_num + RR); out:[B: 2**RR]
    B                       :MSTORE(arithB),CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => A                  :MLOAD(arithRes1),JMP(SHRarithfinal)

SHRarith0:
    0 => A

SHRarithfinal:
    $ => B                  :MLOAD(tmpVarBSHX)
    $ => C                  :MLOAD(tmpVarCSHX)
    $ => D                  :MLOAD(tmpVarDSHX)
    $ => RR                 :MLOAD(tmpSHXZkPC2)
    $ => E                  :MLOAD(tmpVarESHX), RETURN

;@info Shift left D bytes to A
;@in A - (A << D)
;@in D - (A << D) D bytes
;@out A -  A << D => A
SHLarith:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 2   :JMPN(outOfCountersArith)
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarBSHX)
    C                       :MSTORE(tmpVarCSHX)
    D                       :MSTORE(tmpVarDSHX)
    E                       :MSTORE(tmpVarESHX)
    ; E init number
    A => E
    ; A bytes
    D => A
    8 => B
    0 => C, D
    ; D = A * 8, D bits
    ${A*B} => D             :ARITH
    ; A init number
    E => A
                            :JMP(SHLarithinit)
SHLarithBit:
    ; check zk-counters
    %MAX_CNT_STEPS - STEP - 100       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 1   :JMPN(outOfCountersArith)
    RR                      :MSTORE(tmpSHXZkPC2)
    B                       :MSTORE(tmpVarBSHX)
    C                       :MSTORE(tmpVarCSHX)
    D                       :MSTORE(tmpVarDSHX)
    E                       :MSTORE(tmpVarESHX)

SHLarithinit:
    ; E init number
    A => E
    0 => A
    ; D --> B bits
    D => B
    ; if D == 0 --> no shift
    $                       :EQ,JMPC(SHLarithfinal)
    255 => A
     ; A < B, 255 < bits
    $                       :LT,JMPC(SHLarith0)

    D => RR
    ; A init number and calculate B = 2**D
    E => A                  :CALL(@exp_num + RR); out:[B: 2**RR]
    ; E = init number * 2**D (result)
    ${A*B} => E
    E                       :MSTORE(result)
    ; D = 256 - D
    256 - D => D, RR
    B => C                  :CALL(@exp_num + RR); out:[B: 2**RR]
    ${A/B} => D
    C => B
    0 => C
    E                       :ARITH, JMP(SHLarithfinal)

SHLarith0:
    0 => E
                            :JMP(SHLarithfinal)

SHLarithfinal:
    E => A
    $ => B                  :MLOAD(tmpVarBSHX)
    $ => C                  :MLOAD(tmpVarCSHX)
    $ => D                  :MLOAD(tmpVarDSHX)
    $ => RR                 :MLOAD(tmpSHXZkPC2)
    $ => E                  :MLOAD(tmpVarESHX), RETURN

; out of counters full tracer event trigger
outOfCountersStep:
    $${eventLog(onError, OOCS)} :JMP(handleBatchError)
outOfCountersKeccak:
    $${eventLog(onError, OOCK)} :JMP(handleBatchError)
outOfCountersBinary:
    $${eventLog(onError, OOCB)} :JMP(handleBatchError)
outOfCountersMemalign:
    $${eventLog(onError, OOCM)} :JMP(handleBatchError)
outOfCountersArith:
    $${eventLog(onError, OOCA)} :JMP(handleBatchError)
outOfCountersPadding:
    $${eventLog(onError, OOCPA)} :JMP(handleBatchError)
outOfCountersPoseidon:
    $${eventLog(onError, OOCPO)} :JMP(handleBatchError)
outOfGas:
    $${eventLog(onError, OOG)}   :JMP(handleError)
invalidJump:
    $${eventLog(onError, invalidJump)} :JMP(handleError)
invalidOpcode:
    $${eventLog(onError, invalidOpcode)} :JMP(handleError)
stackUnderflow:
    $${eventLog(onError, underflow)} :JMP(handleError)
stackOverflow:
    $${eventLog(onError, overflow)} :JMP(handleError)
deployAddressCollision:
    $${eventLog(onError, invalidAddressCollision)} :JMP(handleError)
invalidStaticTx:
    $${eventLog(onError, invalidStaticTx)} :JMP(handleError)
invalidCodeSize:
    $${eventLog(onError, invalidCodeSize)} :JMP(handleError)
invalidCodeStartsEF:
    $${eventLog(onError, invalidCodeStartsEF)} :JMP(handleError)

handleError:
    %MAX_CNT_STEPS - STEP - 500       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    ;revert all state changes
    $ => SR         :MLOAD(initSR), CALL(revertTouched)
    ;remaining gas = 0
    $ => A          :MLOAD(originCTX)
    0 => B
    $               :EQ,JMPC(firstContextInvalid)
    A => CTX
    ; Add return data context value to origin context
    ; Clear return data context
    0               :MSTORE(retDataCTX)
    CTX             :MSTORE(currentCTX)
    $ => GAS        :MLOAD(gasCTX)
    $ => SP         :MLOAD(lastSP)
    $ => PC         :MLOAD(lastPC)
    0               :MSTORE(SP++)
    $ => A          :MLOAD(depth)
    A - 1           :MSTORE(depth), JMP(readCode)

handleBatchError:
    ; restore init state root and finish batch
    $ => SR         :MLOAD(batchSR)
    $${eventLog(onFinishTx)}
    $${eventLog(onFinishBatch)} :JMP(processTxsEnd)

firstContextInvalid:
    ;save Root and jump to send gas to sequencer
    0               :MSTORE(gasRefund)
    0 => GAS        :JMP(sendGasSeq)

VAR GLOBAL tmpVarAoffsetUtil
VAR GLOBAL tmpVarBoffsetUtil
;Get offset/32 & offset%32
;@in A offset (offset is assumed to be less than %MAX_MEM_EXPANSION_BYTES)
;@out E offset/32
;@out C offset%32
offsetUtil:
    %MAX_CNT_STEPS - STEP - 20          :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1    :JMPN(outOfCountersBinary)
    A                                   :MSTORE(tmpVarAoffsetUtil)
    B                                   :MSTORE(tmpVarBoffsetUtil)

    ; E = [e7, e6, ..., e0]
    ; JMPN instruction assures e0 is within the range [0, 2**32 - 1]
    ${A >> 5} => E                      :JMPN(failAssert)
    ${A & 0x1F} => C

    ; since C is assured to be less than 0x20
    ; it is enforced that [e7, e6, ..., e1] are 0 since there is no value multiplied by 32
    ; that equals the field
    ; Since e0 is assured to be less than 32 bits, e0 * 32 + c0 could not overflow the field
    E * 32 + C                          :ASSERT
    C => A
    0x20 => B
    $                                   :LT,JMPNC(failAssert)

    $ => A                              :MLOAD(tmpVarAoffsetUtil)
    $ => B                              :MLOAD(tmpVarBoffsetUtil), RETURN

;@info: move balances between two accounts
;@in: txSrcAddr: source address
;@in: storageAddr: destination address
;@in: txValue: transaction value
moveBalances:
;;;;;;;;
; evmCALL (Move Balances)
;;;;;;;;
    %MAX_CNT_STEPS - STEP - 50       :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3 :JMPN(outOfCountersBinary)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255*4 :JMPN(outOfCountersPoseidon)
    ;Check if is a delegate call
    $ => A                          :MLOAD(isDelegateCall), JMPNZ(endMoveBalances)
    ; Decrement source balance
    $ => A                          :MLOAD(txSrcAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE => B
    0 => C
    ; Balance in A
    $ => A                          :SLOAD
    ; value in B
    $ => B                          :MLOAD(txValue)
    ; Check has enough balance to pay the value. In case not, means we are in a CALL/CALLCODE
    $                               :LT,JMPC(invalidCall)
    ; sourceBalance - value in D
    $ => D                          :SUB
    ; update source balance
    $ => A                          :MLOAD(txSrcAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE => B
    $ => SR                         :SSTORE
    ; Increment destination balance
    $ => A                          :MLOAD(storageAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE  => B
    ; Balance in A
    $ => A                          :SLOAD
    $ => B                          :MLOAD(txValue)
    $ => D                          :ADD
    $ => A                          :MLOAD(storageAddr)
    ; set key for smt balance query
    %SMT_KEY_BALANCE  => B
    0 => C
    $ => SR                         :SSTORE
endMoveBalances:
                                    :RETURN

invalidCall:
    ; return to origin context
    $ => SR                         :MLOAD(initSR)
    $ => A                          :MLOAD(originCTX)
    0 => B
    ; if last context, finish tx
    $                               :EQ,JMPC(handleGas)
    A => CTX
    0                               :MSTORE(retDataCTX)
    CTX                             :MSTORE(currentCTX)
    $ => A                          :MLOAD(gasCTX)
    GAS + A => GAS
    $ => SP                         :MLOAD(lastSP)
    $ => PC                         :MLOAD(lastPC)
    0                               :MSTORE(SP++)
    ; decrease depth
    $ => A                          :MLOAD(depth)
    A - 1                           :MSTORE(depth), JMP(readCode)

VAR GLOBAL pushBytes
VAR GLOBAL numBlocks
VAR GLOBAL leftBytes
VAR GLOBAL accumulator
; @info Read bytes opcode PUSHX
; @internalParam {numBlocks} 4 bytes blocks to read
; @internalParam {leftBytes} remaining bytes
; @in D => bytes to read
; @out E => value read
readPush:
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    D                           :MSTORE(pushBytes)
    D => A
    0                           :MSTORE(accumulator)
    PC + D - 1 => HASHPOS

    ; B = [b7, b6, ..., b0]
    ; JMPN instruction assures b0 is within the range [0, 2**32 - 1]
    ${A >> 2} => B              :JMPN(failAssert)
    B                           :MSTORE(numBlocks)
    ${A & 0x03} => D
    D                           :MSTORE(leftBytes)

    ; since D is assured to be less than 0x04
    ; it is enforced that [b7, b6, ..., b1] are 0 since there is no value multiplied by 4
    ; that equals the field
    ; Since b0 is assured to be less than 32 bits, b0 * 4 + d0 could not overflow the field
    B * 4 + D                   :ASSERT
    D => A
    0x04 => B
    $                           :LT,JMPNC(failAssert)
    0 => B                      :JMP(readPushBlock)

readPushBlock:
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    $ => A                      :MLOAD(numBlocks)
    $                           :EQ, JMPC(endPushInit)
    ; load hash contract identifier
    E                           :MLOAD(contractHashId)
    ; read bytes
    $ => C                      :HASHP1(E)
    HASHPOS - 2 => HASHPOS

    $ => A                      :HASHP1(E)
    HASHPOS - 2 => HASHPOS
    A*256 + C => C

    $ => A                      :HASHP1(E)
    HASHPOS - 2 => HASHPOS
    A*65536 + C => C

    $ => A                      :HASHP1(E)
    HASHPOS - 2 => HASHPOS
    A*16777216 + C => C         :JMP(doRotate)

doRotate:
    B - 1 => A                  :JMP(doRotateLoop)

doRotateLoop:
    %MAX_CNT_STEPS - STEP - 20  :JMPN(outOfCountersStep)
    A                           :JMPN(endRotate)
    ROTL_C => C
    A - 1 => A                  :JMP(doRotateLoop)

endRotate:
    $ => D                      :MLOAD(accumulator)
    C + D => D
    D                           :MSTORE(accumulator)
    B + 1 => B                  :JMP(readPushBlock)

endPushInit:
    $ => A                          :MLOAD(leftBytes), JMPZ(finalPush)
    0 => C
    0 => B                          :JMP(endPushLoop)

endPushLoop:
    %MAX_CNT_STEPS - STEP - 20 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 4 :JMPN(outOfCountersBinary)

    $ => A                          :MLOAD(leftBytes)
    $                               :EQ, JMPC(endPushFinal)

    $ => D                          :HASHP1(E)
    HASHPOS - 2 => HASHPOS
    B - 1 => A                      :JMP(computeFactorLoop)

computeFactorLoop:
    %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)
    A                               :JMPN(computeFactorEnd)
    256*D => D
    A - 1 => A                      :JMP(computeFactorLoop)

computeFactorEnd:
    B + 1 => B
    D + C => C                      :JMP(endPushLoop)

endPushFinal:
    $ => B                          :MLOAD(numBlocks), JMP(doRotate2)

doRotate2:
    B - 1 => A                      :JMP(doRotateLoop2)

doRotateLoop2:
    %MAX_CNT_STEPS - STEP - 10  :JMPN(outOfCountersStep)
    A                           :JMPN(endRotate2)
    ROTL_C => C
    A - 1 => A                  :JMP(doRotateLoop2)

endRotate2:
    $ => D                      :MLOAD(accumulator)
    C + D => D
    D                           :MSTORE(accumulator), JMP(finalPush)

finalPush:
    $ => E                      :MLOAD(accumulator)
    $ => D                      :MLOAD(pushBytes), RETURN

VAR GLOBAL tmpVarDaddB
VAR GLOBAL tmpZkPCaddB
VAR GLOBAL auxBytes
;@info: adds data to batchHashdata byte by byte
;@in: A: bytes to add
;@in D: bytes length
addBatchHashByteByByte:
        %MAX_CNT_STEPS - STEP - 10      :JMPN(handleOOCSatRLP)
        RR                              :MSTORE(tmpZkPCaddB)
        A                               :MSTORE(auxBytes)
        D                               :MSTORE(tmpVarDaddB)
        1 => D

utilsAddBatchHashBytebyByteLoop:
        %MAX_CNT_STEPS - STEP - 50 :JMPN(handleOOCSatRLP)
        %MAX_CNT_BINARY - CNT_BINARY - 1   :JMPN(handleOOCBatRLP)
        32 - D => D
        $ => A                          :MLOAD(auxBytes), CALL(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
        ; get last byte in A
        0xFFn => B
        $ => A                          :AND
        D => B
        ; add last byte to batchHashData
        1 => D                          :CALL(addBatchHashData); in:[D: length of the hash]
        ; check loop
        B => D
        ; D + 1 => D we set 33 in stead of 32 to earn 1 step
        33 - D => D
        $ => B                          :MLOAD(tmpVarDaddB)
        D - B - 1                       :JMPN(utilsAddBatchHashBytebyByteLoop)
        $ => RR                         :MLOAD(tmpZkPCaddB)
                                        :RETURN

VAR GLOBAL startsWithEF
VAR GLOBAL tmpVarAEF
VAR GLOBAL tmpVarBEF
VAR GLOBAL tmpVarCEF
VAR GLOBAL tmpVarDEF
VAR GLOBAL tmpVarEEF
VAR GLOBAL tmpZkPCEF
; @info check bytecode first byte != 0xEF as defined in EIP-3541 (https://eips.ethereum.org/EIPS/eip-3541)
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {startsWithEF} flag to indicate if first deployed byte on the bytecode is 0xEF
checkBytecodeStartsEF:
    %MAX_CNT_STEPS - STEP - 50 :JMPN(outOfCountersStep)
    ; save temporary registers
    A                               :MSTORE(tmpVarAEF)
    B                               :MSTORE(tmpVarBEF)
    C                               :MSTORE(tmpVarCEF)
    D                               :MSTORE(tmpVarDEF)
    E                               :MSTORE(tmpVarEEF)
    RR                              :MSTORE(tmpZkPCEF)

    ; load memOffset
    $ => E                          :MLOAD(memOffsetLinearPoseidon)

    ; get 1 byte from memory
    1 => C                          :CALL(MLOADX) ; in: [E: offset, C: lenght] out: [A: value , E: new offset]
    31 => D                         :CALL(SHRarith) ; in: [A: value, D: #bytes to right shift] out: [A: shifted result]

    ; check if byte read is equal to 0xEF
    %BYTECODE_STARTS_EF - A         :JMPNZ(checkBytecodeStartsEFend)
    1                               :MSTORE(startsWithEF)

checkBytecodeStartsEFend:
    ; set back tmp registers
    $ => RR         :MLOAD(tmpZkPCEF)
    $ => A          :MLOAD(tmpVarAEF)
    $ => B          :MLOAD(tmpVarBEF)
    $ => C          :MLOAD(tmpVarCEF)
    $ => D          :MLOAD(tmpVarDEF)
    $ => E          :MLOAD(tmpVarEEF), RETURN

VAR GLOBAL tmpVarAhashP
VAR GLOBAL tmpVarBhashP
VAR GLOBAL tmpVarChashP
VAR GLOBAL tmpVarEhashP
VAR GLOBAL tmpZkPChashP
VAR GLOBAL memOffsetLinearPoseidon
VAR GLOBAL memSizeLinearPoseidon
; @info Computes hash bytecode from memory bytes
; @internalParam {memOffset} memory offset to read bytes from
; @internalParam {memSize} memory size to read bytes from
; @out D => resulting linear poseidon
hashPoseidonLinearFromMemory:
    %MAX_CNT_STEPS - STEP - 50 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    A                               :MSTORE(tmpVarAhashP)
    B                               :MSTORE(tmpVarBhashP)
    C                               :MSTORE(tmpVarChashP)
    E                               :MSTORE(tmpVarEhashP)
    RR                              :MSTORE(tmpZkPChashP)
    $ => E                          :MLOAD(memOffsetLinearPoseidon)
    $ => C                          :MLOAD(memSizeLinearPoseidon)
    0 => D
    C                               :JMPZ(hashPoseidonReturn)
    ; check poseidon counters
    ; 56 is the value used by the prover to increment poseidon counters depending on the hash length
    C                                                       :MSTORE(arithA)
    56                                                      :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    $ => B                                                  :MLOAD(arithRes1)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 1 - B            :JMPN(outOfCountersPoseidon)
    %MAX_CNT_PADDING_PG_LIMIT - CNT_PADDING_PG - 1 - B      :JMPN(outOfCountersPadding)

    ; get a new hashPId
    $ => B                          :MLOAD(nextHashPId)
    B                               :MSTORE(tmpContractHashId)
    B + 1                           :MSTORE(nextHashPId)
    32 => D
    0 => HASHPOS

hashPoseidonLoop:
    %MAX_CNT_STEPS - STEP - 50 :JMPN(outOfCountersStep)

    C               :JMPZ(hashPoseidonEnd)
    C - 32          :JMPN(hashPoseidonFinal)
                    :CALL(MLOAD32)
    E => B
    $ => E          :MLOAD(tmpContractHashId)
    A               :HASHP(E)
    B => E
    C - 32 => C     :JMP(hashPoseidonLoop)


hashPoseidonFinal:
                    :CALL(MLOADX)
    32 - C => D     :CALL(SHRarith); in: [A: value, D: #bytes to right shift] out: [A: shifted result]
    $ => E          :MLOAD(tmpContractHashId)
    C => D
    A               :HASHP(E)

hashPoseidonEnd:
    $ => E          :MLOAD(tmpContractHashId)
    HASHPOS         :HASHPLEN(E)
    $ => D          :HASHPDIGEST(E)

hashPoseidonReturn:
    $ => RR         :MLOAD(tmpZkPChashP)
    $ => A          :MLOAD(tmpVarAhashP)
    $ => B          :MLOAD(tmpVarBhashP)
    $ => C          :MLOAD(tmpVarChashP)
    $ => E          :MLOAD(tmpVarEhashP), RETURN

VAR GLOBAL tmpVarBmask
; @info Mask address to 20 bytes
; @in A => address not masked
; @out A => masked address
maskAddress:
    %MAX_CNT_STEPS - STEP - 10 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 1 :JMPN(outOfCountersBinary)
    B               :MSTORE(tmpVarBmask)
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFn => B
    $ => A          :AND
    $ => B          :MLOAD(tmpVarBmask), RETURN

;@info: updates the address sytem storage with current batch and state root
updateSystemData:
    ; check keccak counters
    $ => A                              :MLOAD(cntKeccakPreProcess)
    %MAX_CNT_KECCAK_F - CNT_KECCAK_F - A - 1:JMPN(outOfCountersKeccak)
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 50 :JMPN(outOfCountersStep)
    %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - 255*2 :JMPN(outOfCountersPoseidon)
    ; Get last tx count
    %LAST_TX_STORAGE_POS => C
    %ADDRESS_SYSTEM => A
    %SMT_KEY_SC_STORAGE => B
    $ => D                              :MLOAD(txCount)
    ;Update last tx Count at system storage
    D + 1 => D                          :MSTORE(txCount)
    $ => SR                             :SSTORE

    ;Update state root mapping
    D => A
    32 => D
    0 => HASHPOS ; A new hash with position 0 is started
    $ => E                              :MLOAD(lastHashKIdUsed)
    E + 1 => E                          :MSTORE(lastHashKIdUsed)
    A                                   :HASHK(E)
    %STATE_ROOT_STORAGE_POS             :HASHK(E)
    HASHPOS                             :HASHKLEN(E)
    $ => C                              :HASHKDIGEST(E)
    %ADDRESS_SYSTEM => A
    SR => D
    $ => SR                             :SSTORE, RETURN

VAR GLOBAL tmpVarAmulmod
VAR GLOBAL tmpVarBmulmod
VAR GLOBAL tmpVarDmulmod
VAR GLOBAL tmpVarEmulmod
VAR GLOBAL tmpZkPCmulmod
; @info (A*B)%C => C
; @in A
; @in B
; @in C
; @out C
utilMULMOD:
    ; checks zk-counters
    %MAX_CNT_STEPS - STEP - 100 :JMPN(outOfCountersStep)
    %MAX_CNT_BINARY - CNT_BINARY - 3    :JMPN(outOfCountersBinary)
    %MAX_CNT_ARITH - CNT_ARITH - 2      :JMPN(outOfCountersArith)

    RR              :MSTORE(tmpZkPCmulmod)
    A               :MSTORE(tmpVarAmulmod)
    B               :MSTORE(tmpVarBmulmod)
    D               :MSTORE(tmpVarDmulmod)
    E               :MSTORE(tmpVarEmulmod)

    ; The following approach will be followed in order to verify the mulmod operation
    ; A * B + 0 = D*2^256 + E
    ; K * N + mulModResult = D*2^256 + E

    ; Since the k can be bigger than 2²⁵⁶ and therefore does not fit in a register we divedit in the
    ; most significan and less significant part:

    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E
    ; And divide this operation in 2 which fits in 2²⁵⁶ digits

    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2

    ; Mul operation with Arith
    $${var _mulMod = A * B}
    A               :MSTORE(arithA)
    ; here we perform the: A * B + 0 = D*2^256 + E
    ; result is stored in: arithRes1(E) and arithOverflow(D)
    B               :MSTORE(arithB), CALL(mulARITH)
    C => A
    ; Check if modulus is 0 or 1
    2 => B
    $               :LT, JMPC(zeroOneMod)
    ; Now we will try to perform the following equation:
    ; (k.l + k.h * 2²⁵⁶) * N + mulModResult = (D1 + D2) * 2²⁵⁶ + E

    ${(_mulMod / C) >> 256} => B     ; k.h
    ; We can jump with Js, because later it's all verified by the ARITH
    ${cond(B == 0)}  :JMPN(mulModNoKH)

    ; Since there's k.h we will split the equation in those 2
    ;k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ;k.h * 2²⁵⁶ * N  = D2 * 2²⁵⁶ --> k.h  * N  = D2

    ; k.h  * N  = D2
    ; B * A + 0 = 0 * 2²⁵⁶ + E
    ; D2 must be less than 2²⁵⁶
    C => A ; Modulus
    0 => C, D
    ${B * A} => E   :MSTORE(tmpVarDmulmod), ARITH ; D2

    ; k.l * N + mulModResult = D1 * 2²⁵⁶ + E
    ; B * A + C = D*2^256 + E
    ; remember that:
    ; result of mul is stored in: arithRes1(E) and arithOverflow(D)

    ${(_mulMod / A) % (1 << 256)} => B   ; k.l
    ${_mulMod % A} => C        ; mulModResult
    ${(B * A + C) >> 256} => D ; D1
    $               :MLOAD(arithRes1), ARITH

    ; Finally we need to assert the following:
    ; N>resultModulus
    ; D1 + D2 = D
    ; N>resultModulus   ; LT; ASSERT
    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT

    ; Assert D1 + D2 = D ; ADD ;ASSERT
    D => A ; D1
    $ => B          :MLOAD(tmpVarDmulmod) ;D2
    $ => A          :ADD
    $               :MLOAD(arithOverflow), ASSERT, JMP(utilMULMODend)

mulModNoKH:
    ; if theres no K.h the equation is simplified as:
    ; K * N + mulModResult = D*2^256 + E
    ; B * A + C = D*2^256 + E

    C => A ; Modulus on A
    ${(_mulMod / A)} => B   ; k
    ${_mulMod % A} => C     ; mulModResult
    $ => D         :MLOAD(arithOverflow)
    $              :MLOAD(arithRes1), ARITH

    A => B          ; modulus
    C => A          ; mulModResult
    $ => A          :LT
    1               :ASSERT, JMP(utilMULMODend)

zeroOneMod:
    0 => C

utilMULMODend:
    $ => A          :MLOAD(tmpVarAmulmod)
    $ => B          :MLOAD(tmpVarBmulmod)
    $ => D          :MLOAD(tmpVarDmulmod)
    $ => RR         :MLOAD(tmpZkPCmulmod)
    $ => E          :MLOAD(tmpVarEmulmod), RETURN

VAR GLOBAL tmpVarBexp
VAR GLOBAL tmpVarCexp
VAR GLOBAL tmpVarEexp
VAR GLOBAL tmpZkPCexp

;@info exp(A,D) --> A^D
;@in A, D => A^D
;@out A => result
expAD:
    %MAX_CNT_BINARY - CNT_BINARY - 2 :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 20       :JMPN(outOfCountersStep)
    RR              :MSTORE(tmpZkPCexp)
    B               :MSTORE(tmpVarBexp)
    C               :MSTORE(tmpVarCexp)
    E               :MSTORE(tmpVarEexp)
    ;E base
    A => E
    ;B exp
    D => B
    0 => A
    ;if exp == 0 --> expAD0
    $               :EQ,JMPC(expAD0)
    ;A base
    E => A
    0 => B
    ;if base == 0 --> expA0D
    $               :EQ,JMPC(expA0D)
    1 => C
    D => B          :CALL(getLenBits)  ;A exp bits length

    ; check zk-counters on each loop (A loops)
    ; - 3 ARITH: 1 in divARITH + 1 in 2*mulARITH
    ; - 5 BINARIES: 5 in divARITH
    ; - 100 steps (rounded up): 37 in divARITH + 11 in 2*mulARITH + 18 self
    %MAX_CNT_BINARY - CNT_BINARY - 2*A    :JMPN(outOfCountersBinary)
    %MAX_CNT_STEPS - STEP - 50*A         :JMPN(outOfCountersStep)

expADloop:
    ;A exp
    D => A
    0 => B
    ;if exp == 0 --> expADend
    $               :EQ,JMPC(expADend)
    A               :MSTORE(arithA)
    ;divARITH --> exp/2
    2               :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
    ;D = exp/2
    $ => D          :MLOAD(arithRes1)
    ;A = exp%2 (0 or 1)
    $ => A          :MLOAD(arithRes2)
    0 => B
    ;if exp%2 == 0 --> expADloop0
    $               :EQ,JMPC(expADloop0)
    E               :MSTORE(arithA)
    ;mulARITH --> E*C
    C               :MSTORE(arithB), CALL(mulARITH)
     ;C = E*C (acc = bp*acc)
    $ => C          :MLOAD(arithRes1)

expADloop0:
    E               :MSTORE(arithA)
    ;mulARITH --> E*E
    E               :MSTORE(arithB), CALL(mulARITH)
    ;E = E*E (bp = bp*bp)
    $ => E          :MLOAD(arithRes1), JMP(expADloop)
;if base == 0, result0
expA0D:
    0 => C
    0 => D          :JMP(expADend)
 ;if exp == 0, result 1
expAD0:
    1 => C
    0 => D

expADend:
    C => A
    $ => B          :MLOAD(tmpVarBexp)
    $ => C          :MLOAD(tmpVarCexp)
    $ => RR         :MLOAD(tmpZkPCexp)
    $ => E          :MLOAD(tmpVarEexp), RETURN

;@info function to force a failed assertt
failAssert:
    1 => A
    2               :ASSERT