;; get D bytes from batchL2Data
;@in D: number of bytes to get
;@in C: current data parsed pointer
;@out A: D bytes from batchL2Data at offset C
getBatchL2DataBytes:
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPN(invalidTxRLP)
        $ => E                          :MLOAD(batchHashDataPointer)
        $ => HASHPOS                    :MLOAD(batchHashPos)
        $ => A                          :HASHP(E)
        HASHPOS                         :MSTORE(batchHashPos)
        C => HASHPOS
        $ => E                          :MLOAD(txHashPointer)
                                        :RETURN

;; Add bytes to generate ethereum signed message
;; - legacy transaction: signedMessage = H_keccak(rlp(nonce, gasprice, gaslimit, to, value, data, chainId, 0, 0))
;; - pre EIP-155: signedMessage = H_keccak(rlp(nonce, gasprice, gaslimit, to, value, data))
; REVIEW: is it necessary?? (first two steps)
addHashTx:
        $ => A                          :MLOAD(txRLPLength)
        A - HASHPOS - D                 :JMPN(invalidTxRLP)
addHashTxBegin:
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPN(invalidTxRLP)
        $ => E                          :MLOAD(batchHashDataPointer)
        $ => HASHPOS                    :MLOAD(batchHashPos)
        $ => A                          :HASHP(E)
        HASHPOS                         :MSTORE(batchHashPos)
        $ => E                          :MLOAD(txHashPointer)
        C => HASHPOS
        A                               :HASHK(E)
        C + D => C                      :RETURN

;; Add bytes to generate ethereum signed message byte by byte
; It's done byte by byte to get 1 byte access to hashp during execution
;; - legacy transaction: signedMessage = H_keccak(rlp(nonce, gasprice, gaslimit, to, value, data, chainId, 0, 0))
;; - pre EIP-155: signedMessage = H_keccak(rlp(nonce, gasprice, gaslimit, to, value, data))
addHashTxFromFreeInput:
        $ => A                          :MLOAD(txRLPLength)
        A - HASHPOS - D                 :JMPN(invalidTxRLP)
        $ => A                          :MLOAD(batchL2DataLength)
        $ => B                          :MLOAD(batchL2DataParsed)
        A - B - C - D                   :JMPN(invalidTxRLP)
        B + C => A
        ; Read data from free input
        ${getTxs(A,D)} => A, B
        $ => E                          :MLOAD(txHashPointer)
        C => HASHPOS
        ; Insert data into txhash (hashk)
        A                               :HASHK(E)
        C + D => C
        ; Save current registers
        A                               :SAVE(B,C,D,E,RR,RCX)
        $ => E                          :MLOAD(batchHashDataPointer)
        $ => HASHPOS                    :MLOAD(batchHashPos)
        1 => C ; Current pointer
        D => RCX ; total bytes
        ; Set default remainder to 0, in case SHRarith is not using arithDiv because is shifting zero bytes
        0                               :MSTORE(arithRes2)
        ; Validate free input
validateFreeInputLoop:
        RCX - C                         :JMPN(validateFreeInputLoopEnd)
        ; Get free input byte by byte
        RCX - C => D                    :CALL(SHRarith) ; in: [A: value, D: #bytes to right shift] out: [A: shifted result]
        $                               :HASHP1(E), ASSERT
        ; The remainder of divArith used at SHRarith is the following bytes I want to check
        $ => A                          :MLOAD(arithRes2)
        C + 1 => C                      :JMP(validateFreeInputLoop)
validateFreeInputLoopEnd:
        HASHPOS                         :MSTORE(batchHashPos)
        $ => A                          :RESTORE
        C => HASHPOS                    :RETURN

;; Check short value is over 127. Error RLP: single byte < 0x80 are not prefixed
checkShortRLP:
        D - 1                           :JMPNZ(skipCheckShort)
        A - %MIN_VALUE_SHORT            :JMPN(invalidTxRLP)

skipCheckShort:
                                        :RETURN

;; Check long list/value is over 55 bytes long. Error RLP: encoded list too short
checkLongRLP:
        A - %MIN_BYTES_LONG             :JMPN(invalidTxRLP)
                                        :RETURN

;; Check short value is over 127. Error RLP: single byte < 0x80 are not prefixed
checkShortDataRLP:
        $ => B                          :MLOAD(txCalldataLen)
        B - 1                           :JMPNZ(skipCheckShortData)
        A - %MIN_VALUE_SHORT            :JMPN(invalidTxRLP)

skipCheckShortData:
                                        :RETURN

;; Check non-negative integer RLP representation has no leading zeros and it is encoded in its shortest form
VAR GLOBAL tmpVarAcheckNonLeadingZeros
VAR GLOBAL tmpVarZkPCcheckNonLeadingZeros
checkNonLeadingZeros:
        RR                              :MSTORE(tmpVarZkPCcheckNonLeadingZeros)
        A                               :MSTORE(tmpVarAcheckNonLeadingZeros)
        ; set value to B and get its
        A => B                          :CALL(getLenBytes) ; in: [B: number] out: [A: byte length of B]
        ; check (bytes length - encoded length) are not equal
        D - A                           :JMPNZ(invalidTxRLP)
        $ => RR                         :MLOAD(tmpVarZkPCcheckNonLeadingZeros)
        $ => A                          :MLOAD(tmpVarAcheckNonLeadingZeros), RETURN