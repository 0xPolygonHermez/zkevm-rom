;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: B, E, M have been trimmed.
;; POST: out is trimmed
;;
;; modexp:
;; ----------------------------------------
;;          input:
;;                  · Blen ∈ [1, 32], the len of B
;;                  · Elen ∈ [1, 32], the len of E
;;                  · Mlen ∈ [1, 32], the len of M
;;                  ·     B ∈ [0, 2²⁵⁶ - 1]^Blen, the base represented in little-endian
;;                  ·     E ∈ [0, 2²⁵⁶ - 1]^Elen, the exponent represented in little-endian
;;                  ·     M ∈ [0, 2²⁵⁶ - 1]^Mlen, the modulus represented in little-endian
;;
;;          output:
;;                  · B^E (mod M) ∈ [0, 2²⁵⁶ - 1]^Mlen
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; function modexp(base: bigint[], exp: bigint[], mod: bigint[]): bigint[] {
;;     if (array_is_zero(mod) || array_is_one(mod)) return [0n];
;;     if (array_is_zero(base)) return [0n];
;;     if (array_is_one(base)) return [1n];
;;     if (array_is_zero(e)) return [1n];
;;
;;     let out = [1n];
;;     let base = array_div(base, mod)[1];
;;     while (!array_is_zero(exp)) {
;;         if (array_is_zero(base)) return [0n];
;;         if (isOdd(exp)) {
;;             out = array_div(array_mul(out, base),mod)[1];
;;         }
;;         exp = array_div_two(exp);
;;         base = array_div(array_square(base),mod)[1];
;;     }
;;     return r;
;; };

VAR GLOBAL modexp_Blen
VAR GLOBAL modexp_Elen
VAR GLOBAL modexp_Mlen
VAR GLOBAL modexp_B[%MODEXP_MAX_LEN]
VAR GLOBAL modexp_E[%MODEXP_MAX_LEN]
VAR GLOBAL modexp_M[%MODEXP_MAX_LEN]

VAR GLOBAL modexp_out[%MODEXP_MAX_LEN]
VAR GLOBAL modexp_outlen

VAR GLOBAL modexp_RR

; RESOURCES (assuming a worst case scenario):
; -------------------------------------------
; [steps: 7] + len(B)*[steps: 3] + len(M)*[steps: 3] + [steps: 1]                                     // init and B and M to array_div_long
; [steps: 66 + 7*len(B) + 8*len(Q(B,M)) + 9*len(R(B,M)) + 19*len(Q(B,M))*len(M),                      // array_div_long of B and M
;    bin: 4 - len(M) + len(R(B,M)) + 2*len(Q(B,M))*len(M),
;  arith: len(Q(B,M))*len(M)]
; [steps: 2] + len(R(B,M))*[steps: 3]                                                                 // copy R(B,M) to B
;
; for ⌊log₂(E)⌋ iterations:
;   [steps: 4, bin: 1]                                                                                // check E == 0
;   [steps: 3, bin: 1]                                                                                // check B == 0
;   [steps: 3, bin: 1]                                                                                // check E parity
;   if E is odd, then compute (O·B) % M:
;        [steps: 4] + len(O)*[steps: 3] + len(B)*[steps: 3] + [steps: 1]                              // O and B to array_mul_long
;        [steps: 20 - 5*len(O) - 12*len(B) + 19*len(O)*len(B),                                        // array_mul_long of O and B
;           bin: 2 - len(O) - 2*len(B) + 2*len(O)*len(B),
;         arith: len(O)*len(B)]
;        [steps: 4] + len(O·B)*[steps: 3] + len(M)*[steps: 3] + [steps: 1]                            // O·B and M to array_div_long
;        [steps: 66 + 7*len(O·B) + 8*len(Q(O·B,M)) + 9*len(R(O·B,M)) + 19*len(Q(O·B,M))*len(M),       // array_div_long of O·B and M
;           bin: 4 - len(M) + len(R(O·B,M)) + 2*len(Q(O·B,M))*len(M),
;         arith: len(Q(O·B,M))*len(M)]
;       [steps: 3] + len(R(O·B,M))*[steps: 3]                                                         // copy R(O·B,M) to O
;   [steps: 2] + len(E)*[steps: 3] + [steps: 1]                                                       // E to array_div_two
;   [steps: 49 + 3*len(E) + 22*len(Q(E,2)), bin: 3 + 2*len(Q(E,2))]                                   // array_div_two of E
;   [steps: 3] + len(Q(E,2))*[steps: 3]                                                               // Copy Q(E,2) to E
;   [steps: 2] + len(B)*[steps: 3] + [steps: 1]                                                       // B to array_square
;   [steps: 32 - 25*len(B) + 51*len(B)², bin: 1 - 9*len(B) + 9*len(B)², arith: -1 + len(B) + len(B)²] // array_square of B
;   [steps: 4] + len(B²)*[steps: 3] + len(M)*[steps: 3] + [steps: 1]                                  // B² and M to array_div_long
;   [steps: 66 + 7*len(B²) + 8*len(Q(B²,M)) + 9*len(R(B²,M)) + 19*len(Q(B²,M))*len(M),                // array_div_long of B² and M
;      bin: 4 - len(M) + len(R(B²,M)) + 2*len(Q(B²,M))*len(M),
;    arith: len(Q(B²,M))*len(M)]
;   [steps: 3] + len(R(B²,M))*[steps: 3]                                                              // copy R(B²,M) to B
;
; [steps: 2]                                                                                          // end
;
; -------------------------------------------
; nIterations    = ⌊log₂(E)⌋
; num_times_E_is_odd   = HammingWeight(E) (i.e., number of 1s in the binary representation of E)
; num_times_E_is_even  = nIterations - num_times_E_is_odd
; -------------------------------------------
;       · cost(first_part)    = [steps: 76 + 10*len(B) + 3*len(M) + 8*len(Q(B,M)) + 12*len(R(B,M)) + 19*len(Q(B,M))*len(M),
;                                  bin: 4 - len(M) + len(R(B,M)) + 2*len(Q(B,M))*len(M),
;                                arith: len(Q(B,M))*len(M)]
;       · cost(odd_iteration) = [steps: 273 +    len(B) + 6*len(E) + 26*len(M) + 54*len(B)² + 38*len(B)*len(M) + 22*len(Q(E,2)) + 19*len(Q(B²,M))*len(M) + 8*len(Q(B²,M)) + 12*len(R(B²,M)),
;                                  bin: 17  - 11*len(B)            -  2*len(M) +  9*len(B)² +  4*len(B)*len(M) +  2*len(Q(E,2)) +  2*len(Q(B²,M))*len(M)                  +    len(R(B²,M)) ,
;                                arith: -1  +    len(B)                        +    len(B)² +  2*len(B)*len(M)                  +    len(Q(B²,M))*len(M)]
;       · cost(last_part)     = [steps: 2]
; -------------------------------------------
; cost(w.c): cost(first_part) + ⌊log₂(E)⌋*odd_iteration + cost(last_part)
; -------------------------------------------
; Note: For the total count, we have used that O <= M, len(B²) <= 2*len(B), len(O·B) <= len(M·B) <= len(M) + len(B), Q(O·B,M) <= Q(M·B,M) = B and R(O·B,M) < M

modexp:
        %MAX_CNT_STEPS - STEP - 7 - 3*%ARRAY_MAX_LEN - 3*%ARRAY_MAX_LEN - 1  :JMPN(outOfCountersStep) ; init and array div long

        RR              :MSTORE(modexp_RR)

        ; I do not need to cover edge cases here since they are covered in the pre-modexp file
        ; Therefore, I can assume that M > 1, B > 1, E > 0

        1               :MSTORE(modexp_out)
        1               :MSTORE(modexp_outlen)

        ; prepare for computing B % M
        $ => C          :MLOAD(modexp_Blen)
        $ => D          :MLOAD(modexp_Mlen)
        C - 1 => RR
        D - 1 => E      :JMPNZ(modexp_B_to_div_long)

; Compute B = B % M
; -------------------
; 1] Short path
modexp_B_to_div_short:
        $ => A          :MLOAD(modexp_B + RR)
        A               :MSTORE(array_div_short_inA + RR)
        RR - 1 => RR    :JMPN(modexp_M_to_div_short1, modexp_B_to_div_short)

modexp_M_to_div_short1:
        $ => A          :MLOAD(modexp_M)
        A               :MSTORE(array_div_short_inB)

modexp_div_short_B_and_M:
                        :CALL(array_div_short) ;  inputs: [array_div_short_len_inA: C, array_div_short_inA: modexp_B, array_div_short_inB: modexp_M]
                                               ; outputs: [array_div_short_rem]

        %MAX_CNT_STEPS - STEP - 5       :JMPN(outOfCountersStep) ; till pre_loop

        1               :MSTORE(modexp_Blen)
        $ => A          :MLOAD(array_div_short_rem)
        A               :MSTORE(modexp_B), JMP(modexp_pre_loop)

; 2] Long path
modexp_B_to_div_long:
        $ => A          :MLOAD(modexp_B + RR)
        A               :MSTORE(array_div_long_inA + RR)
        RR - 1 => RR    :JMPN(modexp_M_to_div_long1, modexp_B_to_div_long)

modexp_M_to_div_long1:
        $ => A          :MLOAD(modexp_M + E)
        A               :MSTORE(array_div_long_inB + E)
        E - 1 => E      :JMPN(modexp_div_long_B_and_M, modexp_M_to_div_long1)

modexp_div_long_B_and_M:
                        :CALL(array_div_long) ;  inputs: [array_div_long_len_inA: C, array_div_long_len_inB: D, array_div_long_inA: modexp_B, array_div_long_inB: modexp_M]
                                              ; outputs: [array_div_long_len_rem, array_div_long_rem]

        $ => C          :MLOAD(array_div_long_len_rem)

        %MAX_CNT_STEPS - STEP - 2 - 3*%ARRAY_MAX_LEN - 2     :JMPN(outOfCountersStep) ; till pre_loop

        C               :MSTORE(modexp_Blen)
        C - 1 => RR

modexp_rem_from_div1:
        $ => A          :MLOAD(array_div_long_rem + RR)
        A               :MSTORE(modexp_B + RR)
        RR - 1 => RR    :JMPN(modexp_pre_loop, modexp_rem_from_div1)
; -------------------

; Begin of edge cases
modexp_B_is_zero:
        ; (0^E) % M = 0.
        1               :MSTORE(modexp_outlen)
        0               :MSTORE(modexp_out), JMP(modexp_end)
; End of edge cases

; Begin of branching
modexp_loop_multiply:
        ; w.c. happens when both B and the result of out*B are long

        $ => C          :MLOAD(modexp_outlen)
        $ => D          :MLOAD(modexp_Blen)
        C - 1 => RR
        D - 1 => E      :JMPNZ(modexp_out_to_mul_long)

; Compute out * B
; -------------------
; 1] Short path
modexp_out_to_mul_short:
        $ => A          :MLOAD(modexp_out + RR)
        A               :MSTORE(array_mul_short_inA + RR)
        RR - 1 => RR    :JMPN(modexp_B_to_mul_short, modexp_out_to_mul_short)

modexp_B_to_mul_short:
        $ => A          :MLOAD(modexp_B)
        A               :MSTORE(array_mul_short_inB)

modexp_mul_short_out_and_B:
                        :CALL(array_mul_short) ;  inputs: [array_mul_short_len_inA: C, array_mul_short_inA: modexp_out, array_mul_short_inB: modexp_B]
                                               ; outputs: [array_mul_short_len_out, array_mul_short_out]

        %MAX_CNT_STEPS - STEP - 4 - 3*%ARRAY_MAX_LEN - 3*%ARRAY_MAX_LEN - 1 :JMPN(outOfCountersStep)

        $ => C          :MLOAD(array_mul_short_len_out)
        $ => D          :MLOAD(modexp_Mlen)
        C - 1 => RR
        D - 1 => E      :JMPNZ(modexp_mul_short_out_to_div_long, modexp_mul_short_out_to_div_short)

; 2] Long path
modexp_out_to_mul_long:
        $ => A          :MLOAD(modexp_out + RR)
        A               :MSTORE(array_mul_long_inA + RR)
        RR - 1 => RR    :JMPN(modexp_B_to_mul_long, modexp_out_to_mul_long)

modexp_B_to_mul_long:
        $ => A          :MLOAD(modexp_B + E)
        A               :MSTORE(array_mul_long_inB + E)
        E - 1 => E      :JMPN(modexp_mul_long_out_and_B, modexp_B_to_mul_long)

modexp_mul_long_out_and_B:
                        :CALL(array_mul_long) ;  inputs: [array_mul_long_len_inA: C, array_mul_long_len_inB: D, array_mul_long_inA: modexp_out, array_mul_long_inB: modexp_B]
                                              ; outputs: [array_mul_long_len_out, array_mul_long_out]

        %MAX_CNT_STEPS - STEP - 4 - 3*%ARRAY_MAX_LEN - 3*%ARRAY_MAX_LEN - 1 :JMPN(outOfCountersStep)

        $ => C          :MLOAD(array_mul_long_len_out)
        $ => D          :MLOAD(modexp_Mlen)
        C - 1 => RR
        D - 1 => E      :JMPNZ(modexp_mul_long_out_to_div_long, modexp_mul_long_out_to_div_short)

; Compute out = (out * B) % M
;--------------------------------
; 1] Mul short out to div short
modexp_mul_short_out_to_div_short:
        $ => A          :MLOAD(array_mul_short_out + RR)
        A               :MSTORE(array_div_short_inA + RR)
        RR - 1 => RR    :JMPN(modexp_M_to_div_short2, modexp_mul_short_out_to_div_short)

; 2] Mul long out to div short
modexp_mul_long_out_to_div_short:
        $ => A          :MLOAD(array_mul_long_out + RR)
        A               :MSTORE(array_div_short_inA + RR)
        RR - 1 => RR    :JMPN(modexp_M_to_div_short2, modexp_mul_long_out_to_div_short)

modexp_M_to_div_short2:
        $ => A          :MLOAD(modexp_M)
        A               :MSTORE(array_div_short_inB)

modexp_div_short_out_and_M1:
                        :CALL(array_div_short) ;  inputs: [array_div_short_len_inA: C, array_div_short_inA: array_mul_long_out, array_div_short_inB: modexp_M]
                                               ; outputs: [array_div_short_rem]

        %MAX_CNT_STEPS - STEP - 3 - 2 - 3*%ARRAY_MAX_LEN - 2 :JMPN(outOfCountersStep) ; till array_div_short by 2

        1               :MSTORE(modexp_outlen)
        $ => A          :MLOAD(array_div_short_rem)
        A               :MSTORE(modexp_out), JMP(return_modexp_loop_multiply)

; 3] Mul short out to div long
modexp_mul_short_out_to_div_long:
        $ => A          :MLOAD(array_mul_short_out + RR)
        A               :MSTORE(array_div_long_inA + RR)
        RR - 1 => RR    :JMPN(modexp_M_to_div_long2, modexp_mul_short_out_to_div_long)

; 4] Mul long out to div long
modexp_mul_long_out_to_div_long:
        $ => A          :MLOAD(array_mul_long_out + RR)
        A               :MSTORE(array_div_long_inA + RR)
        RR - 1 => RR    :JMPN(modexp_M_to_div_long2, modexp_mul_long_out_to_div_long)

modexp_M_to_div_long2:
        $ => A          :MLOAD(modexp_M + E)
        A               :MSTORE(array_div_long_inB + E)
        E - 1 => E      :JMPN(modexp_div_long_out_and_M1, modexp_M_to_div_long2)

modexp_div_long_out_and_M1:
                        :CALL(array_div_long) ;  inputs: [array_div_long_len_inA: C, array_div_long_inA: array_mul_long_out, array_div_long_inB: modexp_M]
                                              ; outputs: [array_div_long_len_rem, array_div_long_rem]

        %MAX_CNT_STEPS - STEP - 3 - 3*%ARRAY_MAX_LEN - 2 - 3*%ARRAY_MAX_LEN - 2 :JMPN(outOfCountersStep) ; till array_div_short by 2

        $ => C          :MLOAD(array_div_long_len_rem)
        C               :MSTORE(modexp_outlen)
        C - 1 => RR

modexp_rem_from_div2:
        $ => A          :MLOAD(array_div_long_rem + RR)
        A               :MSTORE(modexp_out + RR)
        RR - 1 => RR    :JMPN(return_modexp_loop_multiply, modexp_rem_from_div2)
; -------------------
; End of branching

modexp_pre_loop:
        %MAX_CNT_BINARY - CNT_BINARY - 3                                         :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP - 12 - 4 - 3*%ARRAY_MAX_LEN - 3*%ARRAY_MAX_LEN - 1 :JMPN(outOfCountersStep) ; till array_mul_long of loop_multiply

        ; Is Elen = 1 and E = 0?
        0 => B
        $ - 1           :F_MLOAD(modexp_Elen), JMPNZ(__modexp_E_continue)
        $ => A          :MLOAD(modexp_E)
        $               :EQ, JMPC(modexp_end) ; we are done
                        __modexp_E_continue:

modexp_loop:
        ; Is Blen = 1 and B = 0?
        $ - 1           :F_MLOAD(modexp_Blen), JMPNZ(__modexp_B_continue)
        $ => A          :MLOAD(modexp_B)
        $               :EQ, JMPC(modexp_B_is_zero)
                        __modexp_B_continue:

        ; Is E is odd?
        ; The base is 2^256, so I only need to check if the first chunk is odd to conclude that the whole number is odd.
        $ => A          :MLOAD(modexp_E)
        1 => B
        $               :AND, JMPC(modexp_loop_multiply) ; In the worst case, the exponent is odd in each iteration
                        return_modexp_loop_multiply:

        $ => C          :MLOAD(modexp_Elen)
        C - 1 => RR

; Compute E = E // 2
; -------------------
modexp_E_to_div_two:
        $ => A          :MLOAD(modexp_E + RR)
        A               :MSTORE(array_div_two_in + RR)
        RR - 1 => RR    :JMPN(modexp_div_E_and_two, modexp_E_to_div_two)

modexp_div_E_and_two:
                        :CALL(array_div_two) ;  inputs: [array_div_two_len_in: C, array_div_two_in: modexp_E]
                                             ; outputs: [array_div_two_len_quo, array_div_two_quo]

        %MAX_CNT_STEPS - STEP - 3 - 3*%ARRAY_MAX_LEN - 2 - 3*%ARRAY_MAX_LEN - 1   :JMPN(outOfCountersStep) ; till array_square

        $ => C          :MLOAD(array_div_two_len_quo)
        C               :MSTORE(modexp_Elen)
        C - 1 => RR

modexp_quo_from_div_two:
        $ => A          :MLOAD(array_div_two_quo + RR)
        A               :MSTORE(modexp_E + RR)
        RR - 1 => RR    :JMPN(modexp_pre_B_square, modexp_quo_from_div_two)
; -------------------

; Compute B^2
; -------------------
modexp_pre_B_square:
        $ => C          :MLOAD(modexp_Blen)
        C - 1 => RR

modexp_B_to_square1:
        $ => A          :MLOAD(modexp_B + RR)
        A               :MSTORE(array_square_in + RR)
        RR - 1 => RR    :JMPN(modexp_square_B, modexp_B_to_square1)

modexp_square_B:
                        :CALL(array_square) ;  inputs: [array_square_len_in: C, array_square_in: modexp_B]
                                            ; outputs: [array_square_len_out, array_square_out]

        %MAX_CNT_STEPS - STEP - 4 - 3*%ARRAY_MAX_LEN - 3*%ARRAY_MAX_LEN - 1     :JMPN(outOfCountersStep)

        $ => C          :MLOAD(array_square_len_out)
        $ => D          :MLOAD(modexp_Mlen)
        C - 1 => RR
        D - 1 => E      :JMPNZ(modexp_out_to_div_long2)

; Compute B = (B^2) % M
; 1] Short path
modexp_out_to_div_short2:
        $ => A          :MLOAD(array_square_out + RR)
        A               :MSTORE(array_div_short_inA + RR)
        RR - 1 => RR    :JMPN(modexp_M_to_div_short3, modexp_out_to_div_short2)

modexp_M_to_div_short3:
        $ => A          :MLOAD(modexp_M)
        A               :MSTORE(array_div_short_inB)

modexp_div_short_out_and_M2:
                        :CALL(array_div_short) ;  inputs: [array_div_short_len_inA: C, array_div_short_inA: array_square_out, array_div_short_inB: modexp_M]
                                               ; outputs: [array_div_short_rem]

        %MAX_CNT_STEPS - STEP - 3 - 2    :JMPN(outOfCountersStep) ; till begginning of modexp_pre_loop

        1               :MSTORE(modexp_Blen)
        $ => A          :MLOAD(array_div_short_rem)
        A               :MSTORE(modexp_B), JMP(modexp_pre_loop)

; 2] Long path
modexp_out_to_div_long2:
        $ => A          :MLOAD(array_square_out + RR)
        A               :MSTORE(array_div_long_inA + RR)
        RR - 1 => RR    :JMPN(modexp_M_to_div_long3, modexp_out_to_div_long2)

modexp_M_to_div_long3:
        $ => A          :MLOAD(modexp_M + E)
        A               :MSTORE(array_div_long_inB + E)
        E - 1 => E      :JMPN(modexp_div_long_out_and_M2, modexp_M_to_div_long3)

modexp_div_long_out_and_M2:
                        :CALL(array_div_long) ;  inputs: [array_div_long_len_inA: C, array_div_long_len_inB: D, array_div_long_inA: array_square_out, array_div_long_inB: modexp_M]
                                              ; outputs: [array_div_long_len_rem, array_div_long_rem]

        %MAX_CNT_STEPS - STEP - 3 - 3*%ARRAY_MAX_LEN - 2 :JMPN(outOfCountersStep) ; till begginning of modexp_pre_loop

        $ => C          :MLOAD(array_div_long_len_rem)
        C               :MSTORE(modexp_Blen)
        C - 1 => RR

modexp_rem_from_div3:
        $ => A          :MLOAD(array_div_long_rem + RR)
        A               :MSTORE(modexp_B + RR)
        RR - 1 => RR    :JMPN(modexp_pre_loop, modexp_rem_from_div3)
; -------------------

modexp_end:
        $ => RR         :MLOAD(modexp_RR)
                        :RETURN