; constants needed by executor C++
CONST %N = 2**19
CONST %MAX_CNT_STEPS_LIMIT = %N
CONST %MAX_CNT_ARITH_LIMIT = %N
CONST %MAX_CNT_BINARY_LIMIT = %N
CONST %MAX_CNT_MEM_ALIGN_LIMIT = %N
CONST %MAX_CNT_KECCAK_F_LIMIT = %N
CONST %MAX_CNT_PADDING_PG_LIMIT = %N
CONST %MAX_CNT_POSEIDON_G_LIMIT = %N

VAR GLOBAL lastHashKId
VAR GLOBAL lastHashPId

VAR GLOBAL initial_A
VAR GLOBAL initial_B
VAR GLOBAL initial_C
VAR GLOBAL initial_D
VAR GLOBAL initial_E
VAR GLOBAL initial_CTX
VAR GLOBAL initial_SP
VAR GLOBAL initial_PC
VAR GLOBAL initial_GAS
VAR GLOBAL initial_SR
VAR GLOBAL initial_RR
VAR GLOBAL initial_HASHPOS
VAR GLOBAL initial_RCX

start:

        STEP => A
        0 :ASSERT

        A           :MSTORE(initial_A)
        B           :MSTORE(initial_B)
        C           :MSTORE(initial_C)
        D           :MSTORE(initial_D)
        E           :MSTORE(initial_E)
        CTX         :MSTORE(initial_CTX)
        SP          :MSTORE(initial_SP)
        PC          :MSTORE(initial_PC)
        GAS         :MSTORE(initial_GAS)
        SR          :MSTORE(initial_SR)
        RR          :MSTORE(initial_RR)
        HASHPOS     :MSTORE(initial_HASHPOS)
        RCX         :MSTORE(initial_RCX)
        0 => A,B,C,D,E,CTX, SP, PC, GAS, SR, RR, HASHPOS, RCX

        -1          :MSTORE(lastHashKId)
        -1          :MSTORE(lastHashPId)

        ; 1] B = [2n, 1n, 1n, 1n], E = [3n, 5n], M = [4n, 6n, 7n]
        4               :MSTORE(modexp_Blen)
        2               :MSTORE(modexp_Elen)
        3               :MSTORE(modexp_Mlen)

        2n              :MSTORE(modexp_B)
        1 => E
        1n              :MSTORE(modexp_B + E)
        2 => E
        1n              :MSTORE(modexp_B + E)
        3 => E
        1n              :MSTORE(modexp_B + E)
        3n              :MSTORE(modexp_E)
        1 => E
        5n              :MSTORE(modexp_E + E)
        4n              :MSTORE(modexp_M)
        1 => E
        6n              :MSTORE(modexp_M + E)
        2 => E
        7n              :MSTORE(modexp_M + E)
                        :CALL(modexp)
        ${dump(mem.modexp_out[0],mem.modexp_out[1],mem.modexp_out[2])}
        16799222018138169590613227618843456355247327644003751420511040302320945803948n             :MLOAD(modexp_out)
        1 => E
        67226185770814561827024093064262870237432709513661454124124794094744315370418n             :MLOAD(modexp_out + E)
        2 => E
        1n             :MLOAD(modexp_out + E)
        3             :MLOAD(modexp_outlen)

        ; ; 2] [a, 7n, a, 12n, a, 20n, a, 80n] / [a, a, a, a, 100n]
        ; 8 => C
        ; 5 => D
        ; 115792089237316195423570985008687907853269984665640564039457584007913129639935n              :MSTORE(modexp_inA)
        ; 1 => E
        ; 7n              :MSTORE(modexp_inA + E)
        ; 2 => E
        ; 115792089237316195423570985008687907853269984665640564039457584007913129639935n              :MSTORE(modexp_inA + E)
        ; 3 => E
        ; 12n              :MSTORE(modexp_inA + E)
        ; 4 => E
        ; 115792089237316195423570985008687907853269984665640564039457584007913129639935n              :MSTORE(modexp_inA + E)
        ; 5 => E
        ; 20n              :MSTORE(modexp_inA + E)
        ; 6 => E
        ; 115792089237316195423570985008687907853269984665640564039457584007913129639935n              :MSTORE(modexp_inA + E)
        ; 7 => E
        ; 80n              :MSTORE(modexp_inA + E)

        ; 115792089237316195423570985008687907853269984665640564039457584007913129639935n              :MSTORE(modexp_inB)
        ; 1 => E
        ; 115792089237316195423570985008687907853269984665640564039457584007913129639935n              :MSTORE(modexp_inB + E)
        ; 2 => E
        ; 115792089237316195423570985008687907853269984665640564039457584007913129639935n              :MSTORE(modexp_inB + E)
        ; 3 => E
        ; 115792089237316195423570985008687907853269984665640564039457584007913129639935n              :MSTORE(modexp_inB + E)
        ; 4 => E
        ; 100n              :MSTORE(modexp_inB + E)
        ;                 :CALL(modexp)
        ; 87130681010257731209815790699606742543054641926620622445532439451498988639951n             :MLOAD(modexp_quo)
        ; 1 => E
        ; 76812574048516684092863920748337523031377118540573443471719387411189897879957n             :MLOAD(modexp_quo + E)
        ; 2 => E
        ; 92862962655669424052566829561422975605097710474424610764317468362781816839948n             :MLOAD(modexp_quo + E)
        ; 87130681010257731209815790699606742543054641926620622445532439451498988639950n             :MLOAD(modexp_rem)
        ; 1 => E
        ; 76812574048516684092863920748337523031377118540573443471719387411189897879965n             :MLOAD(modexp_rem + E)
        ; 2 => E
        ; 92862962655669424052566829561422975605097710474424610764317468362781816839947n             :MLOAD(modexp_rem + E)
        ; 3 => E
        ; 13n             :MLOAD(modexp_rem + E)
        ; 4 => E
        ; 84n             :MLOAD(modexp_rem + E)

        ; ; 3] inA == 0, inB != 0
        ; 1 => C
        ; 2 => D
        ; 0n              :MSTORE(modexp_inA)

        ; 8n              :MSTORE(modexp_inB)
        ; 1 => E
        ; 1n              :MSTORE(modexp_inB + E)
        ;                 :CALL(modexp)
        ; 0n             :MLOAD(modexp_quo)
        ; 0n             :MLOAD(modexp_rem)

        ; ; 4] inA != 0, inB == 0 -> error
        ; 2 => C
        ; 1 => D
        ; 0n              :MSTORE(modexp_inA)
        ; 1 => E
        ; 30n              :MSTORE(modexp_inA + E)

        ; 0n              :MSTORE(modexp_inB)
        ;                 :CALL(modexp)
        ; 1 => A
        ; B               :ASSERT

        ; ; 5] inA == inB
        ; 2 => C
        ; 2 => D
        ; 10n             :MSTORE(modexp_inA)
        ; 1 => E
        ; 30n             :MSTORE(modexp_inA + E)

        ; 10n             :MSTORE(modexp_inB)
        ; 1 => E
        ; 30n             :MSTORE(modexp_inB + E)
        ;                 :CALL(modexp)
        ; 1n              :MLOAD(modexp_quo)
        ; 0n              :MLOAD(modexp_rem)

        ; ; 5] inA < inB
        ; 2 => C
        ; 3 => D
        ; 10n             :MSTORE(modexp_inA)
        ; 1 => E
        ; 30n             :MSTORE(modexp_inA + E)

        ; 6n             :MSTORE(modexp_inB)
        ; 1 => E
        ; 7n             :MSTORE(modexp_inB + E)
        ; 2 => E
        ; 8n             :MSTORE(modexp_inB + E)
        ;                 :CALL(modexp)
        ; 0n              :MLOAD(modexp_quo)
        ; 10n             :MLOAD(modexp_rem)
        ; 1 => E
        ; 30n             :MSTORE(modexp_rem + E)

end:

        $ => A           :MLOAD(initial_A)
        $ => B           :MLOAD(initial_B)
        $ => C           :MLOAD(initial_C)
        $ => D           :MLOAD(initial_D)
        $ => E           :MLOAD(initial_E)
        $ => CTX         :MLOAD(initial_CTX)
        $ => SP          :MLOAD(initial_SP)
        $ => PC          :MLOAD(initial_PC)
        $ => GAS         :MLOAD(initial_GAS)
        $ => SR          :MLOAD(initial_SR)
        $ => RR          :MLOAD(initial_RR)
        $ => HASHPOS     :MLOAD(initial_HASHPOS)
        $ => RCX         :MLOAD(initial_RCX)

; label finalizeExecution needed by executor C++
finalizeExecution:
        ${beforeLast()}  : JMPN(finalizeExecution)

                         : JMP(start)
opINVALID:
; label checkAndSaveFrom needed by executor C++
checkAndSaveFrom:
                         :JMP(opINVALID)

INCLUDE "array_lib/utils/array_is_zero.zkasm"
INCLUDE "array_lib/utils/array_is_one.zkasm"
INCLUDE "array_lib/utils/array_is_odd.zkasm"
INCLUDE "array_lib/utils/array_trim.zkasm"
INCLUDE "array_lib/utils/array_compare.zkasm"

INCLUDE "array_lib/array_add_AGTB.zkasm"
INCLUDE "array_lib/array_mul_long.zkasm"
INCLUDE "array_lib/array_mul_short.zkasm"
INCLUDE "array_lib/array_square.zkasm"
INCLUDE "array_lib/array_div_mod_short.zkasm"
INCLUDE "array_lib/array_div_mod_long.zkasm"

INCLUDE "modexp.zkasm"