;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; POST: out is trimmed
;;
;; array_square:
;;             in:
;;                  · C ∈ [1, 32], the len of in
;;                  · in ∈ [0, 2²⁵⁶- 1]^C, the input array
;;
;;          output:
;;                  · out = in², with len(out) <= 2·C
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Matrix visualization: https://hackmd.io/C9KQPGoaSICStIQQFweBlw?view

; code
; --------------------------
; first_iteration_first_row       <-- Compute a[0]·b[0]
; do {
;     finish_first_row            <-- Compute a[0]·b[j] + out[j]
; } while(inB_index_check)        <-- While 0 < j < len(b)
; while(inA_index_check) {        <-- While 0 <  i < len(a)
;       while (inB_index_check) { <-- While 0 <= j < len(b) - 1
;               loop2inB          <-- Compute a[i]·b[j] + out[i+j]
;       }
;      loop2inB_last              <-- Compute a[i]·b[len(b)-1] + out[i+len(b)-1]
; }
; 1] check_carry                  <-- If there is a carry, append it to the result
; 2] trim                         <-- Otherwise, trim the result
; end
; --------------------------

VAR GLOBAL array_square_in[%ARRAY_MAX_LEN]
VAR GLOBAL array_square_out[%ARRAY_MAX_LEN_DOUBLED]
VAR GLOBAL array_square_len_in
VAR GLOBAL array_square_len_out

VAR GLOBAL array_square_carry_chunk_1
VAR GLOBAL array_square_carry_chunk_2
VAR GLOBAL array_square_chunk_3
VAR GLOBAL array_square_aiaj_chunk_2
VAR GLOBAL array_square_out_chunk_2

VAR GLOBAL array_square_RR

array_square:
        ; costs: [steps: 6, binary: 0, arith: 0] + [steps: 9, binary: 0, arith: 1] + (len(in) - 1)*[steps: 35, binary: 6, arith: 1] <--- Init and first row
        ;      + (len(in) - 1)*([steps: 7, binary: 0, arith: 0] + [steps: 6, binary: 0, arith: 1] + [steps: 29, binary: 3, arith: 1] + (len(in) - 1)*[steps: 51, binary: 9, arith: 1]) <--- Rest of the rows
        ;        [steps: 8, binary: 1, arith: 0] <--- Ending
        %MAX_CNT_ARITH - CNT_ARITH   - 1  -    %ARRAY_MAX_LEN_MINUS_ONE -  2*%ARRAY_MAX_LEN_MINUS_ONE -   %ARRAY_MAX_LEN_SQ      :JMPN(outOfCountersArith)
        %MAX_CNT_BINARY - CNT_BINARY      -  6*%ARRAY_MAX_LEN_MINUS_ONE -  3*%ARRAY_MAX_LEN_MINUS_ONE -  9*%ARRAY_MAX_LEN_SQ - 1 :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP        - 15 - 35*%ARRAY_MAX_LEN_MINUS_ONE - 42*%ARRAY_MAX_LEN_MINUS_ONE - 51*%ARRAY_MAX_LEN_SQ - 8 :JMPN(outOfCountersStep)

        RR              :MSTORE(array_square_RR)

        C               :MSTORE(array_square_len_in)
        C + C           :MSTORE(array_square_len_out)

        0               :MSTORE(array_square_chunk_3)     ; initialize the third chunk
        0               :MSTORE(array_square_out_chunk_2) ; initialize the second chunk of out

        0 => RCX,RR     :JMP(array_square_first_iteration_first_row)     ; first and second indexes in loops

; Begin of branching
array_square_loop_index_check:
        ; costs [steps: 7, binary: 0, arith: 0]

        ; out[i + len] = carry
        $ => A          :MLOAD(array_square_carry_chunk_1)
        RCX + B => E
        A               :MSTORE(array_square_out + E)

        $ => A          :MLOAD(array_square_carry_chunk_2)
        A               :MSTORE(array_square_out_chunk_2)

        ; update indices
        RCX + 1 => RCX,RR,A
        B - A           :JMPZ(array_square_prep_trim, array_square_ai_times_ai)
; End of branching

; Begin of first row
array_square_first_iteration_first_row:
        ; costs [steps: 9, binary: 0, arith: 1]

        ; The result will be stored as D·base + C

        ; 1] a[0]·a[0]
        $ => A,B        :MLOAD(array_square_in)
        0 => C
        $${var _arraySquare_a0a0 = A*B}
        ${_arraySquare_a0a0 >> 256} => D
        ${_arraySquare_a0a0} => C :ARITH

        ; carry = product / base
        D               :MSTORE(array_square_carry_chunk_1)

        ; out[0] = product - carry·base
        C               :MSTORE(array_square_out)

        ; update the index
        1 => RR
        $ => B          :MLOAD(array_square_len_in)
        B - RR          :JMPZ(array_square_loop_index_check)

array_square_finish_first_row:
        ; costs [steps: 35, binary: 6, arith: 1]

        ; The result will be stored as D·base + C

        ; 1] a[0]·a[j]
        $ => A          :MLOAD(array_square_in)
        $ => B          :MLOAD(array_square_in + RR)
        0 => C
        $${var _arraySquare_a0a0 = A*B}
        ${_arraySquare_a0a0 >> 256} => D
        ${_arraySquare_a0a0} => C :ARITH
        D              :MSTORE(array_square_aiaj_chunk_2)

        ; 2] 2·a[0]·a[j]
        C => A,B
        $ => C          :ADD, JMPNC(__array_square_no_carry_continue_1)
        ;-----------------
        ; Since here D ∈ [0, base - 2], there cannot be carry in the following addition
        D => A
        1 => B
        $ => D          :ADD
        ;-----------------
                        __array_square_no_carry_continue_1:

        $ => A          :MLOAD(array_square_aiaj_chunk_2)
        D => B
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_2)
        ;-----------------
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_2:

        ; 3] 2·a[0]·a[j] + carry
        C => A
        $ => B          :MLOAD(array_square_carry_chunk_1)
        $ => C          :ADD, JMPNC(__array_square_no_carry_continue_3)
        ;-----------------
        ; Since here D ∈ [0, base - 1], there can be carry in the following addition
        D => A
        1 => B
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_3)
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_3:

        D => A
        $ => B          :MLOAD(array_square_carry_chunk_2)
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_4)
        ;-----------------
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_4:

        ; carry = product / base
        D               :MSTORE(array_square_carry_chunk_1)
        $ => A          :MLOAD(array_square_chunk_3)
        A               :MSTORE(array_square_carry_chunk_2)

        ; out[j] = product - carry·base
        RR => E
        C               :MSTORE(array_square_out + E)
        0               :MSTORE(array_square_chunk_3) ; reset the third chunk

        ; update the index
        RR + 1 => RR
        $ => B          :MLOAD(array_square_len_in)
        B - RR          :JMPZ(array_square_loop_index_check, array_square_finish_first_row)
; End of first row

array_square_ai_times_ai:
        ; costs [steps: 6, binary: 0, arith: 1]

        ; carry = 0 - a[i]·a[i]
        ; a[i]·a[i], where a[i] ∈ [0,base-1]: This number cannot be GT (base - 2)·base + 1, two chunks
        $ => A,B       :MLOAD(array_square_in + RR)
        0 => C
        $${var _arraySquare_aiai = A*B}
        ${_arraySquare_aiai >> 256} => D
        ${_arraySquare_aiai} => C :ARITH
        C               :MSTORE(array_square_carry_chunk_1)
        D               :MSTORE(array_square_carry_chunk_2)

array_square_first_iteration_loopRR2len:
        ; costs [steps: 29, binary: 3, arith: 1]

        ; product = a[i]·a[i] + out[2i] (in the worst case, this is a 3-chunk number)
        ; The result will be stored as array_square_chunk_3·base² + D·base + C

        ; 1] a[i]·a[i]
        $ => A,B        :MLOAD(array_square_in + RR)
        0 => C
        $${var _arraySquare_ai = A*B}
        ${_arraySquare_ai >> 256} => D
        ${_arraySquare_ai} => C :ARITH
        D              :MSTORE(array_square_aiaj_chunk_2)

        ; 3] a[i]·a[i] + out[2i]
        2*RR => E
        $ => A          :MLOAD(array_square_out + E)
        C => B
        $ => C          :ADD, JMPNC(__array_square_no_carry_continue_5)
        ;-----------------
        ; Since here D ∈ [0, base - 1], there can be carry in the following addition
        D => A
        1 => B
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_5)
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_5:

        ; The output can have two chunks only if i == len-1, so we must jump the following block of code if i < len-1
        RR + 1 => A
        $ => B          :MLOAD(array_square_len_in)
        B - A           :JMPNZ(__array_square_no_carry_continue_6)
        ; Add the second output chunk
        $ => A          :MLOAD(array_square_out_chunk_2)
        D => B
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_6)
        ;-----------------
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_6:

        ; carry = product / base
        D               :MSTORE(array_square_carry_chunk_1)
        $ => A          :MLOAD(array_square_chunk_3)
        A               :MSTORE(array_square_carry_chunk_2)

        ; out[i+j] = product - carry·base
        RCX + RR => E
        C               :MSTORE(array_square_out + E)
        0               :MSTORE(array_square_chunk_3) ; reset the third chunk

        ; update the index
        RR + 1 => RR
        $ => B          :MLOAD(array_square_len_in)
        B - RR          :JMPZ(array_square_loop_index_check)

array_square_loopRR2len:
        ; costs [steps: 51, binary: 9, arith: 1]

        ; product = 2·(a[i]·a[j]) + out[i+j] + carry (in the worst case, this is a 3-chunk number)
        ; The result will be stored as array_square_chunk_3·base² + D·base + C

        ; 1] a[i]·a[j], where a[i],a[j] ∈ [0,base-1]: This number cannot be GT (base - 2)·base + 1, two chunks
        RCX => E
        $ => A          :MLOAD(array_square_in + E)
        $ => B          :MLOAD(array_square_in + RR)
        0 => C
        $${var _arraySquare_aiaj = A*B}
        ${_arraySquare_aiaj >> 256} => D
        ${_arraySquare_aiaj} => C :ARITH
        D              :MSTORE(array_square_aiaj_chunk_2)

        ; 2] 2·a[i]·a[j]: This number cannot be GT base² + (base - 4)·base + 2, three chunks
        C => A,B
        $ => C          :ADD, JMPNC(__array_square_no_carry_continue_7)
        ;-----------------
        ; Since here D ∈ [0, base - 2], there cannot be carry in the following addition
        D => A
        1 => B
        $ => D          :ADD
        ;-----------------
                        __array_square_no_carry_continue_7:

        $ => A          :MLOAD(array_square_aiaj_chunk_2)
        D => B
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_8)
        ;-----------------
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_8:

        ; 3] 2·a[i]·a[j] + out[i+j]:
        ;       a) j < len-1:  This number cannot be GT base² + (base - 3)·base + 1, as out[i+j] < base
        ;       b) j == len-1: This number cannot be GT base² + (base - 3)·base + base - 1, as  out[i + len] <= base + (base - 3)
        ; In both cases, three chunks
        RCX + RR => E
        $ => A          :MLOAD(array_square_out + E)
        C => B
        $ => C          :ADD, JMPNC(__array_square_no_carry_continue_9)
        ;-----------------
        ; Since here D ∈ [0, base - 1], there can be carry in the following addition
        D => A
        1 => B
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_9)
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_9:

        ; The output can have two chunks only if j == len-1, so we must jump the following block of code if j < len-1
        RR + 1 => A
        $ => B          :MLOAD(array_square_len_in)
        B - A           :JMPNZ(__array_square_no_carry_continue_10)
        ; Add the second output chunk
        $ => A          :MLOAD(array_square_out_chunk_2)
        D => B
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_10)
        ;-----------------
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_10:

        ; 4] product = 2·a[i]·a[j] + out[i+j] + carry: This number cannot be GT base² + (base - 2)·base, three chunks
        C => A
        $ => B          :MLOAD(array_square_carry_chunk_1)
        $ => C          :ADD, JMPNC(__array_square_no_carry_continue_11)
        ;-----------------
        ; Since here D ∈ [0, base - 1], there can be carry in the following addition
        D => A
        1 => B
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_11)
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_11:

        D => A
        $ => B          :MLOAD(array_square_carry_chunk_2)
        $ => D          :ADD, JMPNC(__array_square_no_carry_continue_12)
        ;-----------------
        1               :MSTORE(array_square_chunk_3)
        ;-----------------
                        __array_square_no_carry_continue_12:

        ; carry = product / base; This number cannot be greater than base + (base - 2)
        D               :MSTORE(array_square_carry_chunk_1)
        $ => A          :MLOAD(array_square_chunk_3)
        A               :MSTORE(array_square_carry_chunk_2)

        ; out[i+j] = product - carry·base;
        RCX + RR => E
        C               :MSTORE(array_square_out + E)
        0               :MSTORE(array_square_chunk_3) ; reset the third chunk

        ; update the index
        RR + 1 => RR
        $ => B          :MLOAD(array_square_len_in)
        B - RR          :JMPZ(array_square_loop_index_check, array_square_loopRR2len)

array_square_prep_trim:
        ; costs [steps: 8, binary: 1, arith: 0]

        $ => C          :MLOAD(array_square_len_out)
        C - 1 => E
        $ => A          :MLOAD(array_square_out + E)

        ; Check whether the last chunk is zero
        ${A == 0}       :JMPNZ(array_square_trim)

        0 => B
        0               :EQ, JMP(array_square_end)

array_square_trim:
        0               :ASSERT
        C - 1           :MSTORE(array_square_len_out)

array_square_end:
        $ => RR         :MLOAD(array_square_RR)
                        :RETURN