;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: len(inB) >= 2
;; POST: out is trimmed
;;
;; array_mul_long:
;;             in:
;;                  · C ∈ [1, 64], the len of inA
;;                  · D ∈ [2, 32], the len of inB
;;                  · inA ∈ [0, 2²⁵⁶ - 1]^C, the first input array
;;                  · inB ∈ [0, 2²⁵⁶ - 1]^D, the second input array
;;
;;          output:
;;                  · out = inA·inB, with len(out) <= C + D
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; WARNING: This function is tailored for checking that a = q·b + r in the array_div_long function.
;;          In can be used for other purposes except for the worst case, i.e. when len(inA) == %ARRAY_MAX_LEN_DOUBLED.
;;          Specifically, there is an implicit assumption that the output len of this function cannot be
;;          greater than %ARRAY_MAX_LEN_DOUBLED, and do not allow to generate the proof in such case.

; code
; --------------------------
; first_iteration_first_row       <-- Compute a[0]·b[0]
; do {
;     finish_first_row            <-- Compute a[0]·b[j] + out[j]
; } while(inB_index_check)        <-- While 0 < j < len(b)
; while(inA_index_check) {        <-- While 0 <  i < len(a)
;       while (inB_index_check) { <-- While 0 <= j < len(b) - 1
;               loop2inB          <-- Compute a[i]·b[j] + out[i+j]
;       }
;      loop2inB_last              <-- Compute a[i]·b[len(b)-1] + out[i+len(b)-1]
; }
; 1] check_carry                  <-- If there is a carry, append it to the result
; 2] trim                         <-- Otherwise, trim the result
; end
; --------------------------

VAR GLOBAL array_mul_long_inA[%ARRAY_MAX_LEN_DOUBLED]
VAR GLOBAL array_mul_long_inB[%ARRAY_MAX_LEN]
VAR GLOBAL array_mul_long_out[%ARRAY_MAX_LEN_DOUBLED] ; This cannot be bigger because we use it for division checking
VAR GLOBAL array_mul_long_len_inA
VAR GLOBAL array_mul_long_len_inB
VAR GLOBAL array_mul_long_len_out

VAR GLOBAL array_mul_long_out_chunk_2

VAR GLOBAL array_mul_long_RR

array_mul_long:
        ; big loop costs (len(inA) - 1)*((len(inB) - 1) * [steps: 21, binary: 2, arith: 1] + [steps: 18, binary: 1, arith: 1])

        %MAX_CNT_ARITH - CNT_ARITH   -  1 -   %ARRAY_MAX_LEN_MINUS_ONE -    %ARRAY_MAX_LEN_TIMES_DOUBLED -    %ARRAY_MAX_LEN_DOUBLED_MINUS_ONE       :JMPN(outOfCountersArith)
        %MAX_CNT_BINARY - CNT_BINARY                                   -  2*%ARRAY_MAX_LEN_TIMES_DOUBLED -    %ARRAY_MAX_LEN_DOUBLED_MINUS_ONE - 1   :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP        - 12 - 9*%ARRAY_MAX_LEN_MINUS_ONE - 21*%ARRAY_MAX_LEN_TIMES_DOUBLED - 18*%ARRAY_MAX_LEN_DOUBLED_MINUS_ONE - 7   :JMPN(outOfCountersStep)

        RR              :MSTORE(array_mul_long_RR)

        C               :MSTORE(array_mul_long_len_inA)
        D               :MSTORE(array_mul_long_len_inB)

        0 => RCX,RR     ; first and second indexes in loops

array_mul_long_first_iteration_first_row:
        ; The result will be stored as D·base + C

        ; a[0]·b[0], where a[0],b[0] ∈ [0,base-1]: This number cannot be GT (base - 1)·base, two chunks
        $ => A          :MLOAD(array_mul_long_inA)
        $ => B          :MLOAD(array_mul_long_inB)
        0 => C
        $${var _arrayLongMul_AB = A*B}
        ${_arrayLongMul_AB >> 256} => D
        ${_arrayLongMul_AB} => C :ARITH

        ; out[0] = product - carry·B
        C               :MSTORE(array_mul_long_out)

        ; out[1] = carry
        1 => RR
        D => C          :MSTORE(array_mul_long_out + RR)

array_mul_long_finish_first_row:
        ; The result will be stored as D·base + C

        ; a[0]·b[j] + out[j], where a[0],b[j],out[j] ∈ [0,base-1]: This number cannot be GT (base - 1)·base, two chunks
        $ => B          :MLOAD(array_mul_long_inB + RR)
        $${var _arrayLongMul_AB = A*B + C}
        ${_arrayLongMul_AB >> 256} => D
        ${_arrayLongMul_AB} => C :ARITH

        ; C = result, D = carry

        ; out[j] = product - carry·B
        C               :MSTORE(array_mul_long_out + RR)

        ; out[j+1] = carry
        RR + 1 => RR,E
        D => C          :MSTORE(array_mul_long_out + RR)

        ; C = D = carry

array_mul_long_inB_index_check:
        $ - RR          :F_MLOAD(array_mul_long_len_inB), JMPNZ(array_mul_long_finish_first_row)

array_mul_long_inA_index_check:
        ; D = carry, E = last_index_out
        $ - RCX - 1     :F_MLOAD(array_mul_long_len_inA), JMPZ(array_mul_long_check_carry)

        RCX + 1 => RCX  ; update the first index
        0 => RR         :MSTORE(array_mul_long_out_chunk_2) ; reset the second index and the out chunk 2

array_mul_long_loop2inB:
        ; costs [steps: 21, binary: 2, arith: 1]

        ; The result will be stored as D·base + C

        RCX => E
        ; a[i]·b[j] + out[i+j], where a[i],b[j],out[i+j] ∈ [0,base-1]: This number cannot be GT (base - 1)·base, two chunks
        $ => A          :MLOAD(array_mul_long_inA + E)
        $ => B          :MLOAD(array_mul_long_inB + RR)
        RCX + RR => E
        $ => C          :MLOAD(array_mul_long_out + E)
        $${var _arrayLongMul_AB = A*B + C}
        ${_arrayLongMul_AB >> 256} => D
        ${_arrayLongMul_AB} => C :ARITH

        $ => A          :MLOAD(array_mul_long_out_chunk_2), JMPZ(__array_mul_long_c2isZ_continue) ; out_chunk_2 ∈ [0,1]
        ;-----------------
        D => B
        $ => D          :ADD ; the number is of two chunks, no carry can be generated here
                        __array_mul_long_c2isZ_continue:
        ;-----------------

        ; NOTE: It cannot happen that a[i]·b[j] + out[i+j] produces carry and out_chunk_2 is 1.

        ; C = result, D = carry

        ; out[i+j] = product - carry·B
        C               :MSTORE(array_mul_long_out + E)

        ; out[i+j+1] += carry, where carry ∈ [0,base-1]: This number cannot be GT base + (base-3), two chunks
        E + 1 => E
        $ => A          :MLOAD(array_mul_long_out + E)
        D => B
        $ => C          :ADD, JMPNC(__array_mul_long_no_carry_continue_2)
        ;-----------------
        1               :MSTORE(array_mul_long_out_chunk_2)
                        :JMP(__array_mul_long_carry_continue)
                        __array_mul_long_no_carry_continue_2:
        0               :MSTORE(array_mul_long_out_chunk_2)
                        __array_mul_long_carry_continue:
        ;-----------------

        ; C = carry

        C               :MSTORE(array_mul_long_out + E)

        RR + 1 => RR
        $ - RR - 1      :F_MLOAD(array_mul_long_len_inB), JMPZ(array_mul_long_loop2inB_last, array_mul_long_loop2inB)

array_mul_long_loop2inB_last:
        ; costs [steps: 13, binary: 1, arith: 1]

        ; The result will be stored as D·base + C

        RCX => E
        ; a[i]·b[lenB] + out[i+lenB], where a[i],b[lenB],out[i+lenB] ∈ [0,base-1]: This number cannot be GT (base - 1)·base, two chunks
        $ => A          :MLOAD(array_mul_long_inA + E)
        $ => B          :MLOAD(array_mul_long_inB + RR)
        RCX + RR => E
        $ => C          :MLOAD(array_mul_long_out + E)
        $${var _arrayLongMul_AB = A*B + C}
        ${_arrayLongMul_AB >> 256} => D
        ${_arrayLongMul_AB} => C :ARITH

        $ => A          :MLOAD(array_mul_long_out_chunk_2), JMPZ(__array_mul_long_c2isZ_continue2) ; out_chunk_2 ∈ [0,1]
        ;-----------------
        D => B
        $ => D          :ADD ; the number is of two chunks, no carry can be generated here
                        __array_mul_long_c2isZ_continue2:
        ;-----------------

        ; NOTE: It cannot happen that a[i]·b[lenB] + out[i+lenB] produces carry and out_chunk_2 is 1.

        ; out[i+lenB] = product - carry·B
        C               :MSTORE(array_mul_long_out + E)

        ; out[i+lenB+1] = carry, where carry ∈ [0,base-1]
        E + 1 => E

        ; D = carry, E = last_index_out

        ; In the exceptional case where we reached the allowed limit, we proceed to the carry check
        E - %ARRAY_MAX_LEN_DOUBLED  :JMPZ(array_mul_long_check_carry)

        D               :MSTORE(array_mul_long_out + E), JMP(array_mul_long_inA_index_check)

array_mul_long_check_carry:
        ; D = carry, E = last_index_out
        D => A
        0 => B
        $               :EQ, JMPC(array_mul_long_trim)

        ; out[E] != 0, then len(out) = E + 1
        E - %ARRAY_MAX_LEN_DOUBLED  :JMPZ(failAssert)

        E + 1           :MSTORE(array_mul_long_len_out), JMP(array_mul_long_end)

array_mul_long_trim:
        ; out[E] = 0, then len(out) = E
        E               :MSTORE(array_mul_long_len_out)

array_mul_long_end:
        $ => RR         :MLOAD(array_mul_long_RR), RETURN