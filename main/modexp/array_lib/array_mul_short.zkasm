;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; POST: out is trimmed
;;
;; array_mul_short:
;;             in:
;;                  · C ∈ [1, 32], the len of inA
;;                  · inA ∈ [0, 2²⁵⁶ - 1]^C, the first input array
;;                  · inB ∈ [0, 2²⁵⁶ - 1], the second input
;;
;;          output:
;;                  · out = inA·inB, with len(out) <= C + 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; code
; --------------------------
; first_iteration           <-- a[0]·b
; while(loop_index_check) { <-- While 0 < i < len(a)
;     loop2inA              <-- Compute a[i]·b + carry
; }
; 1] check_carry            <-- If there is a carry, append it to the result
; 2] trim                   <-- Otherwise, trim the result
; end
; --------------------------

VAR GLOBAL array_mul_short_inA[%ARRAY_MAX_LEN]
VAR GLOBAL array_mul_short_inB
VAR GLOBAL array_mul_short_out[%ARRAY_MAX_LEN_PLUS_ONE]
VAR GLOBAL array_mul_short_len_inA
VAR GLOBAL array_mul_short_len_out

VAR GLOBAL array_mul_short_RR

/*
 * RESOURCES:
 * -----------------------------
 * (worst case) [steps: 10, arith: 1] + (lenA-1)*[steps: 7, arith: 1] + [steps: 7, bin: 1]
 * total: [steps: 10 + 7*lenA, bin: 1, arith: lenA]
 * -----------------------------
 */

array_mul_short:
        %MAX_CNT_ARITH - CNT_ARITH  -   %ARRAY_MAX_LEN       :JMPN(outOfCountersArith)
        %MAX_CNT_BINARY - CNT_BINARY  - 1   :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP       - 10 - 7*%ARRAY_MAX_LEN   :JMPN(outOfCountersStep)

        RR              :MSTORE(array_mul_short_RR)

        C               :MSTORE(array_mul_short_len_inA)

array_mul_short_first_iteration:
        ; The result will be stored as D·base + C

        ; 1] a[0] * b, where a[0],b ∈ [0,base-1]: This number cannot be GT (base - 1)·base, two chunks
        $ => A          :MLOAD(array_mul_short_inA)
        $ => B          :MLOAD(array_mul_short_inB)
        0 => C
        $${var _arrayShortMul_AB = A*B}
        ${_arrayShortMul_AB >> 256} => D ; this is used as the next carry
        ${_arrayShortMul_AB} => C :ARITH

        ; out[0] = product - carry·base
        C               :MSTORE(array_mul_short_out)

        1 => E

array_mul_short_loop_index_check:
        $ - E           :F_MLOAD(array_mul_short_len_inA), JMPZ(array_mul_short_check_carry)

array_mul_short_loop2inA:
        ; The result will be stored as D·base + C

        ; 1] a[i] * b + carry, where a[i],b,carry ∈ [0,base-1]: This number cannot be GT (base - 1)·base, two chunks
        $ => A          :MLOAD(array_mul_short_inA + E)
        D => C
        $${var _arrayShortMul_AB = A*B + C}
        ${_arrayShortMul_AB >> 256} => D ; this is used as the next carr
        ${_arrayShortMul_AB} => C :ARITH

        ; out[i] = product - carry·base
        C               :MSTORE(array_mul_short_out + E)

        E + 1 => E      :JMP(array_mul_short_loop_index_check)

; If the last carry > 0, we need to insert it to the output
array_mul_short_check_carry:
        D => A
        0 => B
        $               :EQ, JMPC(array_mul_short_trim)

        D               :MSTORE(array_mul_short_out + E)
        E + 1           :MSTORE(array_mul_short_len_out), JMP(array_mul_short_end)

array_mul_short_trim:
        E               :MSTORE(array_mul_short_len_out)

array_mul_short_end:
        $ => RR         :MLOAD(array_mul_short_RR)
                        :RETURN