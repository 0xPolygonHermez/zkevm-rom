; TODO: Finish if necessary

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; array_add:
;;             in: 
;;                  · C ∈ [0, 2²⁵⁶ - 1], the len of inA
;;                  · D ∈ [0, 2²⁵⁶ - 1], the len of inB
;;
;;          output: 
;;                  · out = inA - inB, with len(out) <= max(C, D)
;;                  · sign = 0 if inA >= inB, 1 otherwise
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

VAR GLOBAL array_add_inA[300]
VAR GLOBAL array_add_inB[300]
VAR GLOBAL array_add_out[300]
VAR GLOBAL array_add_len_inA
VAR GLOBAL array_add_len_inB
VAR GLOBAL array_add_sign

VAR GLOBAL array_add_RR

array_add:
        RR              :MSTORE(array_add_RR)
        C               :MSTORE(array_add_len_inA)
        D               :MSTORE(array_add_len_inB)

                        :CALL(array_compare)
        $ => C          :MLOAD(array_add_len_inA)
        $ => D          :MLOAD(array_add_len_inB)
        $ => A          :MLOAD(array_compare_result)
        0 => B
        $               :EQ, JMPC(array_add_BGTA_case)

        ; inA >= inB
                        :CALL(array_add_AGTB)
        0               :MSTORE(array_add_sign)
                        :JMP(array_add_end)

array_add_BGTA_case:
                        :CALL(array_add_BGTA)
        1               :MSTORE(array_add_sign)

array_add_end:
        $ => RR         :MLOAD(array_add_RR)
                        :RETURN

INCLUDE "array_add_AGTB.zkasm"