; TODO: Finish if necessary

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; array_sub:
;;             in: 
;;                  · C ∈ [1, 300], the len of inA
;;                  · D ∈ [1, 300], the len of inB
;;
;;          output: 
;;                  · out = inA - inB, with len(out) <= max(C, D)
;;                  · sign = 0 if inA >= inB, 1 otherwise
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

VAR GLOBAL array_sub_inA[300]
VAR GLOBAL array_sub_inB[300]
VAR GLOBAL array_sub_out[300]
VAR GLOBAL array_sub_len_inA
VAR GLOBAL array_sub_len_inB
VAR GLOBAL array_sub_sign

VAR GLOBAL array_sub_RR

array_sub:
        RR              :MSTORE(array_sub_RR)
        C               :MSTORE(array_sub_len_inA)
        D               :MSTORE(array_sub_len_inB)

                        :CALL(array_compare)
        $ => C          :MLOAD(array_sub_len_inA)
        $ => D          :MLOAD(array_sub_len_inB)
        $ => A          :MLOAD(array_compare_result)
        0 => B
        $               :EQ, JMPC(array_sub_BGTA_case)

        ; inA >= inB
                        :CALL(array_sub_AGTB)
        0               :MSTORE(array_sub_sign)
                        :JMP(array_sub_end)

array_sub_BGTA_case:
                        :CALL(array_sub_BGTA)
        1               :MSTORE(array_sub_sign)

array_sub_end:
        $ => RR         :MLOAD(array_sub_RR)
                        :RETURN

INCLUDE "array_sub_AGTB.zkasm"