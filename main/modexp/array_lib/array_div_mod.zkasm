;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; array_div_mod:
;;             in: 
;;                  · C ∈ [1, 300], the len of inA
;;                  · D ∈ [1, 300], the len of inB
;;                  · inA ∈ [0, 2²⁵⁶ - 1]^C, the first input array
;;                  · inB ∈ [0, 2²⁵⁶ - 1]^D, the second input array
;;
;;          output: 
;;                  · [quo,rem] = [inA / inB, inA % inB], with len(quo) <= C - D + 1, len(rem) <= D
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

VAR GLOBAL array_div_mod_inA[300]
VAR GLOBAL array_div_mod_inB[300]
VAR GLOBAL array_div_mod_quo[300]
VAR GLOBAL array_div_mod_rem[300]

VAR GLOBAL array_div_mod_len_inA
VAR GLOBAL array_div_mod_len_inB
VAR GLOBAL array_div_mod_len_quo
VAR GLOBAL array_div_mod_len_rem

VAR GLOBAL array_div_mod_RR

array_div_mod:
        RR              :MSTORE(array_div_mod_RR)
        C               :MSTORE(array_div_mod_len_inA)
        D               :MSTORE(array_div_mod_len_inB)
        0 => RR,E

        D => A
        1 => B
        $               :EQ, JMPC(array_div_mod_inA_to_div_mod_short)

; Long
array_div_mod_inA_to_div_mod_long:
        $ => A          :MLOAD(array_div_mod_inA + RR)
        A               :MSTORE(array_div_mod_long_inA + RR)
        RR + 1 => RR
        RR => A
        C => B
        $               :EQ, JMPC(array_div_mod_inB_to_div_mod_long)
                        :JMP(array_div_mod_inA_to_div_mod_long)

array_div_mod_inB_to_div_mod_long:
        $ => A          :MLOAD(array_div_mod_inB + E)
        A               :MSTORE(array_div_mod_long_inB + E)
        E + 1 => E
        E => A
        D => B
        $               :EQ, JMPC(array_div_mod_compute_long)
                        :JMP(array_div_mod_inB_to_div_mod_long)

array_div_mod_compute_long:
                        :CALL(array_div_mod_long)

        ; If error, return nothing
        1 => A
        $               :EQ, JMPC(array_div_mod_end)

        $ => C          :MLOAD(array_div_mod_long_len_quo)
        $ => D          :MLOAD(array_div_mod_long_len_rem)
        C               :MSTORE(array_div_mod_len_quo)
        D               :MSTORE(array_div_mod_len_rem)
        0 => RR,E
array_div_mod_assign_long_quo:
        $ => A          :MLOAD(array_div_mod_long_quo + RR)
        A               :MSTORE(array_div_mod_quo + RR)
        RR + 1 => RR
        RR => A
        C => B
        $               :EQ, JMPC(array_div_mod_assign_long_rem)
                        :JMP(array_div_mod_assign_long_quo)

array_div_mod_assign_long_rem:
        $ => A          :MLOAD(array_div_mod_long_rem + E)
        A               :MSTORE(array_div_mod_rem + E)
        E + 1 => E
        E => A
        D => B
        $               :EQ, JMPC(array_div_mod_end)
                        :JMP(array_div_mod_assign_long_rem)

; Short
array_div_mod_inA_to_div_mod_short:
        $ => A          :MLOAD(array_div_mod_inA + RR)
        A               :MSTORE(array_div_mod_short_inA + RR)
        RR + 1 => RR
        RR => A
        C => B
        $               :EQ, JMPC(array_div_mod_inB_to_div_mod_short)
                        :JMP(array_div_mod_inA_to_div_mod_short)

array_div_mod_inB_to_div_mod_short:
        $ => A          :MLOAD(array_div_mod_inB)
        A               :MSTORE(array_div_mod_short_inB)

array_div_mod_compute_short:
                        :CALL(array_div_mod_short)

        ; If error, return nothing
        1 => A
        $               :EQ, JMPC(array_div_mod_end)

        $ => C          :MLOAD(array_div_mod_short_len_quo)
        C               :MSTORE(array_div_mod_len_quo)
        1               :MSTORE(array_div_mod_len_rem)
        0 => RR
array_div_mod_assign_short_quo:
        $ => A          :MLOAD(array_div_mod_short_quo + RR)
        A               :MSTORE(array_div_mod_quo + RR)
        RR + 1 => RR
        RR => A
        C => B
        $               :EQ, JMPC(array_div_mod_assign_short_rem)
                        :JMP(array_div_mod_assign_short_quo)

array_div_mod_assign_short_rem:
        $ => A          :MLOAD(array_div_mod_short_rem)
        A               :MSTORE(array_div_mod_rem)

array_div_mod_end:
        $ => RR         :MLOAD(array_div_mod_RR)
                        :RETURN