;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: The input arrays have been trimmed.
;; POST: The remainder is trimmed.
;;
;; array_div_mod_long:
;;             in: 
;;                  · C ∈ [1, 16], the len of inA
;;                  · D ∈ [1, 16], the len of inB
;;                  · inA ∈ [0, 2²⁵⁶ - 1]^C, the first input array
;;                  · inB ∈ [0, 2²⁵⁶ - 1]^D, the second input array
;;
;;          output: 
;;                  · [quo,rem] = [inA / inB, inA % inB], with len(quo) <= C - D + 1, len(rem) <= D
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

; function array_div_mod_long(a: bigint[], b: bigint[], B: bigint): bigint[] {
;     if (a === [0n]) {
;         if (b === [0n]) {
;             throw new Error("Division by zero");
;         }
;         return [0n, 0n];
;     } else if (b === [0n]) {
;         throw new Error("Division by zero");
;     } 
;
;     if (a === b) {
;         return [1n, 0n];
;     } else if (a < b) {
;         return [0n, a];
;     }
; }

; NOTE: This function receives the actual result from the helper (avoiding the need of computing divisions);
;       checks the correctness of the result and returns the result to the caller

VAR GLOBAL array_div_mod_long_inA[16]
VAR GLOBAL array_div_mod_long_inB[16]
VAR GLOBAL array_div_mod_long_quo[16]
VAR GLOBAL array_div_mod_long_rem[16]

VAR GLOBAL array_div_mod_long_len_inA
VAR GLOBAL array_div_mod_long_len_inB
VAR GLOBAL array_div_mod_long_len_quo
VAR GLOBAL array_div_mod_long_len_rem

VAR GLOBAL array_div_mod_long_RR

; ERROR CODES (B)
; 0 - no error
; 1 - inB is zero

array_div_mod_long:
        %MAX_CNT_BINARY - CNT_BINARY - 4  - C   - D       :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP        - 19 - 4*C - 4*D - 1 :JMPN(outOfCountersStep)

        RR              :MSTORE(array_div_mod_long_RR)
        C               :MSTORE(array_div_mod_long_len_inA)
        D               :MSTORE(array_div_mod_long_len_inB)

        ; Let's cover the edge cases
        ; 1] Is C == 1 and inA == 0?
        C => A
        1 => B
        $               :EQ, JMPNC(array_div_mod_long_inA_continue)
        0 => B
        $ => A          :MLOAD(array_div_mod_long_inA)
        $               :EQ, JMPC(array_div_mod_long_inA_is_zero)
                        array_div_mod_long_inA_continue:

        ; 2] Is D == 1 and inB == 0?
        D => A
        1 => B
        $               :EQ, JMPNC(array_div_mod_long_inB_continue1)
        0 => B
        $ => A          :MLOAD(array_div_mod_long_inB)
        $               :EQ, JMPC(array_div_mod_long_inB_is_zero)
                        array_div_mod_long_inB_continue1:

        ; 3] Check if inA = inB or inA < inB
        C => RR
        D => E
array_div_mod_long_compare_inA1:
        RR - 1 => RR
        $ => A          :MLOAD(array_div_mod_long_inA + RR)
        A               :MSTORE(array_compare_inA + RR)
        RR              :JMPZ(array_div_mod_long_compare_inB1, array_div_mod_long_compare_inA1)

array_div_mod_long_compare_inB1:
        E - 1 => E
        $ => A          :MLOAD(array_div_mod_long_inB + E)
        A               :MSTORE(array_compare_inB + E)
        E               :JMPZ(array_div_mod_long_compare1, array_div_mod_long_compare_inB1)

array_div_mod_long_compare1:
                        :CALL(array_compare)

        %MAX_CNT_BINARY - CNT_BINARY - 1     :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP        - 6        :JMPN(outOfCountersStep)

        $ => A          :MLOAD(array_compare_result), JMPZ(array_div_mod_long_prep_inALTinB)
        1 => B     
        $               :EQ, JMPC(array_div_mod_long_same_input)
        ; From here, inA > inB
        
        $${MPdiv(addr.array_div_mod_long_inA,mem.array_div_mod_long_len_inA,addr.array_div_mod_long_inB,mem.array_div_mod_long_len_inB)}

                        :JMP(array_div_mod_long_prepare_trim_rem)

; Begin of edge cases
array_div_mod_long_inA_is_zero:
        ; Is D == 1 and inB == 0? 0/0 is undefined
        D => A
        1 => B
        $               :EQ, JMPNC(array_div_mod_long_inB_continue2)
        0 => B
        $ => A          :MLOAD(array_div_mod_long_inB)
        $               :EQ, JMPC(array_div_mod_long_inB_is_zero)
                        array_div_mod_long_inB_continue2:
        ; From here, inB != 0

        ; Return [q,r] = [0,0] and len(q) = 1, len(r) = 1
        0               :MSTORE(array_div_mod_long_quo)
        0               :MSTORE(array_div_mod_long_rem)
        1               :MSTORE(array_div_mod_long_len_quo)
        1               :MSTORE(array_div_mod_long_len_rem)
        0 => B          :JMP(array_div_mod_long_end)

array_div_mod_long_inB_is_zero:
        ; Error, you cannot divide by 0
        1 => B          :JMP(array_div_mod_long_end)

array_div_mod_long_same_input:
        1               :MSTORE(array_div_mod_long_quo)
        0               :MSTORE(array_div_mod_long_rem)
        1               :MSTORE(array_div_mod_long_len_quo)
        1               :MSTORE(array_div_mod_long_len_rem)
        0 => B          :JMP(array_div_mod_long_end)

array_div_mod_long_prep_inALTinB:
        C               :MSTORE(array_div_mod_long_len_rem)
        1               :MSTORE(array_div_mod_long_len_quo)

        %MAX_CNT_STEPS - STEP  - 1 - 4*C - 2        :JMPN(outOfCountersStep)

        0 => RR

array_div_mod_long_inALTinB:
        $ => A          :MLOAD(array_div_mod_long_inA + RR)
        A               :MSTORE(array_div_mod_long_rem + RR)
        RR + 1 => RR
        C - 1 => C      :JMPNZ(array_div_mod_long_inALTinB)

array_div_mod_long_inALTinB_before_end:
        0               :MSTORE(array_div_mod_long_quo)        
        0 => B          :JMP(array_div_mod_long_end)
; End of edge cases

array_div_mod_long_prepare_trim_rem:
        ${receiveLenRemainder()} => C
        C => RR

        %MAX_CNT_STEPS - STEP - 4*C - 1        :JMPN(outOfCountersStep)

array_div_mod_long_trim_rem_in:
        RR - 1 => RR
        ${receiveRemainderChunk(RR)} => A
        A               :MSTORE(array_trim_in + RR)
        RR              :JMPZ(array_div_mod_long_trim_rem, array_div_mod_long_trim_rem_in)

array_div_mod_long_trim_rem:
                        :CALL(array_trim)

        %MAX_CNT_STEPS - STEP - 6        :JMPN(outOfCountersStep)

        C               :MSTORE(array_div_mod_long_len_rem)

array_div_mod_long_prepare_mul_quo_inB:
        ${receiveLenQuotient()} => C
        C               :MSTORE(array_div_mod_long_len_quo)
        $ => D          :MLOAD(array_div_mod_long_len_inB)
        C => RR
        D => E

        %MAX_CNT_STEPS - STEP - 5*C - 4*D - 1      :JMPN(outOfCountersStep)

array_div_mod_long_quo_to_mul:
        RR - 1 => RR
        ${receiveQuotientChunk(RR)} => A
        A               :MSTORE(array_div_mod_long_quo + RR)
        A               :MSTORE(array_mul_inA + RR)
        RR              :JMPZ(array_div_mod_long_inB_to_mul, array_div_mod_long_quo_to_mul)

array_div_mod_long_inB_to_mul:
        E - 1 => E
        $ => A          :MLOAD(array_div_mod_long_inB + E)
        A               :MSTORE(array_mul_inB + E)
        E               :JMPZ(array_div_mod_long_mul_quo_inB, array_div_mod_long_inB_to_mul)

array_div_mod_long_mul_quo_inB:
                        :CALL(array_mul)

        %MAX_CNT_STEPS - STEP - 5      :JMPN(outOfCountersStep)

        ; prepare next
        $ => C          :MLOAD(array_mul_len_out)
        $ => D          :MLOAD(array_div_mod_long_len_rem)
        C => RR
        D => E

        %MAX_CNT_STEPS - STEP - 4*C - 5*D - 1    :JMPN(outOfCountersStep)

array_div_mod_long_res_to_add:
        RR - 1 => RR
        $ => A          :MLOAD(array_mul_out + RR)
        A               :MSTORE(array_add_AGTB_inA + RR)
        RR              :JMPZ(array_div_mod_long_rem_to_add, array_div_mod_long_res_to_add)

array_div_mod_long_rem_to_add:
        E - 1 => E
        ${receiveRemainderChunk(E)} => A
        A               :MSTORE(array_div_mod_long_rem + E)
        A               :MSTORE(array_add_AGTB_inB + E)
        E               :JMPZ(array_div_mod_long_add_res_rem, array_div_mod_long_rem_to_add)

array_div_mod_long_add_res_rem:
                        :CALL(array_add_AGTB)

        %MAX_CNT_STEPS - STEP - 4      :JMPN(outOfCountersStep)

        ; prepare next
        $ => C           :MLOAD(array_add_AGTB_len_out)
        $ => D           :MLOAD(array_div_mod_long_len_inA)
        C => RR
        D => E

        %MAX_CNT_STEPS - STEP - 4*C - 4*D - 1    :JMPN(outOfCountersStep)

array_div_mod_long_compare_inA2:
        RR - 1 => RR
        $ => A          :MLOAD(array_add_AGTB_out + RR)
        A               :MSTORE(array_compare_inA + RR)
        RR              :JMPZ(array_div_mod_long_compare_inB2, array_div_mod_long_compare_inA2)

array_div_mod_long_compare_inB2:
        E - 1 => E
        $ => A          :MLOAD(array_div_mod_long_inA + E)
        A               :MSTORE(array_compare_inB + E)
        E               :JMPZ(array_div_mod_long_compare2, array_div_mod_long_compare_inB2)

array_div_mod_long_compare2:
                        :CALL(array_compare)

        %MAX_CNT_STEPS - STEP - 4      :JMPN(outOfCountersStep)

        1               :MLOAD(array_compare_result)
        0 => B ; everything worked fine

array_div_mod_long_end:
        $ => RR         :MLOAD(array_div_mod_long_RR)
                        :RETURN