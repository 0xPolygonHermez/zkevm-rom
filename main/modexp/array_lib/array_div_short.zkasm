;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: The input arrays have been trimmed and inB != 0.
;; POST: The quotient is trimmed.
;;
;; array_div_short:
;;             in:
;;                  · C ∈ [1, 32], the len of inA
;;                  · inA ∈ [0, 2²⁵⁶ - 1]^C, the first input array
;;                  · inB ∈ [0, 2²⁵⁶ - 1], the second input
;;
;;          output:
;;                  · [quo,rem] = [inA / inB[0], inA % inB[0]], with len(quo) <= C, len(rem) = 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

VAR GLOBAL array_div_short_inA[%ARRAY_MAX_LEN]
VAR GLOBAL array_div_short_inB
VAR GLOBAL array_div_short_quo[%ARRAY_MAX_LEN]
VAR GLOBAL array_div_short_rem

VAR GLOBAL array_div_short_len_inA
VAR GLOBAL array_div_short_len_quo

VAR GLOBAL array_div_short_RR

/*
 * RESOURCES:
 * -------------------------------------------
 *
 * Worst Path: A != 0, A > B, lenA > 1:
 *             [steps: 4]                                               // compare A and B
 *             + [steps: 11, bin: 1] + (lenQ-1)*[steps: 4] + [steps: 3] // get Q and input Q and B to mul
 *             + [steps: 10 + 7*lenQ, bin: 1, arith: lenQ]              // multiply Q and B
 *             + [steps: 10, bin: 2] + (lenQ+1)*[steps: 3] + [steps: 1] // R and Q·B to add
 *             + [steps: 14 + 6*lenQ, bin: 1 + lenQ]                    // add Q·B and R
 *             + [steps: 3] + lenA*[steps: 3] + [steps: 2]              // compare A and Q·B + R and finish
 * Total: [steps: 57 + 3*lenA + 20*lenQ,
 *           bin: 5 + lenQ,
 *         arith: lenQ]
 * -------------------------------------------
 * where:
 *         R = Remainder of A / B
 *         Q = Quotient of A / B
 *
 * Note: For the total count, we have used the fact that len(Q·B) <= lenQ + 1
 */

array_div_short:
        %MAX_CNT_ARITH - CNT_ARITH        -    %ARRAY_MAX_LEN   :JMPN(outOfCountersArith)
        %MAX_CNT_BINARY - CNT_BINARY -  5 -    %ARRAY_MAX_LEN   :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP        - 57 - 23*%ARRAY_MAX_LEN   :JMPN(outOfCountersStep)

        RR              :MSTORE(array_div_short_RR)

        C               :MSTORE(array_div_short_len_inA)
        C               :MSTORE(array_div_short_len_quo)

        ; Let's cover the edge cases
        ; 1] Is C == 1 and inA == 0?
        C - 1           :JMPNZ(array_div_short_inAGTinB) ; If len(inA) > 1, then we already know that inA > inB
        $ => A          :MLOAD(array_div_short_inA); Here, len(inA) = len(inB) = 1
        0 => B
        $               :EQ, JMPC(array_div_short_inA_is_zero, array_div_short_equal_len)
                        __array_div_short_inA_continue:

        ; 2] Check if inA = inB, inA < inB or inA > inB

array_div_short_equal_len:
        ; Here, C = 1

        ; If the lengths are equal, then we must compare the only chunk
        $0{signedComparison(addr.array_div_short_inA,addr.array_div_short_inB)} => RR :JMPZ(array_div_short_check_same_input)

        ; The function does the following:
        ; --------------------------------
        ; if inA < inB => return -1
        ; if inA > inB => return  1
        ; if inA = inB => return  0
        ; --------------------------------

        RR          :JMPN(array_div_short_check_inALTinB)

        1 - RR      :JMPN(failAssert) ; if 1 < RR ERROR

        ; Ensure that the chunk is higher
        $ => A          :MLOAD(array_div_short_inB)
        $ => B          :MLOAD(array_div_short_inA)
        1               :LT, JMP(array_div_short_inAGTinB)

; Begin of edge cases
array_div_short_inA_is_zero:
        ; Return [q,r] = [0,0] and len(q) = 1, len(r) = 1
        0               :MSTORE(array_div_short_quo)
        0               :MSTORE(array_div_short_rem)
        1               :MSTORE(array_div_short_len_quo), JMP(array_div_short_end)

array_div_short_check_same_input:
        $ => A          :MLOAD(array_div_short_inA)
        A               :MLOAD(array_div_short_inB)

array_div_short_same_input:
        ; If inA = inB, then the result is [1,0] since inA = 1·inB + 0
        1               :MSTORE(array_div_short_quo)
        1               :MSTORE(array_div_short_len_quo)
        0               :MSTORE(array_div_short_rem), JMP(array_div_short_end)

array_div_short_check_inALTinB:
        RR + 1          :JMPN(failAssert) ; if RR < -1 ERROR

        $ => A          :MLOAD(array_div_short_inA)
        $ => B          :MLOAD(array_div_short_inB)
        1               :LT

array_div_short_inALTinB:
        ; If inA < inB, then the result is [0, inA] since inA = 0·inB + inA
        0               :MSTORE(array_div_short_quo)
        1               :MSTORE(array_div_short_len_quo)
        $ => A          :MLOAD(array_div_short_inA)
        A               :MSTORE(array_div_short_rem), JMP(array_div_short_end)
; End of edge cases

array_div_short_inAGTinB:
        ; block: [steps: 11, bin: 1]
        ; From here, inA > inB

        ; Strategy: Divide outside and check the result inside
        $${MPdiv_short(addr.array_div_short_inA,mem.array_div_short_len_inA,mem.array_div_short_inB)}

        $0{receiveLenQuotient_short()} => C ; It cannot be zero because q=0 happens only when inA < inB

        ; 1] The received length must satisfy 1 <= len(Q) <= len(inA)
        C - 1 => RR                     :JMPN(failAssert) ; if len(Q) < 1 ERROR
        $ - C                           :F_MLOAD(array_div_short_len_inA), JMPN(failAssert) ; if len(inA) < len(Q) ERROR

        ; 2] To avoid non-determinism, we must ensure that the quotient is trimmed
        ; i.e., that its last chunk is not 0
        ${receiveQuotientChunk_short(RR)} => A ; It cannot be zero because q=0 happens only when inA < inB
        0 => B
        0               :EQ
        ; From here, the quotient is trimmed

        ; 3] Let's multiply the quotient by inB

        C               :MSTORE(array_div_short_len_quo)
        C - 1 => RR

        ; save the first non-zero chunk of quo
        A               :MSTORE(array_div_short_quo + RR)
        A               :MSTORE(array_mul_short_inA + RR)
        RR - 1 => RR    :JMPN(array_div_short_inB_to_mul)

array_div_short_quo_to_mul:
        ${receiveQuotientChunk_short(RR)} => A
        A               :MSTORE(array_div_short_quo + RR)
        A               :MSTORE(array_mul_short_inA + RR)
        RR - 1 => RR    :JMPN(array_div_short_inB_to_mul, array_div_short_quo_to_mul)

array_div_short_inB_to_mul:
        $ => A          :MLOAD(array_div_short_inB)
        A               :MSTORE(array_mul_short_inB)

array_div_short_mul_quo_inB:
                        :CALL(array_mul_short);  inputs: [array_mul_short_len_inA: C, array_mul_short_inA: array_div_short_quo, array_mul_short_inB: array_div_short_inB]
                                              ; outputs: [array_mul_short_len_out, array_mul_short_out]
        ; block (R != 0): [steps: 10, bin: 1]

        ; w.c. is when rem is not zero

        ; Check the remainder
        ${receiveRemainderChunk_short()} => A

        ${A == 0}       :JMPNZ(array_div_short_rem_is_zero)

        ; Check that the remainder is not zero
        0 => B
        0               :EQ

        ; We must ensure the the remaider is lower than inB
        $ => B          :MLOAD(array_div_short_inB)
        1               :LT

        A               :MSTORE(array_div_short_rem)
        A               :MSTORE(array_add_short_inB)

        $ => C          :MLOAD(array_mul_short_len_out)
        C - 1 => RR
array_div_short_result_to_add:
        $ => A          :MLOAD(array_mul_short_out + RR)
        A               :MSTORE(array_add_short_inA + RR)
        RR - 1 => RR    :JMPN(array_div_short_add_result_rem, array_div_short_result_to_add)

array_div_short_add_result_rem:
                        :CALL(array_add_short) ;  inputs: [array_add_short_len_inA: C, array_add_short_inA: array_mul_short_out, array_add_short_inB: array_div_short_inB]
                                               ; outputs: [array_add_short_len_out, array_add_short_out]

        ; The length of q·b + r must be the same as the input of a
        $ => C          :MLOAD(array_add_short_len_out)
        C               :MLOAD(array_div_short_len_inA)
        C - 1 => RR

; Check that a == q·b + r
array_div_short_check_result_eq_inA1:
        $ => A          :MLOAD(array_add_short_out + RR)
        A               :MLOAD(array_div_short_inA + RR)
        RR - 1 => RR    :JMPN(array_div_short_end, array_div_short_check_result_eq_inA1)


; Path with remainder equal to 0
array_div_short_rem_is_zero:
        0               :ASSERT, MSTORE(array_div_short_rem)

        ; The length of q·b must be the same as the input of a
        $ => C          :MLOAD(array_div_short_len_inA)
        C               :MLOAD(array_mul_short_len_out)

        ; Check that a == q·b + 0
        C - 1 => RR
array_div_short_check_result_eq_inA2:
        $ => A          :MLOAD(array_mul_short_out + RR)
        A               :MLOAD(array_div_short_inA + RR)
        RR - 1 => RR    :JMPN(array_div_short_end, array_div_short_check_result_eq_inA2)

array_div_short_end:
        $ => RR         :MLOAD(array_div_short_RR)
                        :RETURN