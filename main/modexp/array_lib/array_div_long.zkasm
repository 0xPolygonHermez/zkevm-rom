;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: The input arrays have been trimmed, len(inB) >= 2 and therefore inB != 0
;; POST: The quotient and remainder are trimmed.
;;
;; array_div_long:
;;             in:
;;                  · C ∈ [1, 64], the len of inA
;;                  · D ∈ [2, 32], the len of inB
;;                  · inA ∈ [0, 2²⁵⁶ - 1]^C, the first input array
;;                  · inB ∈ [0, 2²⁵⁶ - 1]^D, the second input array
;;
;;          output:
;;                  · [quo,rem] = [inA / inB, inA % inB], with len(quo) <= C - D + 1, len(rem) <= D
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; code
; --------------------------
; // Edge cases
; if (C == 1) {
;   if (inA == 0) {
;     inA_is_zero         <-- return [0, 0]
;   } else {
;     prep_inALTinB       <-- len(q) = 1, len(r) = len(inA)
;     inALTinB            <-- return [0, inA]
;   }
; }
;
; inA_not_zero_two_chunks <-- check whether inA = inB, inA < inB or inA > inB
; if (C < D) {
;   prep_inALTinB         <-- len(q) = 1, len(r) = len(inA)
;   inALTinB              <-- return [0, inA]
; } else if (C > D) ----------------------------------------------------------┐
;                                                                             |
; if (inA == inB (*)) {                                                       │
;   check_inAEQinB        <-- check inA[i] == inB[i] for i in [0, len(inA))   │
;   inAEQinB              <-- return [1, 0]                                   │
; } else if (inA < inB) {                                                     │
;   return [0, inA]                                                           │
; }                                                                           │
;                                                                             │
; inAGTinB   <----------------------------------------------------------------┘
; quo_to_mul
; inB_to_mul
; mul_quo_inB
;   1]
;   compare_rem
;   compare_rem_first
;   rem_to_add
;   mul_out_to_add
;   add_mul_out_rem
;   check_rem_not_zero
;   2]
;   rem_is_zero
;   check_rem_is_zero
; end
; --------------------------
; (*) This means the condition is trustless, so it must be checked

VAR GLOBAL array_div_long_inA[%ARRAY_MAX_LEN_DOUBLED]
VAR GLOBAL array_div_long_inB[%ARRAY_MAX_LEN]
VAR GLOBAL array_div_long_quo[%ARRAY_MAX_LEN_DOUBLED_MINUS_ONE]
VAR GLOBAL array_div_long_rem[%ARRAY_MAX_LEN]

VAR GLOBAL array_div_long_len_inA
VAR GLOBAL array_div_long_len_inB
VAR GLOBAL array_div_long_len_quo
VAR GLOBAL array_div_long_len_rem

VAR GLOBAL array_div_long_RR

/*
 * RESOURCES:
 * -------------------------------------------
 *
 * Worst Path: A != 0, A > B, len(A) == len(B) and len(R) == len(B):
 *             [steps: 14, bin: 1] + (len(A)-1)*[steps: 4] +                                                                                                     // compare A and B
 *             + [steps: 15, bin: 1] + (len(Q)-1)*[steps: 4] + len(B)*[steps: 3] + [steps: 1]                                                                    // get Q and input Q and B to mul
 *             + [steps: 15 + 14*len(Q) + 7*len(B) + 19*len(Q)*(len(B)-1), bin: 1 + len(Q) + 2*len(Q)*(len(B)-1), arith: len(Q) + len(B) + 19*len(Q)*(len(B)-1)] // multiply Q and B
 *             + [steps: 14, bin: 1] + (len(R)-1)*[steps: 5] + [steps: 4] + len(Q·B)*[steps: 3] + [steps: 1]                                                     // R and Q·B to add
 *             + [steps: 8 + 6*len(Q·B) + 4*len(B), bin: len(Q·B) + len(B) - 2]                                                                                  // add Q·B and R
 *             + [steps: 3] + len(A)*[steps: 3] + [steps: 2]                                                                                                     // compare A and Q·B + R and finish
 * Total: [steps: 64 + 7*len(A) + 23*len(B) + 8*len(Q) + 5*len(R) + 19*len(Q)*len(B),
 *           bin: 2 + 2*len(B) + 2*len(Q)*len(B),
 *         arith: len(B) - 18*len(Q) + 19*len(Q)*len(B)]
 * -------------------------------------------
 * where:
 *         R = Remainder of A / B
 *         Q = Quotient of A / B
 *
 * Note: For the total count, we have used the fact that len(Q·B) <= len(Q) + len(B)
 */

array_div_long:
        ; w.c. until array_mul_long is when inA > inB and len(inA) == len(inB)

        %MAX_CNT_BINARY - CNT_BINARY - 2                                                              :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP        - 24 - 4*%ARRAY_MAX_LEN_DOUBLED_MINUS_ONE - 3*%ARRAY_MAX_LEN - 1 :JMPN(outOfCountersStep) ; till array_mul_long

        RR              :MSTORE(array_div_long_RR)

        C               :MSTORE(array_div_long_len_inA)
        D               :MSTORE(array_div_long_len_inB)

        ; Let's cover the edge cases
        ; 1] Is C == 1 and inA == 0?
        C - 1           :JMPNZ(array_div_long_inA_not_zero_two_chunks)
        $ => A          :MLOAD(array_div_long_inA) ; Here, len(inA) = 1 and len(inB) >= 2
        0 => B
        $               :EQ, JMPC(array_div_long_inA_is_zero, array_div_long_prep_inALTinB)

array_div_long_inA_not_zero_two_chunks:
        ; 2] Check if inA = inB, inA < inB or inA > inB

        ; Start by comparing the lengths of the arrays
        C - D           :JMPN(array_div_long_prep_inALTinB)
        D - C           :JMPN(array_div_long_inAGTinB)
        ; Here, C = D

        ; If the lengths are equal, then we must compare them chunk by chunk

        ; Get the first different chunk and check that is between -len(inA) and len(inA)
        $0{signedComparison(addr.array_div_long_inA,addr.array_div_long_inB,mem.array_div_long_len_inA)} => RR :JMPZ(array_div_long_check_inAEQinB)

        ; The function does the following:
        ; --------------------------------
        ; if inA < inB => return -i-1
        ; if inA > inB => return  i+1
        ; if inA = inB => return  0
        ; --------------------------------
        ; where i is the first different chunk from 0 to len(inA)

        RR          :JMPN(array_div_long_check_inALTinB)

        C - RR      :JMPN(failAssert) ; if C < RR ERROR

        RR - 1 => RR ; Moving from i+1 to i
        ; Ensure the received chunk is higher
        $ => A          :MLOAD(array_div_long_inB + RR)
        $ => B          :MLOAD(array_div_long_inA + RR)
        1               :LT

        ; Now, we must check that the previous chunks are all equal
        C - 1 => E ; [steps: 14, bin: 1]
array_div_long_check_inAGTinB_loop:
        E - RR          :JMPZ(array_div_long_inAGTinB)
        $ => A          :MLOAD(array_div_long_inA + E)
        A               :MLOAD(array_div_long_inB + E)
        E - 1 => E      :JMP(array_div_long_check_inAGTinB_loop)

; Begin of edge cases
array_div_long_inA_is_zero:
        ; Return [q,r] = [0,0] and len(q) = 1, len(r) = 1
        0               :MSTORE(array_div_long_quo)
        0               :MSTORE(array_div_long_rem)
        1               :MSTORE(array_div_long_len_quo)
        1               :MSTORE(array_div_long_len_rem), JMP(array_div_long_end)

array_div_long_check_inAEQinB:
        C - 1 => RR
array_div_long_check_loop:
        $ => A          :MLOAD(array_div_long_inA + RR)
        A               :MLOAD(array_div_long_inB + RR)
        RR - 1 => RR    :JMPN(array_div_long_inAEQinB, array_div_long_check_loop)

array_div_long_inAEQinB:
        ; if inA = inB, then return [1, 0] and len(q) = 1, len(r) = 1
        1               :MSTORE(array_div_long_quo)
        0               :MSTORE(array_div_long_rem)
        1               :MSTORE(array_div_long_len_quo)
        1               :MSTORE(array_div_long_len_rem), JMP(array_div_long_end)

array_div_long_check_inALTinB:
        RR + C          :JMPN(failAssert) ; if RR < -C ERROR

        -RR - 1 => RR  ; Moving from -i-1 to i
        ; Ensure that the received chunk is lower
        $ => A          :MLOAD(array_div_long_inA + RR)
        $ => B          :MLOAD(array_div_long_inB + RR)
        1               :LT

        ; Now, we must check that the above chunks are all equal, unless there are none
        C - 1 => E
array_div_long_check_inALTinB_loop:
        E - RR          :JMPZ(array_div_long_prep_inALTinB)
        $ => A          :MLOAD(array_div_long_inA + E)
        A               :MLOAD(array_div_long_inB + E)
        E - 1 => E      :JMP(array_div_long_check_inALTinB_loop)

array_div_long_prep_inALTinB:
        ; if inA < inB, then return [0, inA] and len(q) = 1, len(r) = len(inA)
        0               :MSTORE(array_div_long_quo)
        1               :MSTORE(array_div_long_len_quo)
        C               :MSTORE(array_div_long_len_rem)
        C - 1 => RR
array_div_long_inALTinB:
        $ => A          :MLOAD(array_div_long_inA + RR)
        A               :MSTORE(array_div_long_rem + RR)
        RR - 1 => RR    :JMPN(array_div_long_end, array_div_long_inALTinB)
; End of edge cases

array_div_long_inAGTinB:
        ; block: [steps: 15, bin: 1]
        ; From here, inA > inB

        ; Strategy: Divide outside and check the result inside
        $${MPdiv(addr.array_div_long_inA,mem.array_div_long_len_inA,addr.array_div_long_inB,mem.array_div_long_len_inB)}

        $0{receiveLenQuotient()} => C ; It cannot be zero because q=0 happens only when inA < inB

        ; 1] len(Q) + len(inB) - 1 <= len(Q·inB) <= len(Q) + len(inB) (generic for multiplication of two integers)
        ; 2] 1 <= len(R) <= len(inB)
        ;               inA = Q·inB + R
        ; max{len(Q·inB),len(R)} <= len(inA)
        ; len(Q) + len(inB) - 1 <= len(Q·inB) <= len(inA)

        ; 1] The received length must satisfy 1 <= len(Q) <= len(inA) - len(inB) + 1
        C - 1 => RR                             :JMPN(failAssert) ; if len(Q) < 1 ERROR
        $ => A                                  :MLOAD(array_div_long_len_inA)
        $ => B                                  :MLOAD(array_div_long_len_inB)
        A - B + 1 - C                           :JMPN(failAssert) ; if len(inA) - len(inB) + 1 < len(Q) ERROR

        ; 2] To avoid non-determinism, we must ensure that the quotient is trimmed
        ; i.e., that its last chunk is not 0
        ${receiveQuotientChunk(RR)} => A ; It cannot be zero because q=0 happens only when inA < inB
        0 => B
        0               :EQ
        ; From here, the quotient is trimmed

        ; 3] Let's multiply the quotient by inB

        C               :MSTORE(array_div_long_len_quo)
        $ => D          :MLOAD(array_div_long_len_inB)
        C - 1 => RR
        D - 1 => E

        ; save the first non-zero chunk of quo
        A               :MSTORE(array_div_long_quo + RR)
        A               :MSTORE(array_mul_long_inA + RR)
        RR - 1 => RR    :JMPN(array_div_long_inB_to_mul)

array_div_long_quo_to_mul:
        ${receiveQuotientChunk(RR)} => A
        A               :MSTORE(array_div_long_quo + RR)
        A               :MSTORE(array_mul_long_inA + RR)
        RR - 1 => RR    :JMPN(array_div_long_inB_to_mul, array_div_long_quo_to_mul)

array_div_long_inB_to_mul:
        $ => A          :MLOAD(array_div_long_inB + E)
        A               :MSTORE(array_mul_long_inB + E)
        E - 1 => E      :JMPN(array_div_long_mul_quo_inB, array_div_long_inB_to_mul)

array_div_long_mul_quo_inB:
                        :CALL(array_mul_long) ;  inputs: [array_mul_long_len_inA: C, array_mul_long_len_inB: D, array_mul_long_inA: array_div_long_quo, array_mul_long_inB: array_div_long_inB]
                                              ; outputs: [array_mul_long_len_out, array_mul_long_out]
        ; block (R != 0 and len(R) == len(B)): [steps: 14, bin: 1]

        ; w.c. is when rem is not zero
        %MAX_CNT_BINARY - CNT_BINARY - 1                               - 1                                    :JMPN(outOfCountersBinary)
        %MAX_CNT_STEPS - STEP        - 14 - 5*%ARRAY_MAX_LEN_MINUS_ONE - 2 - 3 - 3*%ARRAY_MAX_LEN_DOUBLED - 1 :JMPN(outOfCountersStep) ; till array_add_AGTB

        ; Check the remainder
        $0{receiveLenRemainder()} => D          :JMPZ(array_div_long_rem_is_zero)

        ; 1] The received length must satisfy 1 <= len(R) <= len(inB) <= len(inA)
        D - 1 => E              :JMPN(failAssert) ; if len(R) < 1 ERROR
        $ => C                  :MLOAD(array_div_long_len_inB)
        C - D                   :JMPN(failAssert) ; if len(inB) < len(R) ERROR

        ; 2] To avoid non-determinism, we must ensure that the remainder is trimmed
        ; i.e., that its last chunk is not 0
        ${receiveRemainderChunk(E)} => A
        0 => B
        0               :EQ
        ; From here, the remainder is trimmed

        ; 3] Moreover, we must ensure that the remainder is lower than inB

        ; save the expected length of the remainder and the associated chunk
        D               :MSTORE(array_div_long_len_rem)
        A               :MSTORE(array_div_long_rem + E)
        A               :MSTORE(array_add_AGTB_inB + E)

        ; If len(R) < len(B), then we are done
        D - C           :JMPN(array_div_long_rem_to_add)

        ; If len(R) == len(B), then we must compare them chunk by chunk
        ${getFirstDiffChunkRem(addr.array_div_long_inB,mem.array_div_long_len_inB)} => RR :JMPN(failAssert)
        D - 1 - RR      :JMPN(failAssert) ; if D - 1 < RR ERROR

        ; if it is the last chunk, then we are done
        E - RR          :JMPZ(array_div_long_compare_rem_first)

array_div_long_compare_rem:
        A                                :MLOAD(array_div_long_inB + E)
        E - 1 => E
        ${receiveRemainderChunk(E)} => A :MSTORE(array_div_long_rem + E)
        A                                :MSTORE(array_add_AGTB_inB + E)
        E - RR                           :JMPNZ(array_div_long_compare_rem)

array_div_long_compare_rem_first:
        $ => B          :MLOAD(array_div_long_inB + E)
        1               :LT

array_div_long_rem_to_add:
        ; From here, we have checked that the R < inB
        ; Introduce the remaining rem chunks to the addition
        E - 1 => E                       :JMPN(array_div_long_add_check)
        ${receiveRemainderChunk(E)} => A :MSTORE(array_div_long_rem + E)
        A                                :MSTORE(array_add_AGTB_inB + E)
        E                                :JMPNZ(array_div_long_rem_to_add)

array_div_long_add_check:

        ; 4] Let's add the remainder to the multiplication result

        $ => C          :MLOAD(array_mul_long_len_out)
        C - 1 => RR
array_div_long_mul_out_to_add:
        $ => A          :MLOAD(array_mul_long_out + RR)
        A               :MSTORE(array_add_AGTB_inA + RR)
        RR - 1 => RR    :JMPN(array_div_long_add_mul_out_rem, array_div_long_mul_out_to_add)

array_div_long_add_mul_out_rem:
                        :CALL(array_add_AGTB) ;  inputs: [array_add_AGTB_len_inA: C, array_add_AGTB_len_inB: D, array_add_AGTB_inA: array_mul_long_out, array_add_AGTB_inB: array_div_long_rem]
                                              ; outputs: [array_add_AGTB_len_out, array_add_AGTB_out]

        %MAX_CNT_STEPS - STEP - 3 - 3*%ARRAY_MAX_LEN_DOUBLED - 2 :JMPN(outOfCountersStep)

        ; The length of q·b + r must be the same as the input of a
        $ => C          :MLOAD(array_add_AGTB_len_out)
        C               :MLOAD(array_div_long_len_inA)
        C - 1 => RR

; Check that a == q·b + r
array_div_long_check_rem_not_zero:
        $ => A          :MLOAD(array_add_AGTB_out + RR)
        A               :MLOAD(array_div_long_inA + RR)
        RR - 1 => RR    :JMPN(array_div_long_end, array_div_long_check_rem_not_zero)

; Path with remainder equal to 0
array_div_long_rem_is_zero:
        1               :MSTORE(array_div_long_len_rem)
        0               :MSTORE(array_div_long_rem)

        ; The length of q·b must be the same as the input of a
        $ => C          :MLOAD(array_div_long_len_inA)
        C               :MLOAD(array_mul_long_len_out)

        ; Check that a == q·b + 0
        C - 1 => RR
array_div_long_check_rem_is_zero:
        $ => A          :MLOAD(array_mul_long_out + RR)
        A               :MLOAD(array_div_long_inA + RR)
        RR - 1 => RR    :JMPN(array_div_long_end, array_div_long_check_rem_is_zero)

array_div_long_end:
        $ => RR         :MLOAD(array_div_long_RR)
                        :RETURN