; constants needed by executor C++
CONST %N = 2**19
CONST %MAX_CNT_STEPS_LIMIT = %N
CONST %MAX_CNT_ARITH_LIMIT = %N
CONST %MAX_CNT_BINARY_LIMIT = %N
CONST %MAX_CNT_MEM_ALIGN_LIMIT = %N
CONST %MAX_CNT_KECCAK_F_LIMIT = %N
CONST %MAX_CNT_PADDING_PG_LIMIT = %N
CONST %MAX_CNT_POSEIDON_G_LIMIT = %N

VAR GLOBAL lastHashKId
VAR GLOBAL lastHashPId

VAR GLOBAL initial_A
VAR GLOBAL initial_B
VAR GLOBAL initial_C
VAR GLOBAL initial_D
VAR GLOBAL initial_E
VAR GLOBAL initial_CTX
VAR GLOBAL initial_SP
VAR GLOBAL initial_PC
VAR GLOBAL initial_GAS
VAR GLOBAL initial_SR
VAR GLOBAL initial_RR
VAR GLOBAL initial_HASHPOS
VAR GLOBAL initial_RCX

VAR GLOBAL modexp_Bnchunks
VAR GLOBAL modexp_Mnchunks
VAR GLOBAL modexp_B[20]
VAR GLOBAL modexp_M[20]

VAR GLOBAL inA[5]
VAR GLOBAL inB[3]
VAR GLOBAL out[6]
VAR GLOBAL quo[10]
VAR GLOBAL inAn[10]
VAR GLOBAL rem[3]

start:

        STEP => A
        0 :ASSERT

        A           :MSTORE(initial_A)
        B           :MSTORE(initial_B)
        C           :MSTORE(initial_C)
        D           :MSTORE(initial_D)
        E           :MSTORE(initial_E)
        CTX         :MSTORE(initial_CTX)
        SP          :MSTORE(initial_SP)
        PC          :MSTORE(initial_PC)
        GAS         :MSTORE(initial_GAS)
        SR          :MSTORE(initial_SR)
        RR          :MSTORE(initial_RR)
        HASHPOS     :MSTORE(initial_HASHPOS)
        RCX         :MSTORE(initial_RCX)
        0 => A,B,C,D,E,CTX, SP, PC, GAS, SR, RR, HASHPOS, RCX

        -1          :MSTORE(lastHashKId)
        -1          :MSTORE(lastHashPId)


        ; array div mod short
        ; 1] len(inB) = len(inA) and inB > inA
        4 => C
        2n              :MSTORE(inA)
        1 => E
        1n              :MSTORE(inA + E)
        2 => E
        1n              :MSTORE(inA + E)
        3 => E
        1n              :MSTORE(inA + E)
        3n              :MSTORE(inB)
                        :CALL(array_div_mod_short)
        0n                :MLOAD(quo)
        1 => E
        77194726158210796949047323339125271902179989777093709359638389338608753093291n                :MLOAD(quo + E)
        2 => E
        38597363079105398474523661669562635951089994888546854679819194669304376546645n                :MLOAD(quo + E)
        2n                :MLOAD(rem)

        ; array div mod long
        ; 1] inA = 1Â·2**256 + 2, inB = 10
        ; 2 => C
        ; 1 => D
        ; 2n              :MSTORE(inA)
        ; 1 => E
        ; 1n              :MSTORE(inA + E)
        ; 10n             :MSTORE(inB)
        ;                 :CALL(array_div_mod_long)

end:

        $ => A           :MLOAD(initial_A)
        $ => B           :MLOAD(initial_B)
        $ => C           :MLOAD(initial_C)
        $ => D           :MLOAD(initial_D)
        $ => E           :MLOAD(initial_E)
        $ => CTX         :MLOAD(initial_CTX)
        $ => SP          :MLOAD(initial_SP)
        $ => PC          :MLOAD(initial_PC)
        $ => GAS         :MLOAD(initial_GAS)
        $ => SR          :MLOAD(initial_SR)
        $ => RR          :MLOAD(initial_RR)
        $ => HASHPOS     :MLOAD(initial_HASHPOS)
        $ => RCX         :MLOAD(initial_RCX)

; label finalizeExecution needed by executor C++
finalizeExecution:
        ${beforeLast()}  : JMPN(finalizeExecution)

                         : JMP(start)
opINVALID:
; label checkAndSaveFrom needed by executor C++
checkAndSaveFrom:
                         :JMP(opINVALID)

INCLUDE "array_div_mod_short.zkasm"
INCLUDE "array_div_mod_long.zkasm"