;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; array_square:
;;             in: 
;;                  · C ∈ [0, 2²⁵⁶ - 1], the len of inA
;;
;;          output: 
;;                  · out = inA², with len(out) = 2·C
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

VAR GLOBAL array_square_len_inA
VAR GLOBAL array_square_carry

VAR GLOBAL array_square_im1
VAR GLOBAL array_square_im2
VAR GLOBAL array_square_im3

VAR GLOBAL array_square_RR

array_square:
        RR              :MSTORE(array_square_RR)
        C               :MSTORE(array_square_len_inA)
        0n => RCX   ; first index in loops
        0n => RR ; second index in loops
                        :JMP(array_square_loopZero2inA)

array_square_add_carry_1:
        D + 1n => D
                        :JMP(return_array_square_add_carry_1)

array_square_add_carry_2:
        1n => C
                        :JMP(return_array_square_add_carry_2)

array_square_add_carry_3:
        D + 1n => D
                        :JMP(return_array_square_add_carry_3)

array_square_loop_index_check:
        ; out[i + len] = carry;
        $ => A          :MLOAD(array_square_carry)
        $ => B          :MLOAD(array_square_len_inA)
        RCX + B => E
        A                 :MSTORE(out + E)

        ; update indices
        RCX + 1n => RCX
        RCX => RR

        RCX => A
        ; $ => B          :MLOAD(array_square_len_inA)
        $               :EQ, JMPC(array_square_end)
                        :JMP(return_array_square_loop_index_check)

array_square_loopZero2inA:
        RCX => E
        ; product = 2·(a_i·a_j) + out[i + j] - a_i·a_i = a_i·(2·a_j - a_i) + out[i + j]
        ; carry = product / B;

        ; 1] 2·a_j: This number cannot be GT base + (base - 2), two chunks
        $ => A,B        :MLOAD(inA + RR)

        ; 1] a_i·a_j: This number cannot be GT (base - 2)·base + 1, so it can be represented in two chunks
        $ => A          :MLOAD(inA + E)
        $ => B          :MLOAD(inA + RR)
        0n => C
        $${var _arrayLongMul_AB = A*B}    
        ${_arrayLongMul_AB >> 256} => D
        ${_arrayLongMul_AB} => E :ARITH

        ; 2] 2·a_i·a_j: This number cannot be GT base² + (base - 4)·base + 2, three chunks
        E => A,B
        $ => E          :ADD, JMPC(array_square_add_carry_1)
                        return_array_square_add_carry_1:
        D => A,B 
        $ => E          :ADD ; Here, we do not handle the carry because if it exists it will be erased in step 4
        ; $ => E          :ADD, JMPC(array_square_add_carry_2)
        ;                 return_array_square_add_carry_2:

        ; 3] 2·a_i·a_j + out[i + j]: This number cannot be GT base² + (base - 3)·base + 1, three chunks
        RR + RCX => RR
        $ => A         :MLOAD(out + RR)
        E => B
        $ => E          :ADD, JMPC(array_square_add_carry_3)
                        return_array_square_add_carry_3:

        ; 4] 2·a_i·a_j + out[i + j] - a_i·a_i: This number cannot be GT (base - 2)·base + 1, three chunks
        ; TODO: Do it before!
        $ => A          :MLOAD(inA + E)
        $ => B          :MLOAD(inA + RCX)
        0n => C
        $${var _arrayLongMul_AB = A*B}
        ${_arrayLongMul_AB >> 256} => D
        ${_arrayLongMul_AB} => E :ARITH

        ; out[i + j] = product - carry·B;
        E => A
        RCX + RR => E
        $ => B          :MLOAD(out + E)
        $ => C          :ADD, JMPC(array_square_add_carry)
                        return_array_square_add_carry:
        C               :MSTORE(out + E)
        D               :MSTORE(array_square_carry)

        RR + 1n => RR
        RR => A
        $ => B          :MLOAD(array_square_len_inA)
        $               :EQ, JMPC(array_square_loop_index_check)
                        return_array_square_loop_index_check:
                        :JMP(array_square_loopZero2inA)

array_square_end:
        $ => RR         :MLOAD(array_square_RR)
                        :RETURN