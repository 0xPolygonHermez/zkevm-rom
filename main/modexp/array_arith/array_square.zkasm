;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; array_square:
;;             in: 
;;                  · C ∈ [0, 2²⁵⁶ - 1], the len of in
;;                  · in ∈ [0, 2²⁵⁶ - 1]^C, the input array
;;
;;          output: 
;;                  · out = in², with len(out) <= 2·C
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

VAR GLOBAL array_square_in[300]
VAR GLOBAL array_square_out[600]
VAR GLOBAL array_square_len_in

VAR GLOBAL array_square_carry_high
VAR GLOBAL array_square_carry_low
VAR GLOBAL array_square_aiaj_high

VAR GLOBAL array_square_RR

array_square:
        RR              :MSTORE(array_square_RR)
        C               :MSTORE(array_square_len_in)
        0n => RCX   ; first index in loops
        0n => RR ; second index in loops

        ; 1] a_i·a_i: This number cannot be GT (base - 2)·base + 1, two chunks
        $ => A          :MLOAD(array_square_in)
        A => B
        0n => C
        $${var _arraySquare_aiai = A*B}    
        ${_arraySquare_aiai >> 256} => D
        ${_arraySquare_aiai} => E :ARITH
        D               :MSTORE(array_square_carry_high)
        E               :MSTORE(array_square_carry_low)

                        :JMP(array_square_loopZero2inA)

array_square_add_carry_1:
        D + 1n => D
                        :JMP(return_array_square_add_carry_1)
array_square_add_carry_2:
        D + 1n => D
                        :JMP(return_array_square_add_carry_2)

array_square_sub_carry_1:
        D => A
        1n => B
        $ => D          :SUB ; I don't need to care about the carry
                        :JMP(return_array_square_sub_carry_1)

array_square_loop_index_check:
        ; out[i + len] = carry;
        $ => A          :MLOAD(array_square_carry_low)
        $ => B          :MLOAD(array_square_len_in)
        RCX + B => E
        A                 :MSTORE(array_square_out + E)

        ; update indices
        RCX + 1n => RCX
        RCX => RR

        RCX => A
        $               :EQ, JMPC(array_square_end)

        ; a_i·a_i: This number cannot be GT (base - 2)·base + 1, two chunks
        $ => A          :MLOAD(array_square_in + RR)
        A => B
        0n => C
        $${var _arraySquare_aiai = A*B}    
        ${_arraySquare_aiai >> 256} => D
        ${_arraySquare_aiai} => E :ARITH
        D               :MSTORE(array_square_carry_high)
        E               :MSTORE(array_square_carry_low)

                        :JMP(return_array_square_loop_index_check)

array_square_loopZero2inA:
        RCX => E
        ; carry = 0 - a_i·a_i
        ; product = 2·(a_i·a_j) + out[i + j] + carry
        ; carry = product / B;
        
        ; 1] a_i·a_j: This number cannot be GT (base - 2)·base + 1, two chunks
        $ => A          :MLOAD(array_square_in + E)
        $ => B          :MLOAD(array_square_in + RR)
        0n => C
        $${var _arraySquare_aiaj = A*B}    
        ${_arraySquare_aiaj >> 256} => D
        ${_arraySquare_aiaj} => E :ARITH
        D              :MSTORE(array_square_aiaj_high)

        ; 2] 2·a_i·a_j: This number cannot be GT base² + (base - 4)·base + 2, three chunks
        E => A,B
        $ => C          :ADD, JMPC(array_square_add_carry_1)
                        return_array_square_add_carry_1:
        $ => A          :MLOAD(array_square_aiaj_high)
        D => B 
        $ => D          :ADD ; I don't need to care about the highest carry

        ; 3] 2·a_i·a_j + out[i + j]: This number cannot be GT base² + (base - 3)·base + 1, three chunks
        RR + RCX => E
        $ => A         :MLOAD(array_square_out + E)
        C => B
        $ => C          :ADD, JMPC(array_square_add_carry_2)
                        return_array_square_add_carry_2:

        ; 4] 2·a_i·a_j + out[i + j] - carry: This number cannot be GT (base - 2)·base + 1, two chunks
        C => A
        $ => B          :MLOAD(array_square_carry_low)
        $ => C          :SUB, JMPC(array_square_sub_carry_1)
                        return_array_square_sub_carry_1:
        D => A
        $ => B          :MLOAD(array_square_carry_high)
        $ => D          :SUB; I don't need to care about the highest carry either

        ; carry
        D               :MSTORE(array_square_carry_low)
        0n              :MSTORE(array_square_carry_high)

        ; out[i + j] = product - carry·B;
        RCX + RR => E
        C               :MSTORE(array_square_out + E)

        RR + 1n => RR
        RR => A
        $ => B          :MLOAD(array_square_len_in)
        $               :EQ, JMPC(array_square_loop_index_check)
                        return_array_square_loop_index_check:
                        :JMP(array_square_loopZero2inA)

array_square_end:
        $ => RR         :MLOAD(array_square_RR)
                        :RETURN