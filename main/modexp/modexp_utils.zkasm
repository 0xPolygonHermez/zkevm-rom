
; @info return Einit without 0's
; @in E => Einit with 0's
; @out E => Einit without 0's

VAR GLOBAL modexp_getInit_RR

modexp_getInit:
    RR                  :MSTORE(modexp_getInit_RR)
    1 => C

modexp_getInit2:
                        :CALL(MLOADX)
    31 => D             :CALL(SHRarith)
    A                   :JMPZ(modexp_getInit2)
    E - 1 => E
    $ => RR             :MLOAD(modexp_getInit_RR)
                        :RETURN

VAR GLOBAL tmpVarAmodexp
VAR GLOBAL tmpVarBmodexp
VAR GLOBAL tmpVarCmodexp
VAR GLOBAL tmpVarDmodexp
VAR GLOBAL offsetInitModexp
VAR GLOBAL tmpVarEmodexp
VAR GLOBAL tmpZkPCmodexp
VAR GLOBAL modExpArrayIndex

modexp_getBase:
    RR                  :MSTORE(tmpZkPCmodexp)
    A                   :MSTORE(tmpVarAmodexp)
    B                   :MSTORE(tmpVarBmodexp)
    C                   :MSTORE(tmpVarCmodexp)
    D                   :MSTORE(tmpVarDmodexp)
    E                   :MSTORE(offsetInitModexp)
    E + C => E          ;E = offset final
    0                   :MSTORE(modExpArrayIndex)
    0                   :MSTORE(modexp_Blen)

modexp_getBaseLoop:
    C => A
    0 => B
    $                   :EQ,JMPC(modexp_saveBaseLen)
    32 => B
    $                   :LT,JMPC(modexp_getBaseMloadX)
    E - 32 => E
                        :CALL(MLOAD32)
    E - 32 => E
    C - 32 => C         :JMP(modexp_getBaseMstore)

modexp_getBaseMloadX:
    E - C => E
                        :CALL(MLOADX)
    E - C => E
    32 - C => D         :CALL(SHRarith)
    0 => C

modexp_getBaseMstore:
    E                   :MSTORE(tmpVarEmodexp)
    A => E
    $ => B              :MLOAD(modExpArrayIndex)
    $ => A              :ADD
    0 => B
    $                   :EQ,JMPC(modexp_getBaseFinal)
    E => A
    $ => E              :MLOAD(modExpArrayIndex)
    A                   :MSTORE(modexp_B+E)
    E + 1 => B          :MSTORE(modExpArrayIndex)

modexp_getBaseFinal:
    $ => E              :MLOAD(tmpVarEmodexp),JMP(modexp_getBaseLoop)

modexp_saveBaseLen:
    $ => A              :MLOAD(modExpArrayIndex)
    0 => B
    $                   :EQ,JMPC(modexp_getReturn)
    A - 1 => E          :MSTORE(modExpArrayIndex)
    $ => A              :MLOAD(modexp_B + E)
    $                   :EQ,JMPC(modexp_saveBaseLen)
    E + 1               :MSTORE(modexp_Blen),JMP(modexp_getReturn)

modexp_getExp:
    RR                  :MSTORE(tmpZkPCmodexp)
    A                   :MSTORE(tmpVarAmodexp)
    B                   :MSTORE(tmpVarBmodexp)
    C                   :MSTORE(tmpVarCmodexp)
    D                   :MSTORE(tmpVarDmodexp)
    E                   :MSTORE(offsetInitModexp)
    E + C => E          ;E = offset final
    0                   :MSTORE(modExpArrayIndex)
    0                   :MSTORE(modexp_Elen)

modexp_getExpLoop:
    C => A
    0 => B
    $                   :EQ,JMPC(modexp_saveExpLen)
    32 => B
    $                   :LT,JMPC(modexp_getExpMloadX)
    E - 32 => E
                        :CALL(MLOAD32)
    E - 32 => E
    C - 32 => C         :JMP(modexp_getExpMstore)

modexp_getExpMloadX:
    E - C => E
                        :CALL(MLOADX)
    E - C => E
    32 - C => D         :CALL(SHRarith)
    0 => C

modexp_getExpMstore:
    E                   :MSTORE(tmpVarEmodexp)
    A => E
    $ => B              :MLOAD(modExpArrayIndex)
    $ => A              :ADD
    0 => B
    $                   :EQ,JMPC(modexp_getExpFinal)
    E => A
    $ => E              :MLOAD(modExpArrayIndex)
    A                   :MSTORE(modexp_E+E)
    E + 1 => B          :MSTORE(modExpArrayIndex)

modexp_getExpFinal:
    $ => E              :MLOAD(tmpVarEmodexp),JMP(modexp_getExpLoop)

modexp_saveExpLen:
    $ => A              :MLOAD(modExpArrayIndex)
    0 => B
    $                   :EQ,JMPC(modexp_getReturn)
    A - 1 => E          :MSTORE(modExpArrayIndex)
    $ => A              :MLOAD(modexp_E + E)
    $                   :EQ,JMPC(modexp_saveExpLen)
    E + 1               :MSTORE(modexp_Elen),JMP(modexp_getReturn)

modexp_getMod:
    RR                  :MSTORE(tmpZkPCmodexp)
    A                   :MSTORE(tmpVarAmodexp)
    B                   :MSTORE(tmpVarBmodexp)
    C                   :MSTORE(tmpVarCmodexp)
    D                   :MSTORE(tmpVarDmodexp)
    E                   :MSTORE(offsetInitModexp)
    E + C => E          ;E = offset final
    0                   :MSTORE(modExpArrayIndex)
    0                   :MSTORE(modexp_Mlen)

modexp_getModLoop:
    C => A
    0 => B
    $                   :EQ,JMPC(modexp_saveModLen)
    32 => B
    $                   :LT,JMPC(modexp_getModMloadX)
    E - 32 => E
                        :CALL(MLOAD32)
    E - 32 => E
    C - 32 => C         :JMP(modexp_getModMstore)

modexp_getModMloadX:
    E - C => E
                        :CALL(MLOADX)
    E - C => E
    32 - C => D         :CALL(SHRarith)
    0 => C

modexp_getModMstore:
    E                   :MSTORE(tmpVarEmodexp)
    A => E
    $ => B              :MLOAD(modExpArrayIndex)
    $ => A              :ADD
    0 => B
    $                   :EQ,JMPC(modexp_getModFinal)
    E => A
    $ => E              :MLOAD(modExpArrayIndex)
    A                   :MSTORE(modexp_M+E)
    E + 1 => B          :MSTORE(modExpArrayIndex)

modexp_getModFinal:
    $ => E              :MLOAD(tmpVarEmodexp),JMP(modexp_getModLoop)

modexp_saveModLen:
    $ => A              :MLOAD(modExpArrayIndex)
    0 => B
    $                   :EQ,JMPC(modexp_getReturn)
    A - 1 => E          :MSTORE(modExpArrayIndex)
    $ => A              :MLOAD(modexp_M + E)
    $                   :EQ,JMPC(modexp_saveModLen)
    E + 1               :MSTORE(modexp_Mlen),JMP(modexp_getReturn)

modexp_getReturn:
    $ => RR             :MLOAD(tmpZkPCmodexp)
    $ => A              :MLOAD(tmpVarAmodexp)
    $ => B              :MLOAD(tmpVarBmodexp)
    $ => C              :MLOAD(tmpVarCmodexp)
    $ => D              :MLOAD(tmpVarDmodexp)
    $ => E              :MLOAD(offsetInitModexp)
    E + C => E
                        :RETURN
