
; @info return Einit without 0's
; @in E => Einit with 0's
; @out E => Einit without 0's

VAR GLOBAL modexp_getInit_RR

modexp_getInit:
    RR                  :MSTORE(modexp_getInit_RR)
    1 => C

modexp_getInit2:
                        :CALL(MLOADX)
    31 => D             :CALL(SHRarith)
    A                   :JMPZ(modexp_getInit2)
    E - 1 => E
    $ => RR             :MLOAD(modexp_getInit_RR)
                        :RETURN

VAR GLOBAL BASE
VAR GLOBAL EXP
VAR GLOBAL MOD

VAR GLOBAL tmpVarAmodexp
VAR GLOBAL tmpVarBmodexp
VAR GLOBAL tmpVarCmodexp
VAR GLOBAL tmpVarDmodexp
VAR GLOBAL tmpVarEmodexp
VAR GLOBAL tmpZkPCmodexp

modexp_getBase:
    RR                  :MSTORE(tmpZkPCmodexp)
    A                   :MSTORE(tmpVarAmodexp)
    B                   :MSTORE(tmpVarBmodexp)
    C                   :MSTORE(tmpVarCmodexp)
    D                   :MSTORE(tmpVarDmodexp)
    E + C => E          ;E = offset final
    0 => B

modexp_getBaseLoop:
    C                   :JMPZ(modexp_getReturn)
    C - 32              :JMPN(modexp_getBaseMloadX)
    E - 32 => E
                        :CALL(MLOAD32)
    C - 32 => C         :JMP(modexp_getBaseFinal)

modexp_getBaseMloadX:
    E - C => E
                        :CALL(MLOADX)
    32 - C => D         :CALL(SHRarith)

modexp_getBaseFinal:
    A                   :MSTORE(BASE+B)
    B + 1 => B
                        :JMP(modexp_getBaseLoop)

modexp_getExp:
    RR                  :MSTORE(tmpZkPCmodexp)
    A                   :MSTORE(tmpVarAmodexp)
    B                   :MSTORE(tmpVarBmodexp)
    C                   :MSTORE(tmpVarCmodexp)
    D                   :MSTORE(tmpVarDmodexp)
    E + C => E          ;E = offset final
    0 => B

modexp_getExpLoop:
    C                   :JMPZ(modexp_getReturn)
    C - 32              :JMPN(modexp_getExpMloadX)
    E - 32 => E
                        :CALL(MLOAD32)
    C - 32 => C         :JMP(modexp_getExpFinal)

modexp_getExpMloadX:
    E - C => E
                        :CALL(MLOADX)
    32 - C => D         :CALL(SHRarith)

modexp_getExpFinal:
    A                   :MSTORE(EXP+B)
    B + 1 => B
                        :JMP(modexp_getExpLoop)

modexp_getMod:
    RR                  :MSTORE(tmpZkPCmodexp)
    A                   :MSTORE(tmpVarAmodexp)
    B                   :MSTORE(tmpVarBmodexp)
    C                   :MSTORE(tmpVarCmodexp)
    D                   :MSTORE(tmpVarDmodexp)
    E + C => E          ;E = offset final
    0 => B              :JMP(modexp_getModLoop)

modexp_getModLoop:
    C                   :JMPZ(modexp_getReturn)
    C - 32              :JMPN(modexp_getModMloadX)
    E - 32 => E
                        :CALL(MLOAD32)
    C - 32 => C         :JMP(modexp_getModFinal)

modexp_getModMloadX:
    E - C => E
                        :CALL(MLOADX)
    32 - C => D         :CALL(SHRarith)

modexp_getModFinal:
    A                   :MSTORE(MOD+B)
    B + 1 => B
                        :JMP(modexp_getModLoop)

modexp_getReturn:
    $ => RR             :MLOAD(tmpZkPCmodexp)
    $ => A              :MSTORE(tmpVarAmodexp)
    $ => B              :MSTORE(tmpVarBmodexp)
    $ => C              :MSTORE(tmpVarCmodexp)
    $ => D              :MSTORE(tmpVarDmodexp)
                        :RETURN
