INCLUDE "constants.zkasm"
INCLUDE "vars.zkasm"

; Blocks zkROM
;       A - Load initial registers into memory: oldStateRoot (B), oldAccBatchHashData (C), oldNumBatch (SP) & chainID (GAS)
;       B - Set batch global variables
;       C - Loop decoding transactions
;       D - Loop processing transactions
;       E - Batch computations: get newLocalExitRoot, assert transactions size, compute batchHashData & compute newAccBatchHashData
;       F - Finalize execution

start: ; main zkROM entry point
;;;;;;;;;;;;;;;;;;
;; A - Load input variables
;;;;;;;;;;;;;;;;;;
        STEP => A
        0                                   :ASSERT ; Ensure it is the beginning of the execution

        CTX                                 :MSTORE(forkID)
        CTX - %FORK_ID                      :JMPNZ(failAssert)

        B => SR                             :MSTORE(oldStateRoot) ;set initial state root
        C                                   :MSTORE(oldAccBatchHashData)
        SP                                  :MSTORE(oldNumBatch)
        GAS                                 :MSTORE(chainID) ; assumed to be less than 32 bits

        ${getHistoricGERRoot()}             :MSTORE(historicGER)
        ${getSequencerAddr()}               :MSTORE(sequencerAddr)
        ${getTimestampLimit()}              :MSTORE(timestampLimit)
        ${getTxsLen()}                      :MSTORE(batchDataLength) ; less than 300.000 bytes. Enforced by the smart contract

        ; Increase batch number
        SP + 1                              :MSTORE(newNumBatch)

;;;;;;;;;;;;;;;;;;
;; B - Set batch global variables
;;     - load transaction count from system smart contract
;;     - compute keccaks needed to finish the batch
;;;;;;;;;;;;;;;;;;
        $${eventLog(onStartBatch, C)}
        ; Load current block number from system smart contract
        %LAST_BLOCK_STORAGE_POS => C
        %ADDRESS_SYSTEM => A
        %SMT_KEY_SC_STORAGE => B
        $ => D          :SLOAD, MSTORE(blockNum)

        ; Compute necessary keccak counters to finish batch
        $ => A          :MLOAD(batchDataLength)
        ; Divide the total data length + 1 by 136 to obtain the keccak counter increment.
        ; 136 is the value used by the prover to increment keccak counters
        A + 1                                   :MSTORE(arithA)
        136                                     :MSTORE(arithB), CALL(divARITH); in: [arithA, arithB] out: [arithRes1: arithA/arithB, arithRes2: arithA%arithB]
        $ => B                                  :MLOAD(arithRes1)
        ; Compute minimum necessary keccaks to finish the batch
        B + 1 + %MIN_CNT_KECCAK_BATCH => B      :MSTORE(cntKeccakPreProcess)
        %MAX_CNT_KECCAK_F - CNT_KECCAK_F - B    :JMPN(outOfCountersKeccak)

;;;;;;;;;;;;;;;;;;
;; C - Loop decoding transactions
;;      - Decode batchData and transactions by type
;;      - If an error is found in any transaction, the batch will not process any transaction
;;;;;;;;;;;;;;;;;;

        0                                   :MSTORE(batchHashPos)
        $ => E                              :MLOAD(lastHashPIdAvailable)
        E + 1                               :MSTORE(lastHashPIdAvailable)
        E                                   :MSTORE(batchHashDataId)
        $ => A                              :MLOAD(lastCtxUsed)
        A                                   :MSTORE(ctxTxToUse) ; Points at first context to be used when processing transactions

        $${var p = 0}
        ; set flag isDecoding to 1 and start decoding
        1               :MSTORE(isDecoding), JMP(decodeBatchData)

;;;;;;;;;;;;;;;;;;
;; D - Loop processing transactions
;;      - Load transaction data and interpret it
;;;;;;;;;;;;;;;;;;

txLoop:
        $ => A                         :MLOAD(pendingTxs)
        A - 1                          :MSTORE(pendingTxs), JMPN(processTxsEnd)
        $ => A                         :MLOAD(txIndex)
        A + 1                          :MSTORE(txIndex)
        $ => A                         :MLOAD(ctxTxToUse) ; Load first context used by transaction
        A + 1 => CTX                   :MSTORE(ctxTxToUse)
        $ => A                         :MLOAD(txType)
        A - %TX_TYPE_CHANGE_L2_BLOCK   :JMPZ(processChangeL2Block)
                                       :JMP(processTx)
createTxReceipt:
        ; Set txReceipt
        $ => E                         :MLOAD(lastHashPIdAvailable)
        E + 1                          :MSTORE(lastHashPIdAvailable)
        ; generate receipt leaf value linearPoseidon(status + gasUsed + logsRoot)
        ; Hash transaction status (1 byte)
        $ => A                         :MLOAD(txStatus)
        1 => D
        A                              :HASHP(E)
        ; Hash gas used (8 bytes)
        8 => D
        $ => B                         :MLOAD(txGasLimit)
        ; Both txGasLimit and GAS are 32 bits. txGasLimit is capped by %TX_GAS_LIMIT (25 bits)
        B - GAS => A                   :HASHP(E)
        ; Hash logsSR (32 bytes)
        32 => D
        $ => A                         :MLOAD(logsSR)
        A                              :HASHP(E)
        HASHPOS                        :HASHPLEN(E)
        $ => D                         :HASHPDIGEST(E)
        ; Swap to txReceipt SR
        SR => E
        $ => SR                        :MLOAD(receiptSR)
        ; Store hash of the log in the tree, key => logIndex
        %ADDRESS_SYSTEM => A
        %SMT_KEY_RECEIPT => B
        $ => C                         :MLOAD(txIndex)
        $ => SR                        :SSTORE
        ; Swap back to main SR
        SR                             :MSTORE(logsSR)

processTxFinished:
        $${eventLog(onFinishTx)}       :JMP(txLoop)

processTxsEnd:
                                       :CALL(consolidateReceiptTree)

;;;;;;;;;;;;;;;;;;
;; E - Batch asserts & computations:
;;      - get newLocalExitRoot
;;      - assert transactions size
;;      - compute batchHashData
;;      - compute newAccBatchHashData
;;;;;;;;;;;;;;;;;;

;; Get local exit root
        ; Read 'localExitRoot' variable from GLOBAL_EXIT_ROOT_MANAGER_L2 and store
        ; it to the 'newLocalExitRoot' input
        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A
        %SMT_KEY_SC_STORAGE => B
        %LOCAL_EXIT_ROOT_STORAGE_POS => C
        $ => A                                          :SLOAD
        A                                               :MSTORE(newLocalExitRoot)

;; Transactions size verification
        ; Ensure bytes added to compute the 'batchHashData' matches the number of bytes loaded from input
        $ => A                          :MLOAD(batchHashPos)
        $                               :MLOAD(batchDataLength), ASSERT

;; Compute 'batchHashData'
        A => HASHPOS
        $ => E                          :MLOAD(batchHashDataId)

        HASHPOS                         :HASHPLEN(E)
        $ => B                          :HASHPDIGEST(E)

        B                               :MSTORE(batchHashData)

;; Compute 'newAccBatchHashData'
; poseidon(input, capacity). Capacity = 0, Input = [oldAccBatchHashData(A), batchHashData(B)]
        $ => A                          :MLOAD(oldAccBatchHashData)
        0 => C
        $                               :POSEIDON, MSTORE(newAccBatchHashData)
        $${eventLog(onFinishBatch)}

;;;;;;;;;;;;;;;;;;
;; F - Finalize execution
;;;;;;;;;;;;;;;;;;
        ; Set output registers
        $ => D                          :MLOAD(newAccBatchHashData)
        $ => E                          :MLOAD(newLocalExitRoot)
        $ => PC                         :MLOAD(newNumBatch)

        ; Set registers to its initials values
        $ => CTX                        :MLOAD(forkID)
        $ => B                          :MLOAD(oldStateRoot)
        $ => C                          :MLOAD(oldAccBatchHashData)
        $ => SP                         :MLOAD(oldNumBatch)
        $ => GAS                        :MLOAD(chainID)
        finalizeExecution:
                                        :JMP(finalWait)

INCLUDE "end.zkasm"
INCLUDE "process-tx.zkasm"
INCLUDE "process-change-l2-block.zkasm"
INCLUDE "utils.zkasm"
INCLUDE "decode/tx-decode.zkasm"
