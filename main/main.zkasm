INCLUDE "constants.zkasm"
INCLUDE "vars.zkasm"

; Blocks zkROM
;       A - Load initial registers into memory: oldStateRoot (SR), oldBatchAccInputHash (C), forkID (CTX), previousL1InfoTreeRoot (D), previousL1InfoTreeIndex (RCX), chainID (GAS)
;       B - Compute forcedHashData
;       C - Compute newBatchAccInputHash, load timestamp and blockNum
;       D - Loop parsing RLP transactions
;       E - Loop processing transactions
;       F - FinalizeBatch
;       G - Finalize execution

start: ; main zkROM entry point
;;;;;;;;;;;;;;;;;;
;; A - Load input variables
;;;;;;;;;;;;;;;;;;
        STEP => A
        0                                       :ASSERT ; Ensure it is the beginning of the execution

        CTX                                     :MSTORE(forkID) ; Fork id from CTX, assumed to be less than 32 bits
        CTX - %FORK_ID                          :JMPNZ(failAssertInvalidForkId)

        SR => A                                  :MSTORE(oldStateRoot) ; oldStateRoot from SR
        SR                                       :MSTORE(batchSR)
        ; safety check that the input root is indeed inside the range limit of 4 goldilocks fields elements
        %FOUR_GOLDILOCKS => B
        1                                       :LT4

        C                                       :MSTORE(oldBatchAccInputHash) ; oldBatchAccInputHash from C
        D                                       :MSTORE(previousL1InfoTreeRoot) ; previousL1InfoTreeRoot from D
        D                                       :MSTORE(currentL1InfoTreeRoot)
        RCX                                     :MSTORE(previousL1InfoTreeIndex) ; previousL1InfoTreeIndex, assumed to be less than 32 bits
        RCX                                     :MSTORE(currentL1InfoTreeIndex)
        GAS                                     :MSTORE(chainID) ; chainID from GAS, assumed to be less than 32 bits

        ${getSequencerAddr()}                   :MSTORE(sequencerAddr)
        ${getBatchHashData()}                   :MSTORE(batchHashData)
        ${getForcedHashData()} => A             :MSTORE(forcedHashData)
        0 => B
        $                                       :EQ, JMPC(computeNewBatchAccInputHash)
        ; If forcedHashData ist no zero, is a forced batch
        ; Set forced batch flag
        1                                       :MSTORE(isForced)
;;;;;;;;;;;;;;;;;;
;; B - Compute forcedHashData
;;;;;;;;;;;;;;;;;;
        $ => E                                  :MLOAD(nextHashKId)
        E + 1                                   :MSTORE(nextHashKId)
        ${getForcedGER()} => A                  :MSTORE(forcedGER), HASHK32(E)
        ${getForcedBlockHashL1()}               :MSTORE(forcedBlockHashL1InfoTree), HASHK32(E) ; no need to set at A
        ${getForcedTimestamp()} => A            :MSTORE(forcedTimestamp), HASHK8(E)
        HASHPOS                                 :HASHKLEN(E)
        ; Assert forcedHashData computed matches with forcedHashData obtained from free input
        $ => A                                  :HASHKDIGEST(E)
        $                                       :MLOAD(forcedHashData), ASSERT
;;;;;;;;;;;;;;;;;
;; C - Compute newBatchAccInputHash, load blockNum and timestamp
;;;;;;;;;;;;;;;;;;
computeNewBatchAccInputHash:
        ; newBatchAccInputHash = LinearPoseidon(oldBatchAccInputHash, batchHashData, sequencerAddress, forcedHashData))
        $ => E                          :MLOAD(nextHashPId)
        E + 1                           :MSTORE(nextHashPId)
        $${eventLog(onStartBatch, C)}
        0 => HASHPOS

        ; 32 bytes
        ${mem.oldBatchAccInputHash}     :HASHP32(E), MLOAD(oldBatchAccInputHash)

        ${mem.batchHashData}            :HASHP32(E), MLOAD(batchHashData)

        ; 20 bytes
        ${mem.sequencerAddr}            :HASHP20(E), MLOAD(sequencerAddr)

        ; 32 bytes
        ${mem.forcedHashData}           :HASHP32(E), MLOAD(forcedHashData)

        ; finish accInputHash
        HASHPOS                         :HASHPLEN(E)

        $ => C                          :HASHPDIGEST(E), MSTORE(newBatchAccInputHash)

        ; Compute batchHashData (loaded at smt from executor)
        $ => E                          :MLOAD(nextHashPId)
        E                               :MSTORE(batchHashDataPointer)
        E + 1                           :MSTORE(nextHashPId)
        ; No need to compute poseidon consumption, max batchL2Data length is 120000 bytes and this is the beginning of the execution, will always have enough poseidons
        $ => A                          :MLOAD(batchHashData)
        A                               :HASHPDIGEST(E)
        ; store batchL2DataLength, less than 4096*31 bytes (126976). Enforced by the smart contract
        $                               :HASHPLEN(E), MSTORE(batchL2DataLength)

        ; Load current timestamp
        %ADDRESS_SYSTEM => A
        %SMT_KEY_SC_STORAGE => B
        %TIMESTAMP_STORAGE_POS => C
        $                               :SLOAD, MSTORE(timestamp)
        ; Load current block
        %LAST_BLOCK_STORAGE_POS => C
        $                               :SLOAD,MSTORE(blockNum)

;;;;;;;;;;;;;;;;;;
;; D - Loop parsing RLP transactions
;;      - Load transaction RLP data and ensure it has correct RLP encoding
;;      - If an error is found in any transaction, the batch will not process any transaction
;;;;;;;;;;;;;;;;;;
        $ => A                                  :MLOAD(lastCtxUsed)
        A + %CALLDATA_RESERVED_CTX => A         :MSTORE(ctxTxToUse) ; Points at first context to be used when processing transactions. We reserve ctx = 1 for calldata
        A                                       :MSTORE(lastCtxUsed)

txLoopRLP:
        $ => A                                  :MLOAD(lastCtxUsed)
        A+1 => CTX                              :MSTORE(lastCtxUsed)
        ; If batchL2DataLength is zero, we finalize batch
        $ => A                                  :MLOAD(batchL2DataLength), JMPZ(finalizeBatch)
        $ - A                                   :F_MLOAD(batchL2DataParsed), JMPN(loadTx_rlp)
;;;;;;;;;;;;;;;;;;
;; E   - Loop processing transactions
;;     - Load transaction data and interpret it
;;;;;;;;;;;;;;;;;;

        ; If forced batch ==> process a forced changeL2BlockTx
        $                                       :MLOAD(isForced), JMPZ(txLoop, handleForcedBatch)
handleForcedBatch:
        1                                       :MSTORE(currentTx), JMP(processChangeL2Block)

txLoop:
        $ => A                                  :MLOAD(pendingTxs)
        A - 1                                   :MSTORE(pendingTxs), JMPN(processTxsEnd)
        $ => A                                  :MLOAD(currentTx)
        A + 1                                   :MSTORE(currentTx)
        $ => A                                  :MLOAD(ctxTxToUse) ; Load first context used by transaction
        A + 1 => CTX                            :MSTORE(ctxTxToUse)
        ; Detect if transaction is a change L2 block tx
        ; Store initial state at the beginning of the transaction
        SR                                      :MSTORE(originSR)
        $ - 1                                   :F_MLOAD(isChangeL2BlockTx), JMPZ(processChangeL2Block, processTx)

processTxFinished:
        %MAX_CNT_BINARY - CNT_BINARY - 1        :JMPN(outOfCountersBinary)
        ; Increase cumulativeGasUsed
        $ => A                                  :MLOAD(txGasLimit)
        A - GAS => A
        $ => B                                  :MLOAD(cumulativeGasUsed)
        $                                       :ADD, MSTORE(cumulativeGasUsed), CALL(fillBlockInfoTreeWithTxReceipt)
        ; Increase txIndex
        $ => A                                  :MLOAD(txIndex)
        A + 1                                   :MSTORE(txIndex)
processIntrinsicTxFinished:
        $${eventLog(onFinishTx)}                :JMP(txLoop)

processTxsEnd:
        ;  Write values at storage at the end of block processing
                                                :CALL(consolidateBlock)
finalizeBatch:

;;;;;;;;;;;;;;;;;;
;; F - Check all save/restore have been consumed
;;   - Retrieve newLocalExitRoot
;;   - Finalize execution: set output values at corresponding registers
;;;;;;;;;;;;;;;;;;
        ;Each save must be restored precisely once. At the end of the program, all saves without restoration must be cleaned because if not, proof generation fails.
                                                :SAVE(B,C,D,E,RR,RCX)
        RID                                     :MSTORE(lastRID)
clearPendingRestores_loop:
        ${getPendingRID(mem.lastRID)} => RID    :JMPN(clearPendingRestores_end)
                                                :RESTORE, JMP(clearPendingRestores_loop)

clearPendingRestores_end:
        $ => RID                :MLOAD(lastRID)
                                :RESTORE
        0 => RID

        ; Retrieve newLocalExitRoot
        ; Read 'localExitRoot' variable from GLOBAL_EXIT_ROOT_MANAGER_L2 and store
        ; it to the 'newLocalExitRoot' var
        %MAX_CNT_POSEIDON_G - CNT_POSEIDON_G - %MAX_CNT_POSEIDON_SLOAD_SSTORE     :JMPN(outOfCountersPoseidon) ; !!!
        ; Comment margin counters
        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A
        %SMT_KEY_SC_STORAGE => B
        %LOCAL_EXIT_ROOT_STORAGE_POS => C
        $ => A                                  :SLOAD
        A                                       :MSTORE(newLocalExitRoot) ; one line
        $${eventLog(onFinishBatch)}
;;;;;;;;;;;;;;;;;;
;; G - Finalize execution
;;;;;;;;;;;;;;;;;;
        SR                              :MSTORE(auxNewSR) ; Store final SR to recover at output setting phase
        ; Set registers to its initials values
        ; Save inputs to RESTORE at last - 1 step
        $ => SR                         :MLOAD(oldStateRoot) ; oldStateRoot from SR
        $ => C                          :MLOAD(oldBatchAccInputHash) ; oldBatchAccInputHash from C
        $ => D                          :MLOAD(previousL1InfoTreeRoot) ; previousL1InfoTreeRoot from D
        $ => RCX                        :MLOAD(previousL1InfoTreeIndex) ; previousL1InfoTreeIndex from E
        ; Set all registers to 0 except inputs: SR (oldStateRoot), C (oldBatchAccInputHash), D (previousL1InfoTreeRoot), RCX (previousL1InfoTreeIndex), GAS (chainID) & CTX (forkID)
        0 => A, B, E, PC, SP, HASHPOS, RR, zkPC
        SR                              :SAVE(B,C,D,E,RR,RCX)
        $ => CTX                        :MLOAD(forkID)
        $ => GAS                        :MLOAD(chainID)

        ; Set output registers
        ; safety check that the output root is indeed inside the range limit of 4 goldilocks fields elements
        $ => SR                         :MLOAD(auxNewSR) ; newStateRoot at SR
        SR => A ; newStateRoot at A
        %FOUR_GOLDILOCKS => B
        1                               :LT4
        ; Recover A to 0
        0 => A

        ; Set output registers
        $ => RR                         :MLOAD(timestamp) ; Timestamp at RR
        $ => RCX                        :MLOAD(currentL1InfoTreeIndex) ; currentL1InfoTreeIndex at RCX
        $ => D                          :MLOAD(currentL1InfoTreeRoot) ; currentL1InfoTreeRoot at D
        $ => C                          :MLOAD(newBatchAccInputHash) ; newBatchAccInputHash at C
        $ => E                          :MLOAD(newLocalExitRoot) ; NewLocalExitRoot at E
        ; SR is already at SR reg
        finalizeExecution:
                                        :JMP(finalWait)

INCLUDE "end.zkasm"
INCLUDE "load-tx-rlp.zkasm"
INCLUDE "process-tx.zkasm"
INCLUDE "process-change-l2-block.zkasm"
INCLUDE "utils.zkasm"
INCLUDE "block-info.zkasm"

