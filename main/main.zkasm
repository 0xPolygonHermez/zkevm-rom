INCLUDE "constants.zkasm"
INCLUDE "vars.zkasm"

; Blocks zkROM
;       A - Load initial registers into memory: oldStateRoot (B), oldBatchAccInputHash (C), & chainID (GAS)
;       B - Compute keccaks needed to finish the batch
;       C - Loop parsing RLP transactions
;       D - Load blockNum variable & Loop processing transactions
;       E - Batch computations: get newLocalExitRoot, assert transactions size, compute batchHashData & compute newBatchAccInputHash
;       F - Finalize execution

start: ; main zkROM entry point
;;;;;;;;;;;;;;;;;;
;; A - Load input variables
;;;;;;;;;;;;;;;;;;
        STEP => A
        0                                       :ASSERT ; Ensure it is the beginning of the execution

        CTX                                     :MSTORE(forkID) ; Fork id from CTX
        CTX - %FORK_ID                          :JMPNZ(failAssert)

        SR => A                                  :MSTORE(oldStateRoot) ; oldStateRoot from SR

        ; safety check that the input root is indeed inside the range limit of 4 goldilocks fields elements
        %FOUR_GOLDILOCKS => B
        1                                       :LT4

        C                                       :MSTORE(oldBatchAccInputHash) ; oldBatchAccInputHash from C
        D                                       :MSTORE(oldL1InfoTreeRoot) ; oldL1InfoTreeRoot from D
        D                                       :MSTORE(l1InfoRoot)
        RCX                                     :MSTORE(oldL1InfoTreeIndex) ; oldL1InfoTreeIndex from E
        RCX                                     :MSTORE(l1InfoTreeIndex)
        GAS                                     :MSTORE(chainID) ; chainID from GAS, assumed to be less than 32 bits
        SR                                      :SAVE(B,C,D,E,RR,RCX)

        ${getSequencerAddr()}                   :MSTORE(sequencerAddr)
        ${getTxsLen()}                          :MSTORE(batchL2DataLength) ; less than 120000 bytes. Enforced by the smart contract
        ${getBatchHashData()}                   :MSTORE(batchHashData)
        $0{getType()} => A                      :MSTORE(type)

        ; If is not forced, forcedHashData is zero, CHECK: remove?
        0                                       :MSTORE(forcedHashData)
        A - 2                                   :JMPNZ(computeNewBatchAccInputHash)
        1                                       :MSTORE(isForced)
        ; compute isForced flag
        ${getGER()}                             :MSTORE(gerL1InfoTree)
        ${getBlockHashL1()}                     :MSTORE(blockHashL1InfoTree)
        ${getMinTimestamp()}                    :MSTORE(timestampL1InfoTree)
        ; Compute forcedHashData
        $ => E                                  :MLOAD(nextHashKId)
        E + 1                                   :MSTORE(nextHashKId)
        32 => D
        $ => A                                  :MLOAD(gerL1InfoTree)
        A                                       :HASHK(E)
        $ => A                                  :MLOAD(blockHashL1InfoTree)
        A                                       :HASHK(E)
        8 => D
        $ => A                                  :MLOAD(timestampL1InfoTree)
        A                                       :HASHK(E)
        HASHPOS                                 :HASHKLEN(E)
        ; CHECK: need to assert with a forcedHashData obtained from free input?
        $ => C                                  :HASHKDIGEST(E)
        C                                       :MSTORE(forcedHashData)
;;;;;;;;;;;;;;;;;
;; B - Compute newBatchAccInputHash, load newLocalExitRoot and timestamp
;;;;;;;;;;;;;;;;;;
computeNewBatchAccInputHash:
        $ => E                          :MLOAD(nextHashKId)
        E + 1                           :MSTORE(nextHashKId)
        $${eventLog(onStartBatch, C)}
        0 => HASHPOS

        32 => D
        $ => A                          :MLOAD(oldBatchAccInputHash)
        A                               :HASHK(E)

        $ => A                          :MLOAD(batchHashData)
        A                               :HASHK(E)

        20 => D
        $ => A                          :MLOAD(sequencerAddr)
        A                               :HASHK(E)

        32 => D
        $ => A                          :MLOAD(forcedHashData)
        A                               :HASHK(E)

        1 => D
        $ => A                          :MLOAD(type)
        A                               :HASHK(E)

        ; finish accInputHash
        HASHPOS                         :HASHKLEN(E)

        $ => C                          :HASHKDIGEST(E)
        C                               :MSTORE(newBatchAccInputHash)

        ; Compute batchHashData (loaded at smt from executor)
        $ => E                          :MLOAD(nextHashPId)
        E                               :MSTORE(batchHashDataPointer)
        E + 1                           :MSTORE(nextHashPId)
        ; Initialize batchHashPos to zero (CHECK: is this necessary?)
        0                               :MSTORE(batchHashPos)
        $ => A                          :MLOAD(batchHashData)
        ; No need to compute poseidon consumption, max batchL2Data length is 120000 bytes and this is the beginning of the execution, will always have enough poseidons
        A                               :HASHPDIGEST(E)
        ; Check batchL2DataLength (CHECK: is it necessary to check this? Is a correct behavior? Is possible to get the length from hashplen?)
        $ => HASHPOS                    :MLOAD(batchL2DataLength)
        HASHPOS                         :HASHPLEN(E)

        ;; Get local exit root
        ; Read 'localExitRoot' variable from GLOBAL_EXIT_ROOT_MANAGER_L2 and store
        ; it to the 'newLocalExitRoot' input, will be used to compute newBatchAccInputHash
        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A
        %SMT_KEY_SC_STORAGE => B
        %LOCAL_EXIT_ROOT_STORAGE_POS => C
        $ => A                                  :SLOAD
        A                                       :MSTORE(newLocalExitRoot)

        ; Load current timestamp
        %TIMESTAMP_STORAGE_POS => C
        %ADDRESS_SYSTEM => A
        %SMT_KEY_SC_STORAGE => B
        $ => A                              :SLOAD, MSTORE(timestamp)
;;;;;;;;;;;;;;;;;;
;; C - Loop parsing RLP transactions
;;      - Load transaction RLP data and ensure it has correct RLP encoding
;;      - If an error is found in any transaction, the batch will not process any transaction
;;;;;;;;;;;;;;;;;;
        $ => A                                  :MLOAD(lastCtxUsed)
        A + %CALLDATA_RESERVED_CTX => A         :MSTORE(ctxTxToUse) ; Points at first context to be used when processing transactions. We reserve ctx = 1 for calldata
        A                                       :MSTORE(lastCtxUsed)

txLoopRLP:
        $ => A                                  :MLOAD(lastCtxUsed)
        A+1 => CTX                              :MSTORE(lastCtxUsed)
        ; If batchL2DataLength is zero, we finalize batch
        $ => A                                  :MLOAD(batchL2DataLength), JMPZ(finalizeBatch)
        $ => C                                  :MLOAD(batchL2DataParsed)
        C - A                                   :JMPN(loadTx_rlp, setBlockNum)

;;;;;;;;;;;;;;;;;;
;; D - Load blockNum variable
;;     - Loop processing transactions
;;     - Load transaction data and interpret it
;;;;;;;;;;;;;;;;;;

setBlockNum:
        %LAST_BLOCK_STORAGE_POS => C
        %ADDRESS_SYSTEM => A
        %SMT_KEY_SC_STORAGE => B
        $                                       :SLOAD,MSTORE(blockNum)
        ; If forced batch ==> process a forced changeL2BlockTx
        $                                       :MLOAD(isForced), JMPZ(txLoop, handleForcedBatch)

handleForcedBatch:
        1                                       :MSTORE(currentTx), JMP(processChangeL2Block)

txLoop:
        $ => A                                  :MLOAD(pendingTxs)
        A - 1                                   :MSTORE(pendingTxs), JMPN(processTxsEnd)
        $ => A                                  :MLOAD(currentTx)
        A + 1                                   :MSTORE(currentTx)
        $ => A                                  :MLOAD(ctxTxToUse) ; Load first context used by transaction
        A + 1 => CTX                            :MSTORE(ctxTxToUse)
        ; Detect if transaction is a change L2 block tx
        ; Store initial state at the beginning of the transaction
        SR                                      :MSTORE(originSR)
        $ => A                                  :MLOAD(isChangeL2BlockTx)
        A - 1                                   :JMPZ(processChangeL2Block, processTx)

processTxFinished:
        %MAX_CNT_BINARY - CNT_BINARY - 1        :JMPN(outOfCountersBinary)
        ; Increase cumulativeGasUsed
        $ => A                                  :MLOAD(txGasLimit)
        A - GAS => A
        $ => B                                  :MLOAD(cumulativeGasUsed)
        $                                       :ADD, MSTORE(cumulativeGasUsed), CALL(fillBlockInfoTreeWithTxReceipt)
        ; Increase txIndex
        $ => A                                  :MLOAD(txIndex)
        A + 1                                   :MSTORE(txIndex)
processIntrinsicTxFinished:
        $${eventLog(onFinishTx)}                :JMP(txLoop)

processTxsEnd:
        ;  Write values at storage at the end of block processing
                                                :CALL(consolidateBlock)
finalizeBatch:

;;;;;;;;;;;;;;;;;;
;; E - Finalize execution: set output values at corresponding registers
;;;;;;;;;;;;;;;;;;
        $${eventLog(onFinishBatch)}

;;;;;;;;;;;;;;;;;;
;; F - Finalize execution
;;;;;;;;;;;;;;;;;;

        ; safety check that the output root is indeed inside the range limit of 4 goldilocks fields elements
        SR => A ; newStateRoot at A
        %FOUR_GOLDILOCKS => B
        1                               :LT4

        ; Set output registers
        $ => RR                         :MLOAD(timestamp) ; Timestamp at RR
        $ => RCX                        :MLOAD(l1InfoTreeIndex) ; l1InfoTreeIndex at RCX
        $ => D                          :MLOAD(l1InfoRoot) ; l1InfoTreeIndex at D
        $ => C                          :MLOAD(newBatchAccInputHash) ; newBatchAccInputHash at C
        $ => E                          :MLOAD(newLocalExitRoot) ; NewLocalExitRoot at E
        ; SR is already at SR reg

        ; Set registers to its initials values
        $ => CTX                        :MLOAD(forkID)
        $ => GAS                        :MLOAD(chainID)

        finalizeExecution:
                                        :JMP(finalWait)

INCLUDE "end.zkasm"
INCLUDE "load-tx-rlp.zkasm"
INCLUDE "process-tx.zkasm"
INCLUDE "process-change-l2-block.zkasm"
INCLUDE "utils.zkasm"
INCLUDE "block-info.zkasm"

