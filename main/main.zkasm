INCLUDE "constants.zkasm"
INCLUDE "vars.zkasm"

start:
; First of all, load The call Data.  The first A value is forced with the hash of the TX.
        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash
        STEP => A
        1                                   :ASSERT                                ; Ensure it is the begining of the execution
        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)
        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

        32 => D
        $ => A                              :MLOAD(oldStateRoot)
        A                                   :HASHK(0)
        A => SR

        ${getOldLocalExitRoot()}  => A      :HASHK(0)
                                            :MSTORE(oldLocalExitRoot)

        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

        ${getBatchHashData()}               :MSTORE(batchHashData)

        ${getChainId()}                     :MSTORE(chainId)

        ${getNumBatch()}                    :MSTORE(numBatch)

        ${getTimestamp()}                   :MSTORE(timestamp)

        ${getTxsLen()}                      :MSTORE(batchL2DataLength)

;;;;;;;;;
;; Set batch hash
;;;;;;;;;
        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)
        HASHPOS                             :MSTORE(oldHashPos)
        ; A new hash with position 0 is started
        0 => HASHPOS

        $ => E                              :MLOAD(lastHashKIdUsed)
        E+1 => E                            :MSTORE(lastHashKIdUsed)
        32 => D ; //TODO: opt. no need set D to 32
        $ => A                              :MLOAD(numBatch)
        A - 1                               :HASHK(E)
        %STATE_ROOT_STORAGE_POS             :HASHK(E)                  ; Storage position of the batch hash
        HASHPOS                             :HASHKLEN(E)
        $ => C                              :HASHKDIGEST(E)
        ${eventLog(onStartBatch, C)}

        %ADDRESS_SYSTEM => A
        %SMT_KEY_SC_STORAGE => B
        $ => D                              :MLOAD(oldStateRoot)
        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'
        
;;;;;;;;;
;; Set global exit root
;;;;;;;;;
        ; A new hash with position 0 is started
        0 => HASHPOS

        $ => E                              :MLOAD(lastHashKIdUsed)
        E+1 => E                            :MSTORE(lastHashKIdUsed)
        32 => D
        $ => A                              :MLOAD(numBatch)
        A                                   :HASHK(E)
        %GLOBAL_EXIT_ROOT_STORAGE_POS       :HASHK(E)                  ; Storage position of the global exit root map
        HASHPOS                             :HASHKLEN(E)
        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2 => A
        %SMT_KEY_SC_STORAGE => B
        $ => D                              :MLOAD(globalExitRoot)
        $ => SR                             :SSTORE

;;;;;;;;;
;; Prepare transaction loop
;;;;;;;;;
        E+1 => E                            :MSTORE(lastHashKIdUsed)
        0                                   :MSTORE(batchHashPos)
        E                                   :MSTORE(batchHashDataId)
        ; Store the lastHashKIdUsed at lastTxHashId variable. We need this variable to know where to read the hash for each transaction at process_tx flow
        E                                   :MSTORE(lastTxHashId) ; //TODO: explanation variable
        $ => A                              :MLOAD(lastCtxUsed)
        A                                   :MSTORE(ctxTxToUse)

        $${var p = 0}

txLoopRLP:
        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
        A+1 => CTX      :MSTORE(lastCtxUsed)

        $ => A          :MLOAD(batchL2DataLength)
        $ => C          :MLOAD(batchL2DataParsed)
        C - A           :JMPN(loadTx_rlp)
                        :JMP(endCheckRLP)

endCheckRLP:
                        :JMP(txLoop)

txLoop:
        $ => A          :MLOAD(pendingTxs)
        A-1 => A        :MSTORE(pendingTxs)
        A               :JMPN(processTxsEnd)

        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system
        A+1 => CTX      :MSTORE(ctxTxToUse)

                        :JMP(processTx)

processTxEnd:
        ${eventLog(onFinishTx)}
                        :JMP(txLoop)

processTxsEnd:

;;;;;;;;;
;; Assert local exit root
;;;;;;;;;
        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A
        %SMT_KEY_SC_STORAGE => B
        %LOCAL_EXIT_ROOT_STORAGE_POS => C                         ; Storage position of the local exit root
        $ => A                          :SLOAD
        $                               :MLOAD(newLocalExitRoot), ASSERT

;;;;;;;;;
;; Txs Size Verification
;;;;;;;;;
        $ => A                          :MLOAD(batchHashPos)
        $                               :MLOAD(batchL2DataLength), ASSERT

;;;;;;;;;
;; Check batchHashData
;;;;;;;;;
        A => HASHPOS
        $ => E                          :MLOAD(batchHashDataId)

        32 => D
        $ => A                          :MLOAD(globalExitRoot)
        A                               :HASHK(E)
        8 => D
        $ => A                          :MLOAD(timestamp)
        A                               :HASHK(E)
        20 => D
        $ => A                          :MLOAD(sequencerAddr)
        A                               :HASHK(E)
        8 => D
        $ => A                          :MLOAD(chainId)
        A                               :HASHK(E)
        $ => A                          :MLOAD(numBatch)
        A                               :HASHK(E)
        HASHPOS                         :HASHKLEN(E)
        $ => A                          :MLOAD(batchHashData)
        $                               :HASHKDIGEST(E), ASSERT

;;;;;;;
; Check Global Hash
;;;;;;;

        ; Get position of the previous hash
        $ => HASHPOS                    :MLOAD(oldHashPos)

        32 => D
        SR                              :HASHK(0)

        $ => A                          :MLOAD(newLocalExitRoot)
        A                               :HASHK(0)

        $ => A                          :MLOAD(batchHashData)
        A                               :HASHK(0)

        HASHPOS                         :HASHKLEN(0)

        $ => A                          :MLOAD(globalHash)
        $                               :HASHKDIGEST(0), ASSERT
        ${eventLog(onFinishBatch)}

        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

finalWait:
        ${beforeLast()}  : JMPN(finalWait)
                         : JMP(start)

INCLUDE "loadtx_rlp.zkasm"
INCLUDE "process_tx.zkasm"
INCLUDE "opcodes.zkasm"
