INCLUDE "vars.zkasm"

start:
; First of all, load The call Data.  The first A value is forced with the hash of the TX. 
        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash
        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)

        32 => D
        ${getOldStateRoot()}=> A            :HASHW(0)
        A => SR 

        32 => D
        ${getOldLocalExitRoot()}  => A      :HASHW(0)
                                            :MSTORE(oldLocalExitRoot)

        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

        ${getBatchHashData()}               :MSTORE(batchHashData)

        ${getChainId()}                     :MSTORE(chainId)

        1000                                :MSTORE(defaultChainId)    ; Hardcoded default chain id

        ${getNumBatch()}                    :MSTORE(numBatch)

        ${getTimestamp()}                    :MSTORE(timestamp)

        ${getTxsLen()}                      :MSTORE(txsListLength);

        $ => A                              :MLOAD(lastCtxUsed)
        A                                   :MSTORE(firstCtxUsed)

        $${var p = 0}

txLoopRLP:
        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system 
        A+1 => CTX      :MSTORE(lastCtxUsed)

        $ => A          :MLOAD(txsListLength)
        $ => C          :MLOAD(batchL2DataRead)
        C - A           :JMPC(loadTx_rlp)
                        :JMP(endCheckRLP)

endCheckRLP:
        $ => A          :MLOAD(firstCtxUsed)
        A               :MSTORE(lastCtxUsed)
        0               :MSTORE(lastHashIdUsed)
                        :JMP(txLoop)

txLoop:
        $ => A          :MLOAD(pendingTxs)
        A-1 =>  A       :MSTORE(pendingTxs)
        A               :JMPC(processTxsEnd)

        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system 
        A+1 => CTX      :MSTORE(lastCtxUsed)

                        :JMP(processTx)

processTxEnd:
                        :JMP(txLoop)

processTxsEnd:


;;;;;;;;
; Get new hashId
;;;;;;;
        ; We get a new hashId
        $ => E                          :MLOAD(lastHashIdUsed)
        E+1 => E                        :MSTORE(lastHashIdUsed)

;;;;;;;;;
;; Append TXs
;;;;;;;;;
        $ => B                          :MLOAD(txsListLength)
        0 => C
        $${p = 0}

appendTxs:
        B - C - 32                      :JMPC(endAppendTxs)
        32 => D
        ${getTxs(p,D)} => A     
        $${p = p + D}
        A                               :HASHW(E)
        C + D => C
                                        :JMP(appendTxs)

endAppendTxs:
        B - C => D
        ${getTxs(p,D)} => A     
        $${ p = p + D}
        A                               :HASHW(E)
        C + D => C

;;;;;;;;;
;; Txs Size Verification
;;;;;;;;;
        C => A
        $                               :MLOAD(txsListLength), ASSERT

;;;;;;;;;
;; Check batchHashData
;;;;;;;;;
        32 => D
        $ => A                          :MLOAD(globalExitRoot)
        A                               :HASHW(E)
        8 => D
        $ => A                          :MLOAD(timestamp)
        A                               :HASHW(E)
        20 => D
        $ => A                          :MLOAD(sequencerAddr)
        A                               :HASHW(E)
        8 => D
        $ => A                          :MLOAD(chainId)
        A                               :HASHW(E)
        $ => A                          :MLOAD(numBatch)
        A                               :HASHW(E)
                                        :HASHE(E)
        $ => A                          :MLOAD(batchHashData)
        $                               :HASHR(E), ASSERT

;;;;;;;
; Check Global Hash
;;;;;;;

        32 => D
        SR                                      :HASHW(0)

        32 => D
        $ => A                                  :MLOAD(newLocalExitRoot)
        A                                       :HASHW(0)

        32 => D
        $ => A                                  :MLOAD(batchHashData)
        A                                       :HASHW(0)

                                                :HASHE(0)

        $ => A                                  :MLOAD(globalHash)
        $                                       :HASHR(0), ASSERT

        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR                 ; Set all registers to 0

longLoop:
        STEP-0x10000+40  : JMPC(longLoop2)
                        : JMP(finalLoop)
longLoop2:
        0
        0
        0
        0       ; 4
        0
        0
        0
        0       ; 8
        0
        0
        0
        0       ; 12
        0
        0
        0
        0       ; 16
        0
        0
        0
        0       ; 20
        0
        0
        0
        0       ; 24
        0
        0
        0
        0       ; 28
        0
        0
        0
        0       : JMP(longLoop) ; 32


finalLoop:
;        STEP-0x800000+2  : JMPC(finalLoop)  ; 2**23
        STEP-0x10000+2  : JMPC(finalLoop)

                         : JMP(start)

INCLUDE "loadtx_rlp.zkasm"
INCLUDE "process_tx.zkasm"

opINVALID:

