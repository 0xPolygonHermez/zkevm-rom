INCLUDE "vars.zkasm"

start:
; First of all, load The call Data.  The first A value is forced with the hash of the TX.
        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash
        STEP => A
        1                                   :ASSERT                                ; Ensure it is the begining of the execution
        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)
        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

        32 => D
        $ => A                              :MLOAD(oldStateRoot)
        A                                   :HASHK(0)
        A => SR

        32 => D
        ${getOldLocalExitRoot()}  => A      :HASHK(0)
                                            :MSTORE(oldLocalExitRoot)

        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

        ${getBatchHashData()}               :MSTORE(batchHashData)

        ${getChainId()}                     :MSTORE(chainId)

        1000                                :MSTORE(defaultChainId)    ; Hardcoded default chain id
        0                                   :MSTORE(systemAddr)        ; Hardcoded default system address

        ;100                                 :MSTORE(SLOAD_GAS)
        ;20000                               :MSTORE(SSTORE_SET_GAS)
        ;2900                                :MSTORE(SSTORE_RESET_GAS)
        ;15000                               :MSTORE(SSTORE_CLEARS_SCHEDULE)

        ${getNumBatch()}                    :MSTORE(numBatch)

        ${getTimestamp()}                   :MSTORE(timestamp)

        ${getTxsLen()}                      :MSTORE(txsListLength)

        ; batch variables
        0                                   :MSTORE(batchDifficulty)
        30000000                            :MSTORE(batchGasLimit)



;;;;;;;;;
;; Set batch hash
;;;;;;;;;
        ; Save the position of the last hash (oldHashPos --> VAR GLOBAL)
        HASHPOS                             :MSTORE(oldHashPos)
        ; A new hash with position 0 is started
        0 => HASHPOS

        $ => E                              :MLOAD(lastHashIdUsed)
        E+1 => E                            :MSTORE(lastHashIdUsed)
        32 => D
        $ => A                              :MLOAD(numBatch)
        A - 1                               :HASHK(E)
        0                                   :HASHK(E)                  ; Storage position of the batch hash
        HASHPOS                             :HASHKLEN(E)
        $ => C                              :HASHKDIGEST(E)

        $ => A                              :MLOAD(systemAddr)
        3 => B
        $ => D                              :MLOAD(oldStateRoot)
        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

;;;;;;;;;
;; Set global exit root
;;;;;;;;;
        ; A new hash with position 0 is started
        0 => HASHPOS

        $ => E                              :MLOAD(lastHashIdUsed)
        E+1 => E                            :MSTORE(lastHashIdUsed)
        32 => D
        $ => A                              :MLOAD(numBatch)
        A                                   :HASHK(E)
        0                                   :HASHK(E)                  ; Storage position of the global exit root map
        HASHPOS                             :HASHKLEN(E)
        $ => C                              :HASHKDIGEST(E)            ; Storage position of the current global exit root

        ${getGlobalExitRootManagerAddr()}  => A
        3 => B
        $ => D                              :MLOAD(globalExitRoot)
        $ => SR                             :SSTORE

;;;;;;;;;
;; Prepare transaction loop
;;;;;;;;;
        $ => HASHPOS                        :MLOAD(oldHashPos)
        E                                   :MSTORE(lastTxHashId)
        $ => A                              :MLOAD(lastCtxUsed)
        A                                   :MSTORE(ctxTxToUse)

        $${var p = 0}

txLoopRLP:
        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
        A+1 => CTX      :MSTORE(lastCtxUsed)

        $ => A          :MLOAD(txsListLength)
        $ => C          :MLOAD(batchL2DataRead)
        C - A           :JMPC(loadTx_rlp)
                        :JMP(endCheckRLP)

endCheckRLP:
                        :JMP(txLoop)

txLoop:
        $ => A          :MLOAD(pendingTxs)
        A-1 =>  A       :MSTORE(pendingTxs)
        A               :JMPC(processTxsEnd)

        $ => A          :MLOAD(ctxTxToUse)                        ; Set the CTX and store in system
        A+1 => CTX      :MSTORE(ctxTxToUse)

                        :JMP(processTx)

processTxEnd:
                        :JMP(txLoop)

processTxsEnd:

;;;;;;;;;
;; Assert local exit root
;;;;;;;;;
        ${getGlobalExitRootManagerAddr()}  => A
        3 => B
        1 => C                                                         ; Storage position of the local exit root
        $ => A                          :SLOAD
        $                               :MLOAD(newLocalExitRoot), ASSERT


;;;;;;;;
; Get new hashId
;;;;;;;
        HASHPOS                         :MSTORE(oldHashPos)
        ; A new hash with position 0 is started
        0 => HASHPOS

        ; We get a new hashId
        $ => E                          :MLOAD(lastHashIdUsed)
        E+1 => E                        :MSTORE(lastHashIdUsed)

;;;;;;;;;
;; Append TXs
;;;;;;;;;
        $ => B                          :MLOAD(txsListLength)
        0 => C
        $${p = 0}

appendTxs:
        B - C - 32                      :JMPC(finalAppendTxs)
        32 => D
        ${getTxs(p,D)} => A
        $${p = p + D}
        A                               :HASHK(E)
        C + D => C
                                        :JMP(appendTxs)

finalAppendTxs:
        B - C => D
        D - 1                           :JMPC(endAppendTxs)
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHK(E)
        C + D => C

endAppendTxs:

;;;;;;;;;
;; Txs Size Verification
;;;;;;;;;
        C => A
        $                               :MLOAD(txsListLength), ASSERT

;;;;;;;;;
;; Check batchHashData
;;;;;;;;;
        32 => D
        $ => A                          :MLOAD(globalExitRoot)
        A                               :HASHK(E)
        8 => D
        $ => A                          :MLOAD(timestamp)
        A                               :HASHK(E)
        20 => D
        $ => A                          :MLOAD(sequencerAddr)
        A                               :HASHK(E)
        8 => D
        $ => A                          :MLOAD(chainId)
        A                               :HASHK(E)
        $ => A                          :MLOAD(numBatch)
        A                               :HASHK(E)
        HASHPOS                         :HASHKLEN(E)
        $ => A                          :MLOAD(batchHashData)
        $                               :HASHKDIGEST(E), ASSERT

;;;;;;;
; Check Global Hash
;;;;;;;

        ; Get position of the previous hash
        $ => HASHPOS                    :MLOAD(oldHashPos)

        32 => D
        SR                              :HASHK(0)

        $ => A                          :MLOAD(newLocalExitRoot)
        A                               :HASHK(0)

        $ => A                          :MLOAD(batchHashData)
        A                               :HASHK(0)

        HASHPOS                         :HASHKLEN(0)

        $ => A                          :MLOAD(globalHash)
        $                               :HASHKDIGEST(0), ASSERT

        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR, HASHPOS, RR                 ; Set all registers to 0

finalWait:
        ${beforeLast()}  : JMPC(finalWait)
                         : JMP(start)

INCLUDE "loadtx_rlp.zkasm"
INCLUDE "process_tx.zkasm"
INCLUDE "opcodes.zkasm"
