INCLUDE "vars.zkasm"

start:
; First of all, load The call Data.  The first A value is forced with the hash of the TX.
        ${getGlobalHash()}                  :MSTORE(globalHash)                    ; In A register we have the TXHash
        ${getGlobalExitRoot()}              :MSTORE(globalExitRoot)
        ${getOldStateRoot()}                :MSTORE(oldStateRoot)

        32 => D
        $ => A                              :MLOAD(oldStateRoot)
        A                                   :HASHW(0)
        A => SR

        32 => D
        ${getOldLocalExitRoot()}  => A      :HASHW(0)
                                            :MSTORE(oldLocalExitRoot)

        ${getNewLocalExitRoot()}            :MSTORE(newLocalExitRoot)

        ${getSequencerAddr()}               :MSTORE(sequencerAddr)

        ${getBatchHashData()}               :MSTORE(batchHashData)

        ${getChainId()}                     :MSTORE(chainId)

        1000                                :MSTORE(defaultChainId)    ; Hardcoded default chain id

        ;100                                 :MSTORE(SLOAD_GAS)
        ;20000                               :MSTORE(SSTORE_SET_GAS)
        ;2900                                :MSTORE(SSTORE_RESET_GAS)
        ;15000                               :MSTORE(SSTORE_CLEARS_SCHEDULE)

        ${getNumBatch()}                    :MSTORE(numBatch)

        ${getTimestamp()}                   :MSTORE(timestamp)

        ${getTxsLen()}                      :MSTORE(txsListLength)

        ; batch variables
        0                                   :MSTORE(batchDifficulty)
        30000000                            :MSTORE(batchGasLimit)



;;;;;;;;;
;; Set batch hash
;;;;;;;;;
        $ => E                              :MLOAD(lastHashIdUsed)
        E+1 => E                            :MSTORE(lastHashIdUsed)
        32 => D
        $ => A                              :MLOAD(numBatch)
        A - 1                               :HASHW(E)
        0                                   :HASHW(E)                  ; Storage position of the batch hash
                                            :HASHE(E)
        $ => C                              :HASHR(E)

        0 => A                                                         ; Address System contract 0x0000000000000000000000000000000000000000
        3 => B
        $ => D                              :MLOAD(oldStateRoot)
        $ => SR                             :SSTORE                    ; Store 'oldStateRoot' in storage position 'keccak256(numBatch - 1, 0)'

;;;;;;;;;
;; Set global exit root
;;;;;;;;;
        $ => E                              :MLOAD(lastHashIdUsed)
        E+1 => E                            :MSTORE(lastHashIdUsed)
        32 => D
        $ => A                              :MLOAD(numBatch)
        A                                   :HASHW(E)
        0                                   :HASHW(E)                  ; Storage position of the global exit root map
                                            :HASHE(E)
        $ => C                              :HASHR(E)                  ; Storage position of the current global exit root

        ${getGlobalExitRootManagerAddr()}  => A
        3 => B
        $ => D                              :MLOAD(globalExitRoot)
        $ => SR                             :SSTORE

;;;;;;;;;
;; Prepare transaction loop
;;;;;;;;;
        E                                   :MSTORE(lastTxHashId)
        $ => A                              :MLOAD(lastCtxUsed)
        A                                   :MSTORE(firstCtxUsed)

        $${var p = 0}

txLoopRLP:
        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
        A+1 => CTX      :MSTORE(lastCtxUsed)

        $ => A          :MLOAD(txsListLength)
        $ => C          :MLOAD(batchL2DataRead)
        C - A           :JMPC(loadTx_rlp)
                        :JMP(endCheckRLP)

endCheckRLP:
        $ => A          :MLOAD(firstCtxUsed)
        A               :MSTORE(lastCtxUsed)
                        :JMP(txLoop)

txLoop:
        $ => A          :MLOAD(pendingTxs)
        A-1 =>  A       :MSTORE(pendingTxs)
        A               :JMPC(processTxsEnd)

        $ => A          :MLOAD(lastCtxUsed)                           ; Set the CTX and store in system
        A+1 => CTX      :MSTORE(lastCtxUsed)

                        :JMP(processTx)

processTxEnd:
                        :JMP(txLoop)

processTxsEnd:

;;;;;;;;;
;; Assert local exit root
;;;;;;;;;
        ${getGlobalExitRootManagerAddr()}  => A
        3 => B
        1 => C                                                         ; Storage position of the local exit root
        $ => A                          :SLOAD
        $                               :MLOAD(newLocalExitRoot), ASSERT


;;;;;;;;
; Get new hashId
;;;;;;;
        ; We get a new hashId
        $ => E                          :MLOAD(lastHashIdUsed)
        E+1 => E                        :MSTORE(lastHashIdUsed)

;;;;;;;;;
;; Append TXs
;;;;;;;;;
        $ => B                          :MLOAD(txsListLength)
        0 => C
        $${p = 0}

appendTxs:
        B - C - 32                      :JMPC(endAppendTxs)
        32 => D
        ${getTxs(p,D)} => A
        $${p = p + D}
        A                               :HASHW(E)
        C + D => C
                                        :JMP(appendTxs)

endAppendTxs:
        B - C => D
        ${getTxs(p,D)} => A
        $${ p = p + D}
        A                               :HASHW(E)
        C + D => C

;;;;;;;;;
;; Txs Size Verification
;;;;;;;;;
        C => A
        $                               :MLOAD(txsListLength), ASSERT

;;;;;;;;;
;; Check batchHashData
;;;;;;;;;
        32 => D
        $ => A                          :MLOAD(globalExitRoot)
        A                               :HASHW(E)
        8 => D
        $ => A                          :MLOAD(timestamp)
        A                               :HASHW(E)
        20 => D
        $ => A                          :MLOAD(sequencerAddr)
        A                               :HASHW(E)
        8 => D
        $ => A                          :MLOAD(chainId)
        A                               :HASHW(E)
        $ => A                          :MLOAD(numBatch)
        A                               :HASHW(E)
                                        :HASHE(E)
        $ => A                          :MLOAD(batchHashData)
        $                               :HASHR(E), ASSERT

;;;;;;;
; Check Global Hash
;;;;;;;

        32 => D
        SR                                      :HASHW(0)

        $ => A                                  :MLOAD(newLocalExitRoot)
        A                                       :HASHW(0)

        $ => A                                  :MLOAD(batchHashData)
        A                                       :HASHW(0)

                                                :HASHE(0)

        $ => A                                  :MLOAD(globalHash)
        $                                       :HASHR(0), ASSERT

        0 => A,B,C,D,E,CTX, SP, PC, GAS, MAXMEM, SR                 ; Set all registers to 0

longLoop:
        STEP-0x10000+40  : JMPC(longLoop2)
                        : JMP(finalLoop)
longLoop2:
        0
        0
        0
        0       ; 4
        0
        0
        0
        0       ; 8
        0
        0
        0
        0       ; 12
        0
        0
        0
        0       ; 16
        0
        0
        0
        0       ; 20
        0
        0
        0
        0       ; 24
        0
        0
        0
        0       ; 28
        0
        0
        0
        0       : JMP(longLoop) ; 32


finalLoop:
;        STEP-0x800000+2  : JMPC(finalLoop)  ; 2**23
        STEP-0x10000+2  : JMPC(finalLoop)

                         : JMP(start)

INCLUDE "loadtx_rlp.zkasm"
INCLUDE "process_tx.zkasm"
INCLUDE "opcodes.zkasm"

opINVALID:

